<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Feign基本使用</title>
    <url>/2021/11/09/Feign%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Feign基本使用"><a href="#Feign基本使用" class="headerlink" title="Feign基本使用"></a>Feign基本使用</h1><h2 id="1、功能概述"><a href="#1、功能概述" class="headerlink" title="1、功能概述"></a>1、功能概述</h2><p><img src="https://camo.githubusercontent.com/f1bd8b9bfe3c049484b0776b42668bb76a57872fe0f01402e5ef73d29b811e50/687474703a2f2f7777772e706c616e74756d6c2e636f6d2f706c616e74756d6c2f70726f78793f63616368653d6e6f267372633d68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f4f70656e466569676e2f666569676e2f6d61737465722f7372632f646f63732f6f766572766965772d6d696e646d61702e69756d6c" alt="img"></p>
<h2 id="2、自定义错误处理"><a href="#2、自定义错误处理" class="headerlink" title="2、自定义错误处理"></a>2、自定义错误处理</h2><p>Feign（默认配置）对于所有错误情况只抛出FeignException异常，但是如果你想处理一个特殊的异常，可以通过在Feign.builder.errorDecoder()实现feign.codec.ErrorDecoder接口来达到目的。</p>
<p>例子：</p>
<p>自定义错误处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StashErrorDecoder</span> <span class="keyword">implements</span> <span class="title">ErrorDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exception <span class="title">decode</span><span class="params">(String methodKey, Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (response.status() &gt;= <span class="number">400</span> &amp;&amp; response.status() &lt;= <span class="number">499</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StashClientException(</span><br><span class="line">                    response.status(),</span><br><span class="line">                    response.reason()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (response.status() &gt;= <span class="number">500</span> &amp;&amp; response.status() &lt;= <span class="number">599</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StashServerException(</span><br><span class="line">                    response.status(),</span><br><span class="line">                    response.reason()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> errorStatus(methodKey, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用错误处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Feign.builder()</span><br><span class="line">                .errorDecoder(<span class="keyword">new</span> StashErrorDecoder())</span><br><span class="line">                .target(StashApi.class, url);</span><br></pre></td></tr></table></figure>

<h2 id="3、基本用法"><a href="#3、基本用法" class="headerlink" title="3、基本用法"></a>3、基本用法</h2><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span></span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(<span class="meta">@Param(&quot;owner&quot;)</span> String owner, <span class="meta">@Param(&quot;repo&quot;)</span> String repo)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /repos/&#123;owner&#125;/&#123;repo&#125;/issues&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createIssue</span><span class="params">(Issue issue, <span class="meta">@Param(&quot;owner&quot;)</span> String owner, <span class="meta">@Param(&quot;repo&quot;)</span> String repo)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Contributor</span> </span>&#123;</span><br><span class="line">  String login;</span><br><span class="line">  <span class="keyword">int</span> contributions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Issue</span> </span>&#123;</span><br><span class="line">  String title;</span><br><span class="line">  String body;</span><br><span class="line">  List&lt;String&gt; assignees;</span><br><span class="line">  <span class="keyword">int</span> milestone;</span><br><span class="line">  List&lt;String&gt; labels;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                         .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                         .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fetch and print a list of the contributors to this library.</span></span><br><span class="line">    List&lt;Contributor&gt; contributors = github.contributors(<span class="string">&quot;OpenFeign&quot;</span>, <span class="string">&quot;feign&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">      System.out.println(contributor.login + <span class="string">&quot; (&quot;</span> + contributor.contributions + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1、接口注解"><a href="#3-1、接口注解" class="headerlink" title="3.1、接口注解"></a>3.1、接口注解</h3><p>Feign的Contract定义的注解规定了底层客户端和接口之间如何工作。</p>
<p>Feign的默认Contract定义了以下注解：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>接口对象</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestLine</td>
<td>Method</td>
<td>为请求定义 HttpMethod 和 UriTemplate。表达式，用大括号 {expression} 包裹的值使用其相应的 @Param 注释参数解析。</td>
</tr>
<tr>
<td>@Param</td>
<td>Parameter</td>
<td>定义一个模板变量，其值将用于解析相应的模板表达式，按名称提供作为注释值。 如果缺少值，它将尝试从字节码方法参数名称中获取名称（如果代码是使用 -parameters 标志编译的）。</td>
</tr>
<tr>
<td>@Headers</td>
<td>Method, Type</td>
<td>定义一个 HeaderTemplate； UriTemplate 的变体。使用@Param 注释值来解析相应的表达式。在 Type 上使用时，模板将应用于每个请求。当在method上使用时，模板将仅适用于带注释的方法。</td>
</tr>
<tr>
<td>@QueryMap</td>
<td>Parameter</td>
<td>定义名称-值对的 Map 或 POJO，以扩展为查询字符串。</td>
</tr>
<tr>
<td>@HeaderMap</td>
<td>Parameter</td>
<td>定义一个名称-值对的 Map，以扩展到 Http Headers。</td>
</tr>
<tr>
<td>@Body</td>
<td>Method</td>
<td>定义一个模板，类似于 UriTemplate 和 HeaderTemplate，它使用@Param 注释值来解析相应的表达式。</td>
</tr>
</tbody></table>
<h3 id="3-2、模板和表达式"><a href="#3-2、模板和表达式" class="headerlink" title="3.2、模板和表达式"></a>3.2、模板和表达式</h3><p>Feign 表达式表示由 URI Template - RFC 6570 定义的简单字符串表达式（Level 1）。表达式使用其相应的 Param 注释方法参数进行扩展。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span></span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(<span class="meta">@Param(&quot;owner&quot;)</span> String owner, <span class="meta">@Param(&quot;repo&quot;)</span> String repository)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contributor</span> </span>&#123;</span><br><span class="line">    String login;</span><br><span class="line">    <span class="keyword">int</span> contributions;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                         .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                         .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The owner and repository parameters will be used to expand the owner and repo expressions</span></span><br><span class="line"><span class="comment">     * defined in the RequestLine.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * the resulting uri will be https://api.github.com/repos/OpenFeign/feign/contributors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    github.contributors(<span class="string">&quot;OpenFeign&quot;</span>, <span class="string">&quot;feign&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表达式必须用大括号 {} 括起来，并且可以包含正则表达式模式，用冒号 : 分隔以限制解析的值。示例owner必须按字母顺序排列。 {owner：[a-zA-Z]*}</p>
<h3 id="3-3、请求参数扩展"><a href="#3-3、请求参数扩展" class="headerlink" title="3.3、请求参数扩展"></a>3.3、请求参数扩展</h3><p>RequestLine 和 QueryMap 模板遵循 URI Template - RFC 6570 Level 1 模板规范，其中指定了以下内容：</p>
<ul>
<li>未解析的表达式被省略。</li>
<li>所有文字和变量值都是 pct 编码的，如果尚未编码或标记为通过 @Param 注释编码。</li>
</ul>
<h3 id="3-4、未定义与空值"><a href="#3-4、未定义与空值" class="headerlink" title="3.4、未定义与空值"></a>3.4、未定义与空值</h3><p>未定义的表达式是表达式的值为显式 null 或未提供值的表达式。根据 URI Template - RFC 6570，可以为表达式提供空值。 Feign 解析表达式时，它首先确定该值是否已定义，如果已定义，则查询参数将保留。如果表达式未定义，则删除查询参数。请参阅下面的完整细分。</p>
<p>空字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Map&lt;String, Object&gt; parameters = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">   parameters.put(<span class="string">&quot;param&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">   <span class="keyword">this</span>.demoClient.test(parameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/test?param=</span></span><br></pre></td></tr></table></figure>

<p>丢失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Map&lt;String, Object&gt; parameters = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">   <span class="keyword">this</span>.demoClient.test(parameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/test</span></span><br></pre></td></tr></table></figure>

<p>未定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Map&lt;String, Object&gt; parameters = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">   parameters.put(<span class="string">&quot;param&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">this</span>.demoClient.test(parameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/test</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5、自定义扩展"><a href="#3-5、自定义扩展" class="headerlink" title="3.5、自定义扩展"></a>3.5、自定义扩展</h3><p>@Param 注释有一个可选的属性扩展器，允许完全控制单个参数的扩展。 expander 属性必须引用一个实现 Expander 接口的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expander</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">expand</span><span class="params">(Object value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6、请求标头扩展"><a href="#3-6、请求标头扩展" class="headerlink" title="3.6、请求标头扩展"></a>3.6、请求标头扩展</h3><p>Headers 和 HeaderMap 模板遵循与请求参数扩展相同的规则，但有以下变化：</p>
<ul>
<li>未解析的表达式被省略。如果结果是一个空的标头值，则整个标头将被删除。</li>
<li>不执行 pct 编码。</li>
</ul>
<p>关于@Param 参数及其名称的说明：</p>
<p>所有具有相同名称的表达式，无论它们在 @RequestLine、@QueryMap、@BodyTemplate 或 @Headers 上的位置如何，都将解析为相同的值。在以下示例中，contentType 的值将用于解析标头和路径表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContentService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /api/documents/&#123;contentType&#125;&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Accept: &#123;contentType&#125;&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">getDocumentByType</span><span class="params">(<span class="meta">@Param(&quot;contentType&quot;)</span> String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7、请求正文扩展"><a href="#3-7、请求正文扩展" class="headerlink" title="3.7、请求正文扩展"></a>3.7、请求正文扩展</h3><p>正文模板遵循与请求参数扩展相同的规则，但有以下更改：</p>
<ul>
<li>未解析的表达式被省略。</li>
<li>扩展的值在放置到请求正文之前不会通过编码器传递。</li>
<li>必须指定 Content-Type 标头。</li>
</ul>
<h3 id="3-8、定制"><a href="#3-8、定制" class="headerlink" title="3.8、定制"></a>3.8、定制</h3><p>Feign 有几个方面可以定制。 对于简单的情况，您可以使用 Feign.builder() 来构建带有自定义组件的 API 接口。 对于请求设置，您可以使用 target() 上的 options(Request.Options options) 来设置 connectTimeout、connectTimeoutUnit、readTimeout、readTimeoutUnit、followRedirects。 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /account/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="function">Account <span class="title">getAccountInfo</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bank bank = Feign.builder()</span><br><span class="line">        .decoder(<span class="keyword">new</span> AccountDecoder())</span><br><span class="line">        .options(<span class="keyword">new</span> Request.Options(<span class="number">10</span>, TimeUnit.SECONDS, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">true</span>))</span><br><span class="line">        .target(Bank.class, <span class="string">&quot;https://api.examplebank.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9、多个接口"><a href="#3-9、多个接口" class="headerlink" title="3.9、多个接口"></a>3.9、多个接口</h3><p>Feign 可以产生多个 api 接口。这些被定义为 Target<T>（默认 HardCodedTarget<T>），允许在执行之前动态发现和修饰请求。 例如，以下模式可能会使用来自身份服务的当前 url 和身份验证令牌来修饰每个请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CloudDNS cloudDNS = Feign.builder()</span><br><span class="line">      .target(<span class="keyword">new</span> CloudIdentityTarget&lt;CloudDNS&gt;(user, apiKey));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CloudIdentityTarget</span> <span class="keyword">extends</span> <span class="title">Target</span>&lt;<span class="title">CloudDNS</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/* implementation of a Target */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-10、集成"><a href="#3-10、集成" class="headerlink" title="3.10、集成"></a>3.10、集成</h3><h4 id="3-10-1、Gson"><a href="#3-10-1、Gson" class="headerlink" title="3.10.1、Gson"></a>3.10.1、Gson</h4><p>Gson 包含一个编码器和解码器，您可以将其与 JSON API 一起使用。 像这样将 GsonEncoder 和/或 GsonDecoder 添加到 Feign.Builder 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GsonCodec codec = <span class="keyword">new</span> GsonCodec();</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                         .encoder(<span class="keyword">new</span> GsonEncoder())</span><br><span class="line">                         .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                         .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-2、Jackson"><a href="#3-10-2、Jackson" class="headerlink" title="3.10.2、Jackson"></a>3.10.2、Jackson</h4><p>Jackson 包含一个编码器和解码器，您可以将其与 JSON API 一起使用。 将 JacksonEncoder 和/或 JacksonDecoder 添加到您的 Feign.Builder 中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      GitHub github = Feign.builder()</span><br><span class="line">                     .encoder(<span class="keyword">new</span> JacksonEncoder())</span><br><span class="line">                     .decoder(<span class="keyword">new</span> JacksonDecoder())</span><br><span class="line">                     .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-3、Sax"><a href="#3-10-3、Sax" class="headerlink" title="3.10.3、Sax"></a>3.10.3、Sax</h4><p>SaxDecoder 允许您以与普通 JVM 和 Android 环境兼容的方式解码 XML。 以下是如何配置 Sax 响应解析的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Api api = Feign.builder()</span><br><span class="line">         .decoder(SAXDecoder.builder()</span><br><span class="line">                            .registerContentHandler(UserIdHandler.class)</span><br><span class="line">                            .build())</span><br><span class="line">         .target(Api.class, <span class="string">&quot;https://apihost&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-4、JAXB"><a href="#3-10-4、JAXB" class="headerlink" title="3.10.4、JAXB"></a>3.10.4、JAXB</h4><p>JAXB 包括可与 XML API 一起使用的编码器和解码器。 将 JAXBEncoder 和/或 JAXBDecoder 添加到您的 Feign.Builder 中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Api api = Feign.builder()</span><br><span class="line">             .encoder(<span class="keyword">new</span> JAXBEncoder())</span><br><span class="line">             .decoder(<span class="keyword">new</span> JAXBDecoder())</span><br><span class="line">             .target(Api.class, <span class="string">&quot;https://apihost&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-5、JAX-RS"><a href="#3-10-5、JAX-RS" class="headerlink" title="3.10.5、JAX-RS"></a>3.10.5、JAX-RS</h4><p>JAXRSContract 覆盖注解处理以使用 JAX-RS 规范提供的标准处理。这是目前针对 1.1 规范的目标。 这是上面重写的示例以使用 JAX-RS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span> <span class="meta">@Path(&quot;/repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span></span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(<span class="meta">@PathParam(&quot;owner&quot;)</span> String owner, <span class="meta">@PathParam(&quot;repo&quot;)</span> String repo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                       .contract(<span class="keyword">new</span> JAXRSContract())</span><br><span class="line">                       .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-6、OkHttp"><a href="#3-10-6、OkHttp" class="headerlink" title="3.10.6、OkHttp"></a>3.10.6、OkHttp</h4><p>OkHttpClient 将 Feign 的 http 请求定向到 OkHttp，从而实现 SPDY 和更好的网络控制。 要将 OkHttp 与 Feign 一起使用，请将 OkHttp 模块添加到您的类路径中。然后，配置 Feign 以使用 OkHttpClient：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                     .client(<span class="keyword">new</span> OkHttpClient())</span><br><span class="line">                     .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-7、Ribbon"><a href="#3-10-7、Ribbon" class="headerlink" title="3.10.7、Ribbon"></a>3.10.7、Ribbon</h4><p>RibbonClient 覆盖了 Feign 客户端的 URL 解析，增加了 Ribbon 提供的智能路由和弹性能力。 集成要求您将功能区客户端名称作为 url 的主机部分传递，例如 myAppProd。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyService api = Feign.builder()</span><br><span class="line">          .client(RibbonClient.create())</span><br><span class="line">          .target(MyService.class, <span class="string">&quot;https://myAppProd&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-8、Java-11-Http2"><a href="#3-10-8、Java-11-Http2" class="headerlink" title="3.10.8、Java 11 Http2"></a>3.10.8、Java 11 Http2</h4><p>Http2Client 将 Feign 的 http 请求定向到实现 HTTP/2 的 Java11 New HTTP/2 Client。 要将新 HTTP/2 客户端与 Feign 一起使用，请使用 Java SDK 11。然后，将 Feign 配置为使用 Http2Client：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .client(<span class="keyword">new</span> Http2Client())</span><br><span class="line">                     .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-10-9、Hystrix"><a href="#3-10-9、Hystrix" class="headerlink" title="3.10.9、Hystrix"></a>3.10.9、Hystrix</h4><p>HystrixFeign 配置了 Hystrix 提供的断路器支持。 要将 Hystrix 与 Feign 一起使用，请将 Hystrix 模块添加到您的类路径中。然后使用 HystrixFeign 构建器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyService api = HystrixFeign.builder().target(MyService.class, <span class="string">&quot;https://myAppProd&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-10、SOAP"><a href="#3-10-10、SOAP" class="headerlink" title="3.10.10、SOAP"></a>3.10.10、SOAP</h4><p>SOAP 包括可以与 XML API 一起使用的编码器和解码器。 该模块添加了对通过 JAXB 和 SOAPMessage 编码和解码 SOAP Body 对象的支持。它还通过将它们包装到原始 javax.xml.ws.soap.SOAPFaultException 中来提供 SOAPFault 解码功能，因此您只需捕获 SOAPFaultException 即可处理 SOAPFault。 像这样将 SOAPEncoder 和/或 SOAPDecoder 添加到你的 Feign.Builder 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Api api = Feign.builder()</span><br><span class="line">	     .encoder(<span class="keyword">new</span> SOAPEncoder(jaxbFactory))</span><br><span class="line">	     .decoder(<span class="keyword">new</span> SOAPDecoder(jaxbFactory))</span><br><span class="line">	     .errorDecoder(<span class="keyword">new</span> SOAPErrorDecoder())</span><br><span class="line">	     .target(MyApi.class, <span class="string">&quot;http://api&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-11、SLF4J"><a href="#3-10-11、SLF4J" class="headerlink" title="3.10.11、SLF4J"></a>3.10.11、SLF4J</h4><p>SLF4JModule 允许将 Feign 的日志记录定向到 SLF4J，允许您轻松使用您选择的日志记录后端（Logback、Log4J 等） 要将 SLF4J 与 Feign 一起使用，请将 SLF4J 模块和您选择的 SLF4J 绑定添加到您的类路径中。然后，配置 Feign 以使用 Slf4jLogger：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                     .logger(<span class="keyword">new</span> Slf4jLogger())</span><br><span class="line">                     .logLevel(Level.FULL)</span><br><span class="line">                     .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-11、解码器"><a href="#3-11、解码器" class="headerlink" title="3.11、解码器"></a>3.11、解码器</h3><p>Feign.builder() 允许您指定其他配置，例如如何解码响应。 如果接口中的任何方法返回 Response、String、byte[] 或 void 之外的类型，则需要配置非默认解码器。 下面是如何配置 JSON 解码（使用 feign-gson 扩展）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                     .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                     .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您需要在将响应提供给解码器之前对其进行预处理，则可以使用 mapAndDecode 构建器方法。一个示例用例是处理仅提供 jsonp 的 API，您可能需要在将其发送到您选择的 Json 解码器之前解开 jsonp：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JsonpApi jsonpApi = Feign.builder()</span><br><span class="line">                         .mapAndDecode((response, type) -&gt; jsopUnwrap(response, type), <span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                         .target(JsonpApi.class, <span class="string">&quot;https://some-jsonp-api.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-12、编码器"><a href="#3-12、编码器" class="headerlink" title="3.12、编码器"></a>3.12、编码器</h3><p>将请求正文发送到服务器的最简单方法是定义一个 POST 方法，该方法有一个 String 或 byte[] 参数，上面没有任何注释。您可能需要添加一个 Content-Type 标头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: application/json&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    client.login(<span class="string">&quot;&#123;\&quot;user_name\&quot;: \&quot;denominator\&quot;, \&quot;password\&quot;: \&quot;secret\&quot;&#125;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过配置编码器，您可以发送类型安全的请求正文。这是使用 feign-gson 扩展的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Credentials</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String user_name;</span><br><span class="line">  <span class="keyword">final</span> String password;</span><br><span class="line"></span><br><span class="line">  Credentials(String user_name, String password) &#123;</span><br><span class="line">    <span class="keyword">this</span>.user_name = user_name;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(Credentials creds)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LoginClient client = Feign.builder()</span><br><span class="line">                              .encoder(<span class="keyword">new</span> GsonEncoder())</span><br><span class="line">                              .target(LoginClient.class, <span class="string">&quot;https://foo.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    client.login(<span class="keyword">new</span> Credentials(<span class="string">&quot;denominator&quot;</span>, <span class="string">&quot;secret&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-13、-Body-模板"><a href="#3-13、-Body-模板" class="headerlink" title="3.13、@Body 模板"></a>3.13、@Body 模板</h3><p>@Body 注释指示使用@Param 注释的参数扩展的模板。您可能需要添加一个 Content-Type 标头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: application/xml&quot;)</span></span><br><span class="line">  <span class="meta">@Body(&quot;&lt;login \&quot;user_name\&quot;=\&quot;&#123;user_name&#125;\&quot; \&quot;password\&quot;=\&quot;&#123;password&#125;\&quot;/&gt;&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">xml</span><span class="params">(<span class="meta">@Param(&quot;user_name&quot;)</span> String user, <span class="meta">@Param(&quot;password&quot;)</span> String password)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: application/json&quot;)</span></span><br><span class="line">  <span class="comment">// json curly braces must be escaped!</span></span><br><span class="line">  <span class="meta">@Body(&quot;%7B\&quot;user_name\&quot;: \&quot;&#123;user_name&#125;\&quot;, \&quot;password\&quot;: \&quot;&#123;password&#125;\&quot;%7D&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">json</span><span class="params">(<span class="meta">@Param(&quot;user_name&quot;)</span> String user, <span class="meta">@Param(&quot;password&quot;)</span> String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    client.xml(<span class="string">&quot;denominator&quot;</span>, <span class="string">&quot;secret&quot;</span>); <span class="comment">// &lt;login &quot;user_name&quot;=&quot;denominator&quot; &quot;password&quot;=&quot;secret&quot;/&gt;</span></span><br><span class="line">    client.json(<span class="string">&quot;denominator&quot;</span>, <span class="string">&quot;secret&quot;</span>); <span class="comment">// &#123;&quot;user_name&quot;: &quot;denominator&quot;, &quot;password&quot;: &quot;secret&quot;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-14、请求头"><a href="#3-14、请求头" class="headerlink" title="3.14、请求头"></a>3.14、请求头</h3><p>Feign 支持请求的设置标头作为 api 的一部分或作为客户端的一部分，具体取决于用例。</p>
<h4 id="3-14-1、使用-apis-设置标题"><a href="#3-14-1、使用-apis-设置标题" class="headerlink" title="3.14.1、使用 apis 设置标题"></a>3.14.1、使用 apis 设置标题</h4><p>在特定接口或调用应始终设置某些标头值的情况下，将标头定义为 api 的一部分是有意义的。 可以使用 @Headers 注释在 api 接口或方法上设置静态标头。</p>
<p>可以使用 @Headers 注释在 api 接口或方法上设置静态标头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Headers(&quot;Accept: application/json&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseApi</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: application/json&quot;)</span></span><br><span class="line">  <span class="meta">@RequestLine(&quot;PUT /api/&#123;key&#125;&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="meta">@Param(&quot;key&quot;)</span> String key, V value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法可以使用@Headers 中的变量扩展为静态标题指定动态内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestLine(&quot;POST /&quot;)</span></span><br><span class="line">   <span class="meta">@Headers(&quot;X-Ping: &#123;token&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="meta">@Param(&quot;token&quot;)</span> String token)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果标头字段键和值都是动态的，并且可能键的范围无法提前知道，并且可能因同一 api/客户端中的不同方法调用而异（例如自定义元数据标头字段，例如“x-amz- meta-<em>“ 或 “x-goog-meta-</em>“)，可以使用 HeaderMap 对 Map 参数进行注释，以构造使用地图内容作为其标头参数的查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestLine(&quot;POST /&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="meta">@HeaderMap</span> Map&lt;String, Object&gt; headerMap)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法将标头条目指定为 api 的一部分，并且在构建 Feign 客户端时不需要任何自定义。</p>
<h4 id="3-14-2、为每个目标设置请求头"><a href="#3-14-2、为每个目标设置请求头" class="headerlink" title="3.14.2、为每个目标设置请求头"></a>3.14.2、为每个目标设置请求头</h4><p>要为 Target 上的每个请求方法自定义请求头，可以使用 RequestInterceptor。 RequestInterceptors 可以跨 Target 实例共享，并且应该是线程安全的。 RequestInterceptors 应用于 Target 上的所有请求方法。 如果您需要按方法自定义，则需要自定义 Target，因为 RequestInterceptor 无权访问当前方法元数据。 有关使用 RequestInterceptor 设置标头的示例，请参阅请求拦截器部分。 请求头可以设置为自定义目标的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAuthTokenTarget</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Target</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicAuthTokenTarget</span><span class="params">(Class&lt;T&gt; clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  UrlAndTokenProvider provider,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  ThreadLocal&lt;String&gt; requestIdProvider)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">apply</span><span class="params">(RequestTemplate input)</span> </span>&#123;</span><br><span class="line">      TokenIdAndPublicURL urlAndToken = provider.get();</span><br><span class="line">      <span class="keyword">if</span> (input.url().indexOf(<span class="string">&quot;http&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        input.insert(<span class="number">0</span>, urlAndToken.publicURL);</span><br><span class="line">      &#125;</span><br><span class="line">      input.header(<span class="string">&quot;X-Auth-Token&quot;</span>, urlAndToken.tokenId);</span><br><span class="line">      input.header(<span class="string">&quot;X-Request-ID&quot;</span>, requestIdProvider.get());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> input.request();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Bank bank = Feign.builder()</span><br><span class="line">              .target(<span class="keyword">new</span> DynamicAuthTokenTarget(Bank.class, provider, requestIdProvider));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这些方法取决于在构建 Feign 客户端时在 Feign 客户端上设置的自定义 RequestInterceptor 或 Target，并且可以用作在每个客户端的基础上在所有 api 调用上设置标头的方法。这对于执行诸如在每个客户端的所有 api 请求的标头中设置身份验证令牌等操作非常有用。当在调用 api 调用的线程上进行 api 调用时运行这些方法，这允许在调用时以特定于上下文的方式动态设置标头——例如，线程本地存储可用于根据调用线程设置不同的标头值，这对于诸如为请求设置线程特定的跟踪标识符之类的事情很有用。</p>
<h2 id="4、高级用法"><a href="#4、高级用法" class="headerlink" title="4、高级用法"></a>4、高级用法</h2><h3 id="4-1、基础Apis"><a href="#4-1、基础Apis" class="headerlink" title="4.1、基础Apis"></a>4.1、基础Apis</h3><p>在许多情况下，服务的 api 遵循相同的约定。 Feign 通过单继承接口支持这种模式。 考虑这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseAPI</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /health&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">health</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /all&quot;)</span></span><br><span class="line">  <span class="function">List&lt;Entity&gt; <span class="title">all</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以定义和定位特定的 api，继承基本方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomAPI</span> <span class="keyword">extends</span> <span class="title">BaseAPI</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /custom&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">custom</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在许多情况下，资源表示也是一致的。因此，基本 api 接口支持类型参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Headers(&quot;Accept: application/json&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseApi</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /api/&#123;key&#125;&quot;)</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(<span class="meta">@Param(&quot;key&quot;)</span> String key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /api&quot;)</span></span><br><span class="line">  <span class="function">List&lt;V&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: application/json&quot;)</span></span><br><span class="line">  <span class="meta">@RequestLine(&quot;PUT /api/&#123;key&#125;&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="meta">@Param(&quot;key&quot;)</span> String key, V value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FooApi</span> <span class="keyword">extends</span> <span class="title">BaseApi</span>&lt;<span class="title">Foo</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BarApi</span> <span class="keyword">extends</span> <span class="title">BaseApi</span>&lt;<span class="title">Bar</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2、日志记录"><a href="#4-2、日志记录" class="headerlink" title="4.2、日志记录"></a>4.2、日志记录</h3><p>您可以通过设置 Logger 来记录进出目标的 http 消息。这是最简单的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                     .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                     .logger(<span class="keyword">new</span> Logger.JavaLogger(<span class="string">&quot;GitHub.Logger&quot;</span>).appendToFile(<span class="string">&quot;logs/http.log&quot;</span>))</span><br><span class="line">                     .logLevel(Logger.Level.FULL)</span><br><span class="line">                     .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 JavaLogger 的注意事项：避免使用默认的 JavaLogger() 构造函数 - 它被标记为已弃用，很快将被删除。</p>
<h3 id="4-3、请求拦截器"><a href="#4-3、请求拦截器" class="headerlink" title="4.3、请求拦截器"></a>4.3、请求拦截器</h3><p>当您需要更改所有请求时，无论其目标是什么，您都需要配置一个 RequestInterceptor。例如，如果您充当中介，您可能想要传播 X-Forwarded-For 标头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardedForInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">    template.header(<span class="string">&quot;X-Forwarded-For&quot;</span>, <span class="string">&quot;origin.host.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bank bank = Feign.builder()</span><br><span class="line">                 .decoder(accountDecoder)</span><br><span class="line">                 .requestInterceptor(<span class="keyword">new</span> ForwardedForInterceptor())</span><br><span class="line">                 .target(Bank.class, <span class="string">&quot;https://api.examplebank.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器的另一个常见示例是身份验证，例如使用内置的 BasicAuthRequestInterceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bank bank = Feign.builder()</span><br><span class="line">                 .decoder(accountDecoder)</span><br><span class="line">                 .requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(username, password))</span><br><span class="line">                 .target(Bank.class, <span class="string">&quot;https://api.examplebank.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4、自定义-Param-扩展"><a href="#4-4、自定义-Param-扩展" class="headerlink" title="4.4、自定义@Param 扩展"></a>4.4、自定义@Param 扩展</h3><p>使用 Param 注释的参数基于它们的 toString 展开。通过指定自定义 Param.Expander，用户可以控制此行为，例如格式化日期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /?since=&#123;date&#125;&quot;)</span> <span class="function">Result <span class="title">list</span><span class="params">(<span class="meta">@Param(value = &quot;date&quot;, expander = DateToMillis.class)</span> Date date)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5、动态查询参数"><a href="#4-5、动态查询参数" class="headerlink" title="4.5、动态查询参数"></a>4.5、动态查询参数</h3><p>可以使用 QueryMap 对 Map 参数进行注释，以构造使用地图内容作为其查询参数的查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /find&quot;)</span></span><br><span class="line">  <span class="function">V <span class="title">find</span><span class="params">(<span class="meta">@QueryMap</span> Map&lt;String, Object&gt; queryMap)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也可用于使用 QueryMapEncoder 从 POJO 对象生成查询参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /find&quot;)</span></span><br><span class="line">  <span class="function">V <span class="title">find</span><span class="params">(<span class="meta">@QueryMap</span> CustomPojo customPojo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以这种方式使用时，在不指定自定义 QueryMapEncoder 的情况下，将使用成员变量名称作为查询参数名称生成查询映射。下面的 POJO 将生成“/find?name={name}&amp;number={number}”的查询参数（不保证包含的查询参数的顺序，和往常一样，如果任何值为空，它将被排除在外）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPojo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CustomPojo</span> <span class="params">(String name, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.number = number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要设置自定义 QueryMapEncoder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyApi myApi = Feign.builder()</span><br><span class="line">                 .queryMapEncoder(<span class="keyword">new</span> MyCustomQueryMapEncoder())</span><br><span class="line">                 .target(MyApi.class, <span class="string">&quot;https://api.hostname.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@QueryMap 注释对象时，默认编码器使用反射来检查提供的对象字段以将对象值扩展为查询字符串。如果您希望使用 Java Beans API 中定义的 getter 和 setter 方法构建查询字符串，请使用 BeanQueryMapEncoder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyApi myApi = Feign.builder()</span><br><span class="line">                 .queryMapEncoder(<span class="keyword">new</span> BeanQueryMapEncoder())</span><br><span class="line">                 .target(MyApi.class, <span class="string">&quot;https://api.hostname.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6、错误处理"><a href="#4-6、错误处理" class="headerlink" title="4.6、错误处理"></a>4.6、错误处理</h3><p>如果您需要更多控制处理意外响应，Feign 实例可以通过构建器注册自定义 ErrorDecoder。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyApi myApi = Feign.builder()</span><br><span class="line">                 .errorDecoder(<span class="keyword">new</span> MyErrorDecoder())</span><br><span class="line">                 .target(MyApi.class, <span class="string">&quot;https://api.hostname.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导致 HTTP 状态不在 2xx 范围内的所有响应都将触发 ErrorDecoder 的 decode 方法，允许您处理响应、将失败包装到自定义异常中或执行任何其他处理。如果您想再次重试请求，请抛出 RetryableException。这将调用注册的重试器。</p>
<h3 id="4-7、重试"><a href="#4-7、重试" class="headerlink" title="4.7、重试"></a>4.7、重试</h3><p>默认情况下，Feign 会自动重试 IOExceptions，不管 HTTP 方法如何，将它们视为与网络相关的瞬态异常，以及从 ErrorDecoder 抛出的任何 RetryableException。要自定义此行为，请通过构建器注册自定义 Retryer 实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyApi myApi = Feign.builder()</span><br><span class="line">                 .retryer(<span class="keyword">new</span> MyRetryer())</span><br><span class="line">                 .target(MyApi.class, <span class="string">&quot;https://api.hostname.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重试器负责通过从方法 continueOrPropagate(RetryableException e); 返回 true 或 false 来确定是否应该进行重试；将为每个客户端执行创建一个 Retryer 实例，允许您根据需要维护每个请求之间的状态。 如果确定重试不成功，则会抛出最后一个 RetryException。要抛出导致重试失败的原始原因，请使用 exceptionPropagationPolicy() 选项构建您的 Feign 客户端。</p>
<h3 id="4-8、指标"><a href="#4-8、指标" class="headerlink" title="4.8、指标"></a>4.8、指标</h3><p>默认情况下，feign 不会收集任何指标。 但是，可以向任何 feign 客户端添加指标收集功能。 Metric Capabilities 提供了一流的 Metrics API，用户可以利用它来深入了解请求/响应生命周期。</p>
<p> Dropwizard Metrics 4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                         .addCapability(<span class="keyword">new</span> Metrics4Capability())</span><br><span class="line">                         .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    github.contributors(<span class="string">&quot;OpenFeign&quot;</span>, <span class="string">&quot;feign&quot;</span>);</span><br><span class="line">    <span class="comment">// metrics will be available from this point onwards</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dropwizard Metrics 5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                         .addCapability(<span class="keyword">new</span> Metrics5Capability())</span><br><span class="line">                         .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    github.contributors(<span class="string">&quot;OpenFeign&quot;</span>, <span class="string">&quot;feign&quot;</span>);</span><br><span class="line">    <span class="comment">// metrics will be available from this point onwards</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Micrometer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                         .addCapability(<span class="keyword">new</span> MicrometerCapability())</span><br><span class="line">                         .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    github.contributors(<span class="string">&quot;OpenFeign&quot;</span>, <span class="string">&quot;feign&quot;</span>);</span><br><span class="line">    <span class="comment">// metrics will be available from this point onwards</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-9、静态和默认方法"><a href="#4-9、静态和默认方法" class="headerlink" title="4.9、静态和默认方法"></a>4.9、静态和默认方法</h3><p>Feign 所针对的接口可能具有静态或默认方法（如果使用 Java 8+）。这些允许 Feign 客户端包含未由底层 API 明确定义的逻辑。例如，静态方法可以轻松指定常见的客户端构建配置；默认方法可用于组合查询或定义默认参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span></span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(<span class="meta">@Param(&quot;owner&quot;)</span> String owner, <span class="meta">@Param(&quot;repo&quot;)</span> String repo)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /users/&#123;username&#125;/repos?sort=&#123;sort&#125;&quot;)</span></span><br><span class="line">  <span class="function">List&lt;Repo&gt; <span class="title">repos</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String owner, <span class="meta">@Param(&quot;sort&quot;)</span> String sort)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> List&lt;Repo&gt; <span class="title">repos</span><span class="params">(String owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> repos(owner, <span class="string">&quot;full_name&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Lists all contributors for all repos owned by a user.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">    MergingContributorList contributors = <span class="keyword">new</span> MergingContributorList();</span><br><span class="line">    <span class="keyword">for</span>(Repo repo : <span class="keyword">this</span>.repos(owner)) &#123;</span><br><span class="line">      contributors.addAll(<span class="keyword">this</span>.contributors(user, repo.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contributors.mergeResult();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GitHub <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Feign.builder()</span><br><span class="line">                .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-10、通过-CompletableFuture-异步执行"><a href="#4-10、通过-CompletableFuture-异步执行" class="headerlink" title="4.10、通过 CompletableFuture 异步执行"></a>4.10、通过 CompletableFuture 异步执行</h3><p>Feign 10.8 引入了一个新的构建器 AsyncFeign，它允许方法返回 CompletableFuture 实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span></span><br><span class="line">  CompletableFuture&lt;List&lt;Contributor&gt;&gt; contributors(<span class="meta">@Param(&quot;owner&quot;)</span> String owner, <span class="meta">@Param(&quot;repo&quot;)</span> String repo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    GitHub github = AsyncFeign.asyncBuilder()</span><br><span class="line">                         .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                         .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fetch and print a list of the contributors to this library.</span></span><br><span class="line">    CompletableFuture&lt;List&lt;Contributor&gt;&gt; contributors = github.contributors(<span class="string">&quot;OpenFeign&quot;</span>, <span class="string">&quot;feign&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Contributor contributor : contributors.get(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">      System.out.println(contributor.login + <span class="string">&quot; (&quot;</span> + contributor.contributions + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始实现包括 2 个异步客户端：</p>
<ul>
<li><code>AsyncClient.Default</code></li>
<li><code>AsyncApacheHttp5Client</code></li>
</ul>
]]></content>
      <categories>
        <category>Feign</category>
      </categories>
      <tags>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>feign-form基本使用</title>
    <url>/2021/11/09/feign-form%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="feign-form基本使用"><a href="#feign-form基本使用" class="headerlink" title="feign-form基本使用"></a>feign-form基本使用</h1><p>此模块添加了对编码 application/x-www-form-urlencoded 和 multipart/form-data 表单的支持。</p>
<h2 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h2><p>包含对您的应用程序的依赖项：</p>
<h3 id="1-1、Maven"><a href="#1-1、Maven" class="headerlink" title="1.1、Maven:"></a>1.1、<strong>Maven</strong>:</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2、Gradle"><a href="#1-2、Gradle" class="headerlink" title="1.2、Gradle:"></a>1.2、<strong>Gradle</strong>:</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">compile &#x27;io.github.openfeign.form:feign-form:3.8.0&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="2、要求"><a href="#2、要求" class="headerlink" title="2、要求"></a>2、要求</h2><p>feign-form 扩展依赖于 OpenFeign 及其具体版本：</p>
<ul>
<li>3.5.0 之前的所有 feign-form 版本都适用于 OpenFeign 9.* 版本；</li>
<li>从 feign-form 的 3.5.0 版开始，该模块适用于 OpenFeign 10.1.0 及更高版本。</li>
</ul>
<p>重要提示：没有向后兼容性，也没有任何保证 3.5.0 之后的 feign-form 版本与 10.* 之前的 OpenFeign 一起使用。 OpenFeign 在第 10 个版本中被重构，所以最好的方法 - 使用最新的 OpenFeign 和 feign-form 版本。</p>
<p>注意：</p>
<ul>
<li>spring-cloud-openfeign 在 v2.0.3.RELEASE 之前使用 OpenFeign 9.*，之后使用 10.*。反正这个依赖已经有合适的feign-form版本了，看依赖pom，不需要单独指定；</li>
<li>spring-cloud-starter-feign 是一个已弃用的依赖项，它始终使用 OpenFeign 的 9.* 版本。</li>
</ul>
<h2 id="3、用法"><a href="#3、用法" class="headerlink" title="3、用法"></a>3、用法</h2><p>像这样将 FormEncoder 添加到 Feign.Builder 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SomeApi github = Feign.builder()</span><br><span class="line">                      .encoder(<span class="keyword">new</span> FormEncoder())</span><br><span class="line">                      .target(SomeApi.class, <span class="string">&quot;http://api.some.org&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此外，您可以像这样装饰现有的编码器，例如 JsonEncoder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SomeApi github = Feign.builder()</span><br><span class="line">                      .encoder(<span class="keyword">new</span> FormEncoder(<span class="keyword">new</span> JacksonEncoder()))</span><br><span class="line">                      .target(SomeApi.class, <span class="string">&quot;http://api.some.org&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>并一起使用它们：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SomeApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /json&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: application/json&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">json</span> <span class="params">(Dto dto)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /form&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: application/x-www-form-urlencoded&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">from</span> <span class="params">(<span class="meta">@Param(&quot;field1&quot;)</span> String field1, <span class="meta">@Param(&quot;field2&quot;)</span> String[] values)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以通过 Content-Type 标头指定两种类型的编码形式。</p>
<p>application/x-www-form-urlencoded</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SomeApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /authorization&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: application/x-www-form-urlencoded&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">authorization</span> <span class="params">(<span class="meta">@Param(&quot;email&quot;)</span> String email, <span class="meta">@Param(&quot;password&quot;)</span> String password)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Group all parameters within a POJO</span></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /user&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: application/x-www-form-urlencoded&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addUser</span> <span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>multipart/form-data</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SomeApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// File parameter</span></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /send_photo&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: multipart/form-data&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendPhoto</span> <span class="params">(<span class="meta">@Param(&quot;is_public&quot;)</span> Boolean isPublic, <span class="meta">@Param(&quot;photo&quot;)</span> File photo)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// byte[] parameter</span></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /send_photo&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: multipart/form-data&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendPhoto</span> <span class="params">(<span class="meta">@Param(&quot;is_public&quot;)</span> Boolean isPublic, <span class="meta">@Param(&quot;photo&quot;)</span> <span class="keyword">byte</span>[] photo)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FormData parameter</span></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /send_photo&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: multipart/form-data&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendPhoto</span> <span class="params">(<span class="meta">@Param(&quot;is_public&quot;)</span> Boolean isPublic, <span class="meta">@Param(&quot;photo&quot;)</span> FormData photo)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Group all parameters within a POJO</span></span><br><span class="line">  <span class="meta">@RequestLine(&quot;POST /send_photo&quot;)</span></span><br><span class="line">  <span class="meta">@Headers(&quot;Content-Type: multipart/form-data&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendPhoto</span> <span class="params">(MyPojo pojo)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyPojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FormProperty(&quot;is_public&quot;)</span></span><br><span class="line">    Boolean isPublic;</span><br><span class="line"></span><br><span class="line">    File photo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，sendPhoto 方法使用 photo 参数使用三种不同的受支持类型。</p>
<ul>
<li>File 将使用 File 的扩展名来检测 Content-Type；</li>
<li>byte[] 将使用 application/octet-stream 作为 Content-Type；</li>
<li>FormData 将使用 FormData 的 Content-Type 和 fileName；</li>
<li>用于分组参数（包括上述类型）的客户端自定义 POJO。</li>
</ul>
<p>FormData 是一个自定义对象，它包装了一个 byte[] 并定义了一个 Content-Type 和 fileName，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FormData formData = <span class="keyword">new</span> FormData(<span class="string">&quot;image/png&quot;</span>, <span class="string">&quot;filename.png&quot;</span>, myDataAsByteArray);</span><br><span class="line">someApi.sendPhoto(<span class="keyword">true</span>, formData);</span><br></pre></td></tr></table></figure>

<h2 id="4、Spring-MultipartFile-和-Spring-Cloud-Netflix-FeignClient-支持"><a href="#4、Spring-MultipartFile-和-Spring-Cloud-Netflix-FeignClient-支持" class="headerlink" title="4、Spring MultipartFile 和 Spring Cloud Netflix @FeignClient 支持"></a>4、Spring MultipartFile 和 Spring Cloud Netflix @FeignClient 支持</h2><p>您还可以将表单编码器与 Spring MultipartFile 和 @FeignClient 一起使用。 将依赖项包含到项目的 pom.xml 文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(</span></span><br><span class="line"><span class="meta">    name = &quot;file-upload-service&quot;,</span></span><br><span class="line"><span class="meta">    configuration = FileUploadServiceClient.MultipartSupportConfig.class</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileUploadServiceClient</span> <span class="keyword">extends</span> <span class="title">IFileUploadServiceClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipartSupportConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Encoder <span class="title">feignFormEncoder</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SpringFormEncoder(<span class="keyword">new</span> SpringEncoder(messageConverters));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，如果您不需要 Spring 的标准编码器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(</span></span><br><span class="line"><span class="meta">    name = &quot;file-upload-service&quot;,</span></span><br><span class="line"><span class="meta">    configuration = FileUploadServiceClient.MultipartSupportConfig.class</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileUploadServiceClient</span> <span class="keyword">extends</span> <span class="title">IFileUploadServiceClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipartSupportConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Encoder <span class="title">feignFormEncoder</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SpringFormEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感谢 tf-haotri-pham 的特性，它利用了 Apache commons-fileupload 库，处理多部分响应的解析。正文数据部分作为字节数组保存在内存中。 要使用此功能，请在解码器的消息转换器列表中包含 SpringManyMultipartFilesReader，并让 Feign 客户端返回一个 MultipartFile 数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(</span></span><br><span class="line"><span class="meta">    name = &quot;$&#123;feign.name&#125;&quot;,</span></span><br><span class="line"><span class="meta">    url = &quot;$&#123;feign.url&#125;&quot;</span></span><br><span class="line"><span class="meta">    configuration = DownloadClient.ClientConfiguration.class</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DownloadClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/multipart/download/&#123;fileId&#125;&quot;)</span></span><br><span class="line">  MultipartFile[] download(<span class="meta">@PathVariable(&quot;fileId&quot;)</span> String fileId);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ClientConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Decoder <span class="title">feignDecoder</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;HttpMessageConverter&lt;?&gt;&gt; springConverters =</span><br><span class="line">            messageConverters.getObject().getConverters();</span><br><span class="line"></span><br><span class="line">      List&lt;HttpMessageConverter&lt;?&gt;&gt; decoderConverters =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;(springConverters.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      decoderConverters.addAll(springConverters);</span><br><span class="line">      decoderConverters.add(<span class="keyword">new</span> SpringManyMultipartFilesReader(<span class="number">4096</span>));</span><br><span class="line"></span><br><span class="line">      HttpMessageConverters httpMessageConverters = <span class="keyword">new</span> HttpMessageConverters(decoderConverters);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SpringDecoder(<span class="keyword">new</span> ObjectFactory&lt;HttpMessageConverters&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> httpMessageConverters;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Feign</category>
      </categories>
      <tags>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign源码解析</title>
    <url>/2021/11/09/Feign%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Feign源码解析"><a href="#Feign源码解析" class="headerlink" title="Feign源码解析"></a>Feign源码解析</h1><h2 id="Feign基础用法"><a href="#Feign基础用法" class="headerlink" title="Feign基础用法"></a>Feign基础用法</h2>]]></content>
      <categories>
        <category>Feign</category>
      </categories>
      <tags>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud编程模型</title>
    <url>/2021/11/09/SpringCloud%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="SpringCloud编程模型"><a href="#SpringCloud编程模型" class="headerlink" title="SpringCloud编程模型"></a>SpringCloud编程模型</h1><h2 id="云原生应用"><a href="#云原生应用" class="headerlink" title="云原生应用"></a>云原生应用</h2><p>Cloud Native 是一种应用程序开发风格，它鼓励在持续交付和价值驱动的开发领域轻松采用最佳实践。一个相关的学科是构建 12 要素应用程序，其中开发实践与交付和运营目标保持一致 —— 例如，通过使用声明式编程以及管理和监控。 Spring Cloud 以多种特定方式促进了这些开发风格。起点是一组特性，分布式系统中的所有组件都需要轻松访问这些特性。</p>
<p>其中许多功能都包含在 Spring Boot 中，Spring Cloud 在其上构建。 Spring Cloud 提供了更多功能作为两个库：Spring Cloud Context 和 Spring Cloud Commons。 Spring Cloud Context 为 Spring Cloud 应用程序的 ApplicationContext 提供实用程序和特殊服务（引导上下文、加密、刷新范围和环境端点）。 Spring Cloud Commons 是在不同的 Spring Cloud 实现（例如 Spring Cloud Netflix 和 Spring Cloud Consul）中使用的一组抽象和通用类。</p>
<p>如果由于“非法密钥大小”而出现异常并且您使用 Sun 的 JDK，则需要安装 Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files。有关更多信息，请参阅以下链接：</p>
<ul>
<li><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html">Java 6 JCE</a></li>
<li><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">Java 7 JCE</a></li>
<li><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">Java 8 JCE</a></li>
</ul>
<p>对于您使用的任何 JRE/JDK x64/x86 版本，将文件解压缩到 JDK/jre/lib/security 文件夹中。</p>
<h3 id="1-Spring-Cloud-Context：应用程序上下文服务"><a href="#1-Spring-Cloud-Context：应用程序上下文服务" class="headerlink" title="1. Spring Cloud Context：应用程序上下文服务"></a>1. Spring Cloud Context：应用程序上下文服务</h3><p>Spring Boot 对如何使用 Spring 构建应用程序有自己的看法。例如，它具有常见配置文件的常规位置，并具有用于常见管理和监控任务的端点。 Spring Cloud 在此基础上构建，并添加了一些系统中许多组件会使用或偶尔需要的功能。</p>
<h4 id="1-1-Bootstrap-应用程序上下文"><a href="#1-1-Bootstrap-应用程序上下文" class="headerlink" title="1.1. Bootstrap 应用程序上下文"></a>1.1. Bootstrap 应用程序上下文</h4><p>Spring Cloud 应用程序通过创建“引导程序”上下文来运行，该上下文是主应用程序的父上下文。此上下文负责从外部源加载配置属性并解密本地外部配置文件中的属性。这两个上下文共享一个环境，它是任何 Spring 应用程序的外部属性的来源。默认情况下，引导属性（不是 bootstrap.properties，而是在引导阶段加载的属性）以高优先级添加，因此它们不能被本地配置覆盖。</p>
<p>引导上下文使用与主应用程序上下文不同的约定来定位外部配置。您可以使用 bootstrap.yml 代替 application.yml（或 .properties），将引导程序和主上下文的外部配置很好地分开。以下清单显示了一个示例：</p>
<p>示例 1. bootstrap.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">$&#123;SPRING_CONFIG_URI:http://localhost:8888&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果您的应用程序需要来自服务器的任何特定于应用程序的配置，最好设置 spring.application.name（在 bootstrap.yml 或 application.yml 中）。要将属性 spring.application.name 用作应用程序的上下文 ID，您必须在 bootstrap.[properties|yml]中设置它。 。</p>
<p>如果要检索特定的配置文件配置，还应该在 bootstrap.[properties|yml] 中设置 spring.profiles.active。</p>
<p>您可以通过设置 spring.cloud.bootstrap.enabled=false （例如，在系统属性中）来完全禁用引导过程。</p>
<h4 id="1-2-应用程序上下文层次结构"><a href="#1-2-应用程序上下文层次结构" class="headerlink" title="1.2.应用程序上下文层次结构"></a>1.2.应用程序上下文层次结构</h4><p>如果您从 SpringApplication 或 SpringApplicationBuilder 构建应用程序上下文，则 Bootstrap 上下文将作为父级添加到该上下文。 Spring 的一个特性是子上下文从其父上下文继承属性源和配置文件，因此“主”应用程序上下文包含额外的属性源，与在没有 Spring Cloud Config 的情况下构建相同的上下文相比。额外的财产来源是：</p>
<ul>
<li>“bootstrap”：如果在 bootstrap 上下文中找到任何 PropertySourceLocators 并且它们具有非空属性，则会出现一个具有高优先级的可选 CompositePropertySource。一个例子是来自 Spring Cloud Config Server 的属性。有关如何自定义此属性源的内容，请参阅“自定义 Bootstrap 属性源”。</li>
<li>“applicationConfig: [classpath:bootstrap.yml]”（以及相关文件，如果 Spring 配置文件处于活动状态）：如果您有 bootstrap.yml（或 .properties），这些属性用于配置引导程序上下文。然后当它的父级被设置时，它们被添加到子上下文中。它们的优先级低于 application.yml（或 .properties）以及作为创建 Spring Boot 应用程序过程的正常部分添加到子项的任何其他属性源。有关如何自定义这些属性源的内容，请参阅“更改 Bootstrap 属性的位置”。</li>
</ul>
<p>由于属性源的排序规则，“引导”条目优先。但是，请注意这些不包含来自 bootstrap.yml 的任何数据，它具有非常低的优先级但可用于设置默认值。</p>
<p>您可以通过设置您创建的任何 ApplicationContext 的父上下文来扩展上下文层次结构 — 例如，通过使用它自己的接口或使用 SpringApplicationBuilder 便捷方法（parent()、child() 和sibling()）。引导上下文是您自己创建的最高级祖先的父级。层次结构中的每个上下文都有自己的“引导程序”（可能是空的）属性源，以避免无意中将值从父级提升到其后代。如果有配置服务器，层次结构中的每个上下文也可以（原则上）具有不同的 spring.application.name，因此，具有不同的远程属性源。普通 Spring 应用程序上下文行为规则适用于属性解析：来自子上下文的属性覆盖父上下文中的属性，按名称以及属性源名称。 （如果子级具有与父级同名的属性源，则父级的值不包含在子级中）。</p>
<p>请注意， SpringApplicationBuilder 允许您在整个层次结构中共享环境，但这不是默认设置。因此，兄弟上下文（特别是）不需要具有相同的配置文件或属性源，即使它们可能与其父级共享共同的值。</p>
<h4 id="1-3-更改-Bootstrap-属性的位置"><a href="#1-3-更改-Bootstrap-属性的位置" class="headerlink" title="1.3.更改 Bootstrap 属性的位置"></a>1.3.更改 Bootstrap 属性的位置</h4><p>可以通过设置 spring.cloud.bootstrap.name（默认：bootstrap）、spring.cloud.bootstrap.location（默认：空）或 spring.cloud.bootstrap.additional-location 来指定 bootstrap.yml（或 .properties）位置（默认：空） — 例如，在系统属性中。</p>
<p>这些属性的行为类似于具有相同名称的 spring.config.* 变体。使用 spring.cloud.bootstrap.location 替换默认位置，仅使用指定的位置。要将位置添加到默认列表中，可以使用 spring.cloud.bootstrap.additional-location。事实上，它们用于通过在 Environment 中设置这些属性来设置 bootstrap ApplicationContext。如果有一个活动配置文件（来自 spring.profiles.active 或通过您正在构建的上下文中的环境 API），该配置文件中的属性也会被加载，就像在常规 Spring Boot 应用程序中一样 — 例如，来自 bootstrap -development.properties 用于开发配置文件。</p>
<h4 id="1-4-覆盖远程属性的值"><a href="#1-4-覆盖远程属性的值" class="headerlink" title="1.4.覆盖远程属性的值"></a>1.4.覆盖远程属性的值</h4><p>由引导上下文添加到应用程序的属性源通常是“远程的”（例如，来自 Spring Cloud Config Server）。默认情况下，它们不能在本地被覆盖。如果你想让你的应用程序用他们自己的系统属性或配置文件覆盖远程属性，远程属性源必须通过设置 spring.cloud.config.allowOverride=true 来授予它权限（在本地设置它不起作用） .一旦设置了该标志，两个更细粒度的设置将控制与系统属性和应用程序本地配置相关的远程属性的位置：</p>
<ul>
<li>spring.cloud.config.overrideNone=true：从任何本地属性源覆盖。</li>
<li>spring.cloud.config.overrideSystemProperties=false：只有系统属性、命令行参数和环境变量（而不是本地配置文件）应该覆盖远程设置。</li>
</ul>
<h4 id="1-5-自定义引导配置"><a href="#1-5-自定义引导配置" class="headerlink" title="1.5.自定义引导配置"></a>1.5.自定义引导配置</h4><p>通过在名为 org.springframework.cloud.bootstrap.BootstrapConfiguration 的键下向 /META-INF/spring.factories 添加条目，可以将引导上下文设置为执行您喜欢的任何操作。这包含用于创建上下文的 Spring @Configuration 类的逗号分隔列表。您希望在主应用程序上下文中可用于自动装配的任何 bean 都可以在此处创建。 ApplicationContextInitializer 类型的@Beans 有一个特殊的契约。如果要控制启动顺序，可以用@Order 注解标记类（默认顺序是最后）。</p>
<p>添加自定义 BootstrapConfiguration 时，请注意您添加的类不会错误地@ComponentScanned 到您的“主”应用程序上下文中，在那里可能不需要它们。为引导配置类使用单独的包名称，并确保该名称尚未被 @ComponentScan 或 @SpringBootApplication 注释的配置类覆盖。</p>
<p>bootstrap 过程通过将初始化器注入主 SpringApplication 实例（这是正常的 Spring Boot 启动序列，无论它作为独立应用程序运行还是部署在应用程序服务器中）结束。首先，从 spring.factories 中的类创建引导上下文。然后，ApplicationContextInitializer 类型的所有@Beans 在启动之前被添加到主 SpringApplication 中。</p>
<h4 id="1-6-自定义-Bootstrap-属性源"><a href="#1-6-自定义-Bootstrap-属性源" class="headerlink" title="1.6.自定义 Bootstrap 属性源"></a>1.6.自定义 Bootstrap 属性源</h4><p>bootstrap 进程添加的外部配置的默认属性源是 Spring Cloud Config Server，但您可以通过将 PropertySourceLocator 类型的 bean 添加到 bootstrap 上下文（通过 spring.factories）来添加其他源。例如，您可以插入来自不同服务器或数据库的其他属性。</p>
<p>例如，请考虑以下自定义定位器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPropertySourceLocator</span> <span class="keyword">implements</span> <span class="title">PropertySourceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MapPropertySource(<span class="string">&quot;customProperty&quot;</span>,</span><br><span class="line">                Collections.&lt;String, Object&gt;singletonMap(<span class="string">&quot;property.from.sample.custom.source&quot;</span>, <span class="string">&quot;worked as intended&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的 Environment 是即将创建的 ApplicationContext 的环境 — 换句话说，我们为其提供附加属性源的环境。它已经拥有普通的 Spring Boot 提供的属性源，因此您可以使用它们来定位特定于此环境的属性源（例如，通过在 spring.application.name 上键入它，就像在默认的 Spring Cloud Config Server 中所做的那样属性源定位器）。</p>
<p>如果您在其中创建一个包含此类的 jar，然后添加包含以下设置的 META-INF/spring.factories，则 customProperty PropertySource 将出现在其类路径中包含该 jar 的任何应用程序中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocator</span><br></pre></td></tr></table></figure>

<h4 id="1-7-日志配置"><a href="#1-7-日志配置" class="headerlink" title="1.7.日志配置"></a>1.7.日志配置</h4><p>如果你使用 Spring Boot 来配置日志设置，你应该把这个配置放在 bootstrap.[yml|properties] 如果您希望它适用于所有事件。</p>
<p>为了让 Spring Cloud 正确初始化日志配置，您不能使用自定义前缀。例如，在初始化日志系统时，Spring Cloud 无法识别使用 custom.loggin.logpath。</p>
<h4 id="1-8-环境变化"><a href="#1-8-环境变化" class="headerlink" title="1.8.环境变化"></a>1.8.环境变化</h4><p>应用程序侦听 EnvironmentChangeEvent 并以几种标准方式对更改做出反应（额外的 ApplicationListeners 可以以正常方式添加为 @Beans）。当观察到 EnvironmentChangeEvent 时，它具有已更改的键值列表，应用程序使用这些值：</p>
<ul>
<li>在上下文中重新绑定任何 @ConfigurationProperties bean。</li>
<li>为 logging.level.* 中的任何属性设置记录器级别。</li>
</ul>
<p>请注意，默认情况下，Spring Cloud Config Client 不会轮询环境中的更改。通常，我们不建议使用这种方法来检测更改（尽管您可以使用 @Scheduled 注释进行设置）。如果您有横向扩展的客户端应用程序，最好将 EnvironmentChangeEvent 广播到所有实例，而不是让它们轮询更改（例如，通过使用 Spring Cloud Bus）。</p>
<p>EnvironmentChangeEvent 涵盖了一大类刷新用例，只要您可以实际更改 Environment 并发布事件即可。请注意，这些 API 是公共的并且是核心 Spring 的一部分）。您可以通过访问 /configprops 端点（标准 Spring Boot Actuator 功能）来验证更改是否绑定到 @ConfigurationProperties bean。例如，DataSource 可以在运行时更改其 maxPoolSize（Spring Boot 创建的默认 DataSource 是一个 @ConfigurationProperties bean）并动态增加容量。重新绑定 @ConfigurationProperties 不涵盖另一大类用例，在这些用例中，您需要对刷新进行更多控制，并且需要对整个 ApplicationContext 进行原子性更改。为了解决这些问题，我们有@RefreshScope。</p>
<h4 id="1-9-刷新范围"><a href="#1-9-刷新范围" class="headerlink" title="1.9.刷新范围"></a>1.9.刷新范围</h4><p>当配置发生变化时，标记为@RefreshScope 的 Spring @Bean 会得到特殊处理。此功能解决了有状态 bean 的问题，这些 bean 仅在初始化时注入其配置。例如，如果在通过环境更改数据库 URL 时 DataSource 具有打开的连接，您可能希望这些连接的持有者能够完成他们正在做的事情。然后，下一次从池中借用连接时，它会获得一个带有新 URL 的连接。</p>
<p>有时，甚至可能必须在某些只能初始化一次的 bean 上应用 @RefreshScope 注释。如果 bean 是“不可变的”，则必须使用 @RefreshScope 注释 bean 或在属性键下指定类名：spring.cloud.refresh.extra-refreshable。</p>
<p>如果你有一个作为 HikariDataSource 的 DataSource bean，它不能被刷新。这是 spring.cloud.refresh.never-refreshable 的默认值。如果需要刷新，请选择不同的 DataSource 实现。</p>
<p>刷新作用域 bean 是在使用时（即调用方法时）进行初始化的惰性代理，作用域充当已初始化值的缓存。要强制 bean 在下一次方法调用时重新初始化，您必须使其缓存条目无效。</p>
<p>RefreshScope 是上下文中的一个 bean，并且有一个公共 refreshAll() 方法通过清除目标缓存来刷新范围内的所有 bean。 /refresh 端点公开了此功能（通过 HTTP 或 JMX）。要按名称刷新单个 bean，还有一个 refresh(String) 方法。</p>
<p>要公开 /refresh 端点，您需要向应用程序添加以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">refresh</span></span><br></pre></td></tr></table></figure>

<p>@RefreshScope 在 @Configuration 类上工作（技术上），但它可能会导致令人惊讶的行为。例如，这并不意味着该类中定义的所有@Beans 本身都在@RefreshScope 中。具体来说，任何依赖于这些 bean 的东西都不能依赖于在启动刷新时更新它们，除非它本身在 @RefreshScope 中。在这种情况下，它会在刷新时重建，并重新注入其依赖项。那时，它们从刷新的@Configuration 重新初始化）。</p>
<h4 id="1-10-加密和解密"><a href="#1-10-加密和解密" class="headerlink" title="1.10.加密和解密"></a>1.10.加密和解密</h4><p>Spring Cloud 有一个 Environment 预处理器，用于在本地解密属性值。它遵循与 Spring Cloud Config Server 相同的规则，并通过 encrypt.* 具有相同的外部配置。因此，您可以使用 {cipher}* 形式的加密值，并且只要存在有效密钥，它们就会在主应用程序上下文获得环境设置之前被解密。要在应用程序中使用加密功能，您需要在类路径中包含 Spring Security RSA（Maven 坐标：org.springframework.security:spring-security-rsa），并且您还需要在 JVM 中使用完整的 JCE 扩展.</p>
<p>如果由于“非法密钥大小”而出现异常并且您使用 Sun 的 JDK，则需要安装 Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files。有关更多信息，请参阅以下链接：</p>
<ul>
<li><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html">Java 6 JCE</a></li>
<li><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">Java 7 JCE</a></li>
<li><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">Java 8 JCE</a></li>
</ul>
<p>对于您使用的任何 JRE/JDK x64/x86 版本，将文件解压缩到 JDK/jre/lib/security 文件夹中。</p>
<h4 id="1-11-端点"><a href="#1-11-端点" class="headerlink" title="1.11.端点"></a>1.11.端点</h4><p>对于 Spring Boot Actuator 应用程序，可以使用一些额外的管理端点。您可以使用：</p>
<ul>
<li>POST 到 /actuator/env 以更新环境并重新绑定 @ConfigurationProperties 和日志级别。要启用此端点，您必须设置 management.endpoint.env.post.enabled=true。</li>
<li>/actuator/refresh 重新加载引导上下文并刷新@RefreshScope bean。</li>
<li>/actuator/restart 关闭 ApplicationContext 并重新启动它（默认情况下禁用）。</li>
<li>/actuator/pause 和 /actuator/resume 用于调用生命周期方法（ApplicationContext 上的 stop() 和 start()）。</li>
</ul>
<p>如果您禁用 /actuator/restart 端点，那么 /actuator/pause 和 /actuator/resume 端点也将被禁用，因为它们只是 /actuator/restart 的一个特例。</p>
<h3 id="2-Spring-Cloud-Commons：通用抽象"><a href="#2-Spring-Cloud-Commons：通用抽象" class="headerlink" title="2. Spring Cloud Commons：通用抽象"></a>2. Spring Cloud Commons：通用抽象</h3><p>服务发现、负载平衡和断路器等模式适合一个公共抽象层，所有 Spring Cloud 客户端都可以使用该抽象层，独立于实现（例如，使用 Eureka 或 Consul 进行发现）。</p>
<h4 id="2-1-EnableDiscoveryClient-注解"><a href="#2-1-EnableDiscoveryClient-注解" class="headerlink" title="2.1. @EnableDiscoveryClient 注解"></a>2.1. @EnableDiscoveryClient 注解</h4><p>Spring Cloud Commons 提供了 @EnableDiscoveryClient 注解。这会寻找带有 META-INF/spring.factories 的 DiscoveryClient 和 ReactiveDiscoveryClient 接口的实现。发现客户端的实现在 org.springframework.cloud.client.discovery.EnableDiscoveryClient 键下的 spring.factories 中添加了一个配置类。 DiscoveryClient 实现的示例包括 Spring Cloud Netflix Eureka、Spring Cloud Consul Discovery 和 Spring Cloud Zookeeper Discovery。</p>
<p>默认情况下，Spring Cloud 将提供阻塞和反应式服务发现客户端。您可以通过设置 spring.cloud.discovery.blocking.enabled=false 或 spring.cloud.discovery.reactive.enabled=false 轻松禁用阻塞和/或反应客户端。要完全禁用服务发现，您只需设置 spring.cloud.discovery.enabled=false。</p>
<p>默认情况下， DiscoveryClient 的实现会自动向远程发现服务器注册本地 Spring Boot 服务器。可以通过在 @EnableDiscoveryClient 中设置 autoRegister=false 来禁用此行为。</p>
<p>不再需要@EnableDiscoveryClient。您可以在类路径上放置一个 DiscoveryClient 实现，以使 Spring Boot 应用程序向服务发现服务器注册。</p>
<h5 id="2-1-1-健康指标"><a href="#2-1-1-健康指标" class="headerlink" title="2.1.1.健康指标"></a>2.1.1.健康指标</h5><p>Commons 自动配置以下 Spring Boot 健康指标。</p>
<h6 id="发现客户端健康指标DiscoveryClientHealthIndicator"><a href="#发现客户端健康指标DiscoveryClientHealthIndicator" class="headerlink" title="发现客户端健康指标DiscoveryClientHealthIndicator"></a>发现客户端健康指标<a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#discoveryclienthealthindicator">DiscoveryClientHealthIndicator</a></h6><p>此运行状况指标基于当前注册的 DiscoveryClient 实现。</p>
<ul>
<li>要完全禁用，请设置 spring.cloud.discovery.client.health-indicator.enabled=false。</li>
<li>要禁用描述字段，请设置 spring.cloud.discovery.client.health-indicator.include-description=false。否则，它可能会冒泡作为汇总的 HealthIndicator 的描述。</li>
<li>要禁用服务检索，请设置 spring.cloud.discovery.client.health-indicator.use-services-query=false。默认情况下，指标调用客户端的 getServices 方法。在具有许多注册服务的部署中，在每次检查期间检索所有服务的成本可能太高。这将跳过服务检索，而是使用客户端的探测方法。</li>
</ul>
<h6 id="DiscoveryCompositeHealthContributor"><a href="#DiscoveryCompositeHealthContributor" class="headerlink" title="DiscoveryCompositeHealthContributor"></a><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#discoverycompositehealthcontributor">DiscoveryCompositeHealthContributor</a></h6><p>此复合健康指标基于所有已注册的 DiscoveryHealthIndicator bean。要禁用，请设置 spring.cloud.discovery.client.composite-indicator.enabled=false。</p>
<h5 id="2-1-2-Ordering-DiscoveryClient-实例"><a href="#2-1-2-Ordering-DiscoveryClient-实例" class="headerlink" title="2.1.2.Ordering DiscoveryClient 实例"></a>2.1.2.Ordering <code>DiscoveryClient</code> 实例</h5><p>DiscoveryClient 接口扩展了 Ordered。这在使用多个发现客户端时很有用，因为它允许您定义返回的发现客户端的顺序，类似于如何对 Spring 应用程序加载的 bean 进行排序。默认情况下，任何 DiscoveryClient 的顺序设置为 0。如果您想为自定义 DiscoveryClient 实现设置不同的顺序，您只需覆盖 getOrder() 方法，以便它返回适合您设置的值。除此之外，您可以使用属性来设置 Spring Cloud 提供的 DiscoveryClient 实现的顺序，其中包括 ConsulDiscoveryClient、EurekaDiscoveryClient 和 ZookeeperDiscoveryClient。为此，您只需将 spring.cloud.{clientIdentifier}.discovery.order （或 Eureka 的 eureka.client.order）属性设置为所需的值。</p>
<h5 id="2-1-3-SimpleDiscoveryClient"><a href="#2-1-3-SimpleDiscoveryClient" class="headerlink" title="2.1.3. SimpleDiscoveryClient"></a><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#simplediscoveryclient">2.1.3. SimpleDiscoveryClient</a></h5><p>如果类路径中没有 Service-Registry-backed DiscoveryClient，将使用 SimpleDiscoveryClient 实例，它使用属性来获取有关服务和实例的信息。</p>
<p>有关可用实例的信息应通过以下格式的属性传递给： spring.cloud.discovery.client.simple.instances.service1[0].uri=<a href="http://s11:8080，其中">http://s11:8080，其中</a> spring.cloud.discovery .client.simple.instances 是公共前缀，然后service1代表所涉及的服务的ID，而[0]代表实例的索引号（如示例中可见，索引从0开始），然后是uri 的值是实例可用的实际 URI。</p>
<h4 id="2-2-ServiceRegistry"><a href="#2-2-ServiceRegistry" class="headerlink" title="2.2. ServiceRegistry"></a><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#serviceregistry">2.2. ServiceRegistry</a></h4><p>Commons 现在提供了一个 ServiceRegistry 接口，该接口提供 register(Registration) 和 deregister(Registration) 等方法，让您可以提供自定义注册服务。注册是一个标记界面。</p>
<p>以下示例显示了正在使用的 ServiceRegistry：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient(autoRegister=false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConfiguration</span><span class="params">(ServiceRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registry = registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// called through some external process, such as an event or a custom actuator endpoint</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Registration registration = constructRegistration();</span><br><span class="line">        <span class="keyword">this</span>.registry.register(registration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 ServiceRegistry 实现都有自己的 Registry 实现。</p>
<ul>
<li>ZookeeperRegistration 与 ZookeeperServiceRegistry 一起使用 </li>
<li>EurekaRegistration 与 EurekaServiceRegistry 一起使用 </li>
<li>ConsulRegistration 与 ConsulServiceRegistry 一起使用</li>
</ul>
<p>如果您使用 ServiceRegistry 接口，您将需要为您正在使用的 ServiceRegistry 实现传递正确的 Registry 实现。</p>
<h5 id="2-2-1-ServiceRegistry-Auto-Registration"><a href="#2-2-1-ServiceRegistry-Auto-Registration" class="headerlink" title="2.2.1. ServiceRegistry Auto-Registration"></a><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#serviceregistry-auto-registration">2.2.1. ServiceRegistry Auto-Registration</a></h5><p>默认情况下，ServiceRegistry 实现会自动注册正在运行的服务。要禁用该行为，您可以设置： * @EnableDiscoveryClient(autoRegister=false) 以永久禁用自动注册。 * spring.cloud.service-registry.auto-registration.enabled=false 通过配置禁用行为。</p>
<h6 id="ServiceRegistry-Auto-Registration-Events"><a href="#ServiceRegistry-Auto-Registration-Events" class="headerlink" title="ServiceRegistry Auto-Registration Events"></a><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#serviceregistry-auto-registration-events">ServiceRegistry Auto-Registration Events</a></h6><p>服务自动注册时将触发两个事件。第一个事件称为 InstancePreRegisteredEvent，在注册服务之前触发。第二个事件称为 InstanceRegisteredEvent，在注册服务后触发。您可以注册一个 ApplicationListener(s) 来监听和响应这些事件。</p>
<p>如果 spring.cloud.service-registry.auto-registration.enabled 属性设置为 false，则不会触发这些事件。</p>
<h5 id="2-2-2-Service-Registry-Actuator-Endpoint"><a href="#2-2-2-Service-Registry-Actuator-Endpoint" class="headerlink" title=" 2.2.2. Service Registry Actuator Endpoint"></a><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#service-registry-actuator-endpoint"> 2.2.2. Service Registry Actuator Endpoint</a></h5><p>Spring Cloud Commons 提供了一个 /service-registry 执行器端点。此端点依赖于 Spring 应用程序上下文中的注册 bean。使用 GET 调用 /service-registry 会返回注册的状态。对具有 JSON 正文的同一端点使用 POST 会将当前注册的状态更改为新值。 JSON 正文必须包含具有首选值的状态字段。请参阅更新状态和状态返回值时用于允许值的 ServiceRegistry 实现的文档。例如，Eureka 支持的状态是 UP、DOWN、OUT_OF_SERVICE 和 UNKNOWN。</p>
<h4 id="2-3-Spring-RestTemplate-作为负载均衡器客户端"><a href="#2-3-Spring-RestTemplate-作为负载均衡器客户端" class="headerlink" title="2.3. Spring RestTemplate 作为负载均衡器客户端"></a>2.3. Spring RestTemplate 作为负载均衡器客户端</h4><p>您可以配置 RestTemplate 以使用负载平衡器客户端。要创建负载平衡的 RestTemplate，请创建 RestTemplate @Bean 并使用 @LoadBalanced 限定符，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doOtherStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String results = restTemplate.getForObject(<span class="string">&quot;http://stores/stores&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RestTemplate bean 不再通过自动配置创建。个人应用程序必须创建它。</p>
<p>URI 需要使用虚拟主机名（即服务名，而不是主机名）。 BlockingLoadBalancerClient 用于创建完整的物理地址。</p>
<p>要使用负载平衡的 RestTemplate，您需要在类路径中有一个负载平衡器实现。将 Spring Cloud LoadBalancer starter 添加到您的项目中以便使用它。</p>
<h4 id="2-4-Spring-WebClient-作为负载均衡器客户端"><a href="#2-4-Spring-WebClient-作为负载均衡器客户端" class="headerlink" title="2.4. Spring WebClient 作为负载均衡器客户端"></a>2.4. Spring WebClient 作为负载均衡器客户端</h4><p>您可以将 WebClient 配置为自动使用负载平衡器客户端。要创建负载均衡的 WebClient，请创建一个 WebClient.Builder @Bean 并使用 @LoadBalanced 限定符，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> WebClient.<span class="function">Builder <span class="title">loadBalancedWebClientBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> WebClient.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient.Builder webClientBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">doOtherStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webClientBuilder.build().get().uri(<span class="string">&quot;http://stores/stores&quot;</span>)</span><br><span class="line">                        .retrieve().bodyToMono(String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>URI 需要使用虚拟主机名（即服务名，而不是主机名）。 Spring Cloud LoadBalancer 用于创建完整的物理地址。</p>
<p>如果你想使用@LoadBalanced WebClient.Builder，你需要在类路径中有一个负载均衡器实现。我们建议您将 Spring Cloud LoadBalancer starter 添加到您的项目中。然后，在下面使用 ReactiveLoadBalancer。</p>
<h5 id="2-4-1-重试失败的请求"><a href="#2-4-1-重试失败的请求" class="headerlink" title="2.4.1.重试失败的请求"></a>2.4.1.重试失败的请求</h5><p>负载平衡的 RestTemplate 可以配置为重试失败的请求。默认情况下，此逻辑被禁用。对于非响应式版本（使用 RestTemplate），您可以通过将 Spring Retry 添加到应用程序的类路径来启用它。对于响应式版本（使用 WebTestClient），您需要设置 `spring.cloud.loadbalancer.retry.enabled=true。</p>
<p>如果您想在类路径上使用 Spring Retry 或 Reactive Retry 禁用重试逻辑，您可以设置 spring.cloud.loadbalancer.retry.enabled=false。</p>
<p>对于非反应式实现，如果您想在重试中实现 BackOffPolicy，则需要创建一个 LoadBalancedRetryFactory 类型的 bean 并覆盖 createBackOffPolicy() 方法。</p>
<p>对于反应式实现，您只需要通过将 spring.cloud.loadbalancer.retry.backoff.enabled 设置为 false 来启用它。</p>
<p>您可以设置：</p>
<ul>
<li>spring.cloud.loadbalancer.retry.maxRetriesOnSameServiceInstance - 指示应在同一个 ServiceInstance 上重试请求的次数（为每个选定的实例单独计数） </li>
<li>spring.cloud.loadbalancer.retry.maxRetriesOnNextServiceInstance - 指示应重试新选择的 ServiceInstance 请求的次数 </li>
<li>spring.cloud.loadbalancer.retry.retryableStatusCodes - 始终重试失败请求的状态代码。</li>
</ul>
<p>对于反应式实现，您还可以设置： - spring.cloud.loadbalancer.retry.backoff.minBackoff - 设置最小退避持续时间（默认为 5 毫秒） - spring.cloud.loadbalancer.retry.backoff.maxBackoff - 设置最大退避持续时间（默认情况下，最大长值毫秒） - spring.cloud.loadbalancer.retry.backoff.jitter - 设置用于计算每次调用的实际退避持续时间的抖动（默认情况下，0.5）。</p>
<p>对于反应式实现，您还可以实现自己的 LoadBalancerRetryPolicy 以更详细地控制负载平衡的调用重试。</p>
<p>对于负载平衡重试，默认情况下，我们使用 RetryAwareServiceInstanceListSupplier 包装 ServiceInstanceListSupplier bean，以从先前选择的实例中选择一个不同的实例（如果可用）。您可以通过将 spring.cloud.loadbalancer.retry.avoidPreviousInstance 的值设置为 false 来禁用此行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">LoadBalancedRetryFactory <span class="title">retryFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancedRetryFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> BackOffPolicy <span class="title">createBackOffPolicy</span><span class="params">(String service)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ExponentialBackOffPolicy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您想将一个或多个 RetryListener 实现添加到您的重试功能中，您需要创建一个 LoadBalancedRetryListenerFactory 类型的 bean 并返回您想用于给定服务的 RetryListener 数组，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">LoadBalancedRetryListenerFactory <span class="title">retryListenerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancedRetryListenerFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> RetryListener[] createRetryListeners(String service) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RetryListener[]&#123;<span class="keyword">new</span> RetryListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">open</span><span class="params">(RetryContext context, RetryCallback&lt;T, E&gt; callback)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//TODO Do you business...</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                     <span class="keyword">public</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//TODO Do you business...</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//TODO Do you business...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-多个-RestTemplate-对象"><a href="#2-5-多个-RestTemplate-对象" class="headerlink" title="2.5.多个 RestTemplate 对象"></a>2.5.多个 RestTemplate 对象</h4><p>如果您想要一个非负载均衡的 RestTemplate，请创建一个 RestTemplate bean 并注入它。要访问负载平衡的 RestTemplate，请在创建 @Bean 时使用 @LoadBalanced 限定符，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    WebClient.<span class="function">Builder <span class="title">loadBalanced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> WebClient.builder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    WebClient.<span class="function">Builder <span class="title">webClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> WebClient.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient.Builder webClientBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">private</span> WebClient.Builder loadBalanced;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">doOtherStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loadBalanced.build().get().uri(<span class="string">&quot;http://stores/stores&quot;</span>)</span><br><span class="line">                        .retrieve().bodyToMono(String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">doStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webClientBuilder.build().get().uri(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line">                        .retrieve().bodyToMono(String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-Spring-WebFlux-WebClient-作为负载均衡器客户端"><a href="#2-7-Spring-WebFlux-WebClient-作为负载均衡器客户端" class="headerlink" title="2.7. Spring WebFlux WebClient 作为负载均衡器客户端"></a>2.7. Spring WebFlux WebClient 作为负载均衡器客户端</h4><p>Spring WebFlux 可以使用反应式和非反应式 WebClient 配置，如主题所述：</p>
<ul>
<li>带有 ReactorLoadBalancerExchangeFilterFunction 的 Spring WebFlux WebClient</li>
<li>[负载平衡器交换过滤器功能负载平衡器交换过滤器功能]</li>
</ul>
<h5 id="2-7-1-带有-ReactorLoadBalancerExchangeFilterFunction-的-Spring-WebFlux-WebClient"><a href="#2-7-1-带有-ReactorLoadBalancerExchangeFilterFunction-的-Spring-WebFlux-WebClient" class="headerlink" title="2.7.1.带有 ReactorLoadBalancerExchangeFilterFunction 的 Spring WebFlux WebClient"></a>2.7.1.带有 ReactorLoadBalancerExchangeFilterFunction 的 Spring WebFlux WebClient</h5><p>您可以将 WebClient 配置为使用 ReactiveLoadBalancer。如果您将 Spring Cloud LoadBalancer starter 添加到您的项目中并且如果 spring-webflux 在类路径上，则 ReactorLoadBalancerExchangeFilterFunction 是自动配置的。以下示例显示如何配置 WebClient 以使用反应式负载均衡器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ReactorLoadBalancerExchangeFilterFunction lbFunction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">doOtherStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> WebClient.builder().baseUrl(<span class="string">&quot;http://stores&quot;</span>)</span><br><span class="line">            .filter(lbFunction)</span><br><span class="line">            .build()</span><br><span class="line">            .get()</span><br><span class="line">            .uri(<span class="string">&quot;/stores&quot;</span>)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>URI 需要使用虚拟主机名（即服务名，而不是主机名）。 ReactorLoadBalancer 用于创建完整的物理地址。</p>
<h5 id="2-7-2-带有非反应式负载均衡器客户端的-Spring-WebFlux-WebClient"><a href="#2-7-2-带有非反应式负载均衡器客户端的-Spring-WebFlux-WebClient" class="headerlink" title="2.7.2.带有非反应式负载均衡器客户端的 Spring WebFlux WebClient"></a>2.7.2.带有非反应式负载均衡器客户端的 Spring WebFlux WebClient</h5><p>如果 spring-webflux 在类路径上，LoadBalancerExchangeFilterFunction 是自动配置的。但是请注意，这在后台使用了一个非反应式客户端。以下示例显示如何配置 WebClient 以使用负载均衡器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerExchangeFilterFunction lbFunction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">doOtherStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> WebClient.builder().baseUrl(<span class="string">&quot;http://stores&quot;</span>)</span><br><span class="line">            .filter(lbFunction)</span><br><span class="line">            .build()</span><br><span class="line">            .get()</span><br><span class="line">            .uri(<span class="string">&quot;/stores&quot;</span>)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>URI 需要使用虚拟主机名（即服务名，而不是主机名）。 LoadBalancerClient 用于创建完整的物理地址。</p>
<p>警告：此方法现已弃用。我们建议您使用带有反应式负载均衡器的 WebFlux。</p>
<h4 id="2-8-忽略网络接口"><a href="#2-8-忽略网络接口" class="headerlink" title="2.8.忽略网络接口"></a>2.8.忽略网络接口</h4><p>有时，忽略某些命名的网络接口很有用，以便它们可以从服务发现注册中排除（例如，在 Docker 容器中运行时）。可以设置正则表达式列表以导致所需的网络接口被忽略。以下配置忽略了 docker0 接口和所有以 veth 开头的接口：</p>
<p>示例 2. application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">inetutils:</span></span><br><span class="line">      <span class="attr">ignoredInterfaces:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">docker0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">veth.*</span></span><br></pre></td></tr></table></figure>

<p>您还可以通过使用正则表达式列表强制仅使用指定的网络地址，如以下示例所示：</p>
<p>示例 3. bootstrap.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">inetutils:</span></span><br><span class="line">      <span class="attr">preferredNetworks:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">10.0</span></span><br></pre></td></tr></table></figure>

<p>您还可以强制仅使用站点本地地址，如以下示例所示：</p>
<p>示例 4. application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">inetutils:</span></span><br><span class="line">      <span class="attr">useOnlySiteLocalInterfaces:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>有关什么构成站点本地地址的更多详细信息，请参阅 Inet4Address.html.isSiteLocalAddress()。</p>
<h4 id="2-9-HTTP-客户端工厂"><a href="#2-9-HTTP-客户端工厂" class="headerlink" title="2.9. HTTP 客户端工厂"></a>2.9. HTTP 客户端工厂</h4><p>Spring Cloud Commons 提供了用于创建 Apache HTTP 客户端 (ApacheHttpClientFactory) 和 OK HTTP 客户端 (OkHttpClientFactory) 的 bean。只有当 OK HTTP jar 位于类路径上时，才会创建 OkHttpClientFactory bean。此外，Spring Cloud Commons 提供了用于创建两个客户端使用的连接管理器的 bean：ApacheHttpClientConnectionManagerFactory 用于 Apache HTTP 客户端，OkHttpClientConnectionPoolFactory 用于 OK HTTP 客户端。如果您想自定义如何在下游项目中创建 HTTP 客户端，您可以提供您自己的这些 bean 的实现。此外，如果您提供类型为 HttpClientBuilder 或 OkHttpClient.Builder 的 bean，则默认工厂使用这些构建器作为返回到下游项目的构建器的基础。您还可以通过将 spring.cloud.httpclientfactories.apache.enabled 或 spring.cloud.httpclientfactories.ok.enabled 设置为 false 来禁用这些 bean 的创建。</p>
<h4 id="2-10-启用的功能"><a href="#2-10-启用的功能" class="headerlink" title="2.10.启用的功能"></a>2.10.启用的功能</h4><p>Spring Cloud Commons 提供了一个 /features 执行器端点。此端点返回类路径上可用的功能以及它们是否已启用。返回的信息包括功能类型、名称、版本和供应商。</p>
<h5 id="2-10-1-特征类型"><a href="#2-10-1-特征类型" class="headerlink" title="2.10.1.特征类型"></a>2.10.1.特征类型</h5><p>有两种类型的“特征”：抽象的和命名的。</p>
<p>抽象特性是定义接口或抽象类以及创建实现的特性，例如 DiscoveryClient、LoadBalancerClient 或 LockService。抽象类或接口用于在上下文中查找该类型的 bean。显示的版本是 bean.getClass().getPackage().getImplementationVersion()。</p>
<p>命名特性是没有它们实现的特定类的特性。这些功能包括“断路器”、“API 网关”、“Spring Cloud Bus”等。这些功能需要一个名称和一个 bean 类型。</p>
<h5 id="2-10-2-声明功能"><a href="#2-10-2-声明功能" class="headerlink" title="2.10.2.声明功能"></a>2.10.2.声明功能</h5><p>任何模块都可以声明任意数量的 HasFeature bean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HasFeatures <span class="title">commonsFeatures</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> HasFeatures.abstractFeatures(DiscoveryClient.class, LoadBalancerClient.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HasFeatures <span class="title">consulFeatures</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> HasFeatures.namedFeatures(</span><br><span class="line">    <span class="keyword">new</span> NamedFeature(<span class="string">&quot;Spring Cloud Bus&quot;</span>, ConsulBusAutoConfiguration.class),</span><br><span class="line">    <span class="keyword">new</span> NamedFeature(<span class="string">&quot;Circuit Breaker&quot;</span>, HystrixCommandAspect.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">HasFeatures <span class="title">localFeatures</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> HasFeatures.builder()</span><br><span class="line">      .abstractFeature(Something.class)</span><br><span class="line">      .namedFeature(<span class="keyword">new</span> NamedFeature(<span class="string">&quot;Some Other Feature&quot;</span>, Someother.class))</span><br><span class="line">      .abstractFeature(Somethingelse.class)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些 bean 中的每一个都应该放在一个适当保护的 @Configuration 中。</p>
<h4 id="2-11-Spring-Cloud-兼容性验证"><a href="#2-11-Spring-Cloud-兼容性验证" class="headerlink" title="2.11. Spring Cloud 兼容性验证"></a>2.11. Spring Cloud 兼容性验证</h4><p>由于部分用户在设置 Spring Cloud 应用程序时遇到问题，我们决定添加兼容性验证机制。如果您当前的设置与 Spring Cloud 要求不兼容，它将中断，并附上一份报告，显示究竟出了什么问题。</p>
<p>目前我们验证将哪个版本的 Spring Boot 添加到您的类路径中。</p>
<p>报告示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Your project setup is incompatible with our requirements due to following reasons:</span><br><span class="line"></span><br><span class="line">- Spring Boot [<span class="number">2.1</span><span class="number">.0</span>.RELEASE] is not compatible with <span class="keyword">this</span> Spring Cloud release train</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Consider applying the following actions:</span><br><span class="line"></span><br><span class="line">- Change Spring Boot version to one of the following versions [<span class="number">1.2</span>.x, <span class="number">1.3</span>.x] .</span><br><span class="line">You can find the latest Spring Boot versions here [https:<span class="comment">//spring.io/projects/spring-boot#learn].</span></span><br><span class="line">If you want to learn more about the Spring Cloud Release train compatibility, you can visit <span class="keyword">this</span> page [https:<span class="comment">//spring.io/projects/spring-cloud#overview] and check the [Release Trains] section.</span></span><br></pre></td></tr></table></figure>

<p>要禁用此功能，请将 spring.cloud.compatibility-verifier.enabled 设置为 false。如果要覆盖兼容的 Spring Boot 版本，只需使用逗号分隔的兼容 Spring Boot 版本列表设置 spring.cloud.compatibility-verifier.compatible-boot-versions 属性。</p>
<h3 id="3-Spring-Cloud-负载均衡器"><a href="#3-Spring-Cloud-负载均衡器" class="headerlink" title="3. Spring Cloud 负载均衡器"></a>3. Spring Cloud 负载均衡器</h3><p>Spring Cloud 提供了自己的客户端负载均衡器抽象和实现。对于负载均衡机制，添加了 ReactiveLoadBalancer 接口，并为其提供了基于 Round-Robin 和 Random 的实现。为了让实例从反应式 ServiceInstanceListSupplier 中选择。目前，我们支持 ServiceInstanceListSupplier 的基于服务发现的实现，该实现使用类路径中可用的发现客户端从服务发现中检索可用实例。</p>
<p>可以通过将 spring.cloud.loadbalancer.enabled 的值设置为 false 来禁用 Spring Cloud LoadBalancer。</p>
<h4 id="3-1-在负载平衡算法之间切换"><a href="#3-1-在负载平衡算法之间切换" class="headerlink" title="3.1.在负载平衡算法之间切换"></a>3.1.在负载平衡算法之间切换</h4><p>默认使用的 ReactiveLoadBalancer 实现是 RoundRobinLoadBalancer。要为选定的服务或所有服务切换到不同的实现，您可以使用自定义 LoadBalancer 配置机制。</p>
<p>例如，可以通过@LoadBalancerClient 注解传递以下配置以切换到使用 RandomLoadBalancer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoadBalancerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="title">randomLoadBalancer</span><span class="params">(Environment environment,</span></span></span><br><span class="line"><span class="params"><span class="function">            LoadBalancerClientFactory loadBalancerClientFactory)</span> </span>&#123;</span><br><span class="line">        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomLoadBalancer(loadBalancerClientFactory</span><br><span class="line">                .getLazyProvider(name, ServiceInstanceListSupplier.class),</span><br><span class="line">                name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您作为 @LoadBalancerClient 或 @LoadBalancerClients 配置参数传递的类不应使用 @Configuration 进行注释或不在组件扫描范围内。</p>
<h4 id="3-2-Spring-Cloud-LoadBalancer-集成"><a href="#3-2-Spring-Cloud-LoadBalancer-集成" class="headerlink" title="3.2. Spring Cloud LoadBalancer 集成"></a>3.2. Spring Cloud LoadBalancer 集成</h4><p>为了方便使用 Spring Cloud LoadBalancer，我们提供了可与 WebClient 一起使用的 ReactorLoadBalancerExchangeFilterFunction 和与 RestTemplate 一起使用的 BlockingLoadBalancerClient。您可以在以下部分中查看更多信息和用法示例：</p>
<ul>
<li>Spring RestTemplate 作为负载均衡器客户端 </li>
<li>Spring WebClient 作为负载均衡器客户端 </li>
<li>带有 ReactorLoadBalancerExchangeFilterFunction 的 Spring WebFlux WebClient</li>
</ul>
<h4 id="3-3-Spring-Cloud-LoadBalancer-缓存"><a href="#3-3-Spring-Cloud-LoadBalancer-缓存" class="headerlink" title="3.3. Spring Cloud LoadBalancer 缓存"></a>3.3. Spring Cloud LoadBalancer 缓存</h4><p>除了在每次必须选择实例时通过 DiscoveryClient 检索实例的基本 ServiceInstanceListSupplier 实现之外，我们还提供了两个缓存实现。</p>
<h5 id="3-3-1-Caffeine支持的-LoadBalancer-缓存实现"><a href="#3-3-1-Caffeine支持的-LoadBalancer-缓存实现" class="headerlink" title="3.3.1.Caffeine支持的 LoadBalancer 缓存实现"></a>3.3.1.Caffeine支持的 LoadBalancer 缓存实现</h5><p>如果类路径中有 com.github.ben-manes.caffeine:caffeine，则将使用基于咖啡因的实现。有关如何配置它的信息，请参阅 LoadBalancerCacheConfiguration 部分。</p>
<p>如果您使用的是 Caffeine，您还可以通过在 spring.cloud.loadbalancer.cache.caffeine.spec 属性中传递您自己的 Caffeine Specification 来覆盖 LoadBalancer 的默认 Caffeine 缓存设置。</p>
<p>警告：传递您自己的 Caffeine 规范将覆盖任何其他 LoadBalancerCache 设置，包括常规 LoadBalancer 缓存配置字段，例如 ttl 和容量。</p>
<h5 id="3-3-2-默认-LoadBalancer-缓存实现"><a href="#3-3-2-默认-LoadBalancer-缓存实现" class="headerlink" title="3.3.2.默认 LoadBalancer 缓存实现"></a>3.3.2.默认 LoadBalancer 缓存实现</h5><p>如果类路径中没有 Caffeine，则将使用 spring-cloud-starter-loadbalancer 自动附带的 DefaultLoadBalancerCache。有关如何配置它的信息，请参阅 LoadBalancerCacheConfiguration 部分。</p>
<p>要使用 Caffeine 而不是默认缓存，请将 com.github.ben-manes.caffeine:caffeine 依赖项添加到类路径。</p>
<h5 id="3-3-3-负载均衡器缓存配置"><a href="#3-3-3-负载均衡器缓存配置" class="headerlink" title="3.3.3.负载均衡器缓存配置"></a>3.3.3.负载均衡器缓存配置</h5><p>您可以设置自己的 ttl 值（写入后条目应过期的时间），表示为 Duration，方法是将符合 Spring Boot String 的 String 传递到 Duration 转换器语法。作为 spring.cloud.loadbalancer.cache.ttl 属性的值。您还可以通过设置 spring.cloud.loadbalancer.cache.capacity 属性的值来设置自己的 LoadBalancer 缓存初始容量。</p>
<p>默认设置包括 ttl 设置为 35 秒，默认 initialCapacity 为 256。</p>
<p>您还可以通过将 spring.cloud.loadbalancer.cache.enabled 的值设置为 false 来完全禁用 loadBalancer 缓存。</p>
<p>尽管基本的非缓存实现对于原型设计和测试很有用，但它的效率远低于缓存版本，因此我们建议始终在生产中使用缓存版本。如果缓存已由 DiscoveryClient 实现完成，例如 EurekaDiscoveryClient，则应禁用负载平衡器缓存以防止双重缓存。</p>
<h4 id="3-4-基于区域的负载平衡"><a href="#3-4-基于区域的负载平衡" class="headerlink" title="3.4.基于区域的负载平衡"></a>3.4.基于区域的负载平衡</h4><p>为了启用基于区域的负载平衡，我们提供了 ZonePreferenceServiceInstanceListSupplier。我们使用 DiscoveryClient 特定的区域配置（例如，eureka.instance.metadata-map.zone）来选择客户端尝试过滤可用服务实例的区域。</p>
<p>您还可以通过设置 spring.cloud.loadbalancer.zone 属性的值来覆盖特定于 DiscoveryClient 的区域设置。</p>
<p>目前，只有 Eureka Discovery Client 被检测来设置 LoadBalancer 区域。对于其他发现客户端，设置 spring.cloud.loadbalancer.zone 属性。更多仪器即将推出。</p>
<p>为了确定检索到的 ServiceInstance 的区域，我们检查其元数据映射中“区域”键下的值。</p>
<p>ZonePreferenceServiceInstanceListSupplier 过滤检索到的实例并只返回同一区域内的实例。如果该区域为空或同一区域内没有实例，则返回所有检索到的实例。</p>
<p>为了使用基于区域的负载平衡方法，您必须在自定义配置中实例化 ZonePreferenceServiceInstanceListSupplier bean。</p>
<p>我们使用委托来处理 ServiceInstanceListSupplier bean。我们建议在 ZonePreferenceServiceInstanceListSupplier 的构造函数中传递一个 DiscoveryClientServiceInstanceListSupplier 委托，然后用 CachingServiceInstanceListSupplier 包装后者以利用 LoadBalancer 缓存机制。</p>
<p>您可以使用此示例配置进行设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoadBalancerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstanceListSupplier <span class="title">discoveryClientServiceInstanceListSupplier</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceInstanceListSupplier.builder()</span><br><span class="line">                    .withDiscoveryClient()</span><br><span class="line">                    .withZonePreference()</span><br><span class="line">                    .withCaching()</span><br><span class="line">                    .build(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-LoadBalancer-的实例健康检查"><a href="#3-5-LoadBalancer-的实例健康检查" class="headerlink" title="3.5. LoadBalancer 的实例健康检查"></a>3.5. LoadBalancer 的实例健康检查</h4><p>可以为 LoadBalancer 启用计划的 HealthCheck。为此提供了 HealthCheckServiceInstanceListSupplier。它会定期验证委托 ServiceInstanceListSupplier 提供的实例是否仍然存在并且只返回健康的实例，除非没有 - 然后它返回所有检索到的实例。</p>
<p>这种机制在使用 SimpleDiscoveryClient 时特别有用。对于由实际 Service Registry 支持的客户端，没有必要使用，因为我们在查询外部 ServiceDiscovery 后已经获得了健康的实例。</p>
<p>还建议将此供应商用于每个服务具有少量实例的设置，以避免在失败的实例上重试调用。</p>
<p>如果使用任何服务发现支持的供应商，通常不需要添加此健康检查机制，因为我们直接从服务注册处检索实例的健康状态。</p>
<p>HealthCheckServiceInstanceListSupplier 依赖于由委托通量提供的更新实例。在极少数情况下，您想使用不刷新实例的委托，即使实例列表可能发生变化（例如我们提供的 DiscoveryClientServiceInstanceListSupplier），您可以设置 spring.cloud.loadbalancer.health-check.refetch -instances 为 true 以使 HealthCheckServiceInstanceListSupplier 刷新实例列表。然后，您还可以通过修改 spring.cloud.loadbalancer.health-check.refetch-instances-interval 的值来调整刷新间隔，并通过设置 spring.cloud.loadbalancer.health-check.repeat- 选择禁用额外的健康检查重复health-check 为 false，因为每个实例重新获取也会触发健康检查。</p>
<p>HealthCheckServiceInstanceListSupplier 使用以 spring.cloud.loadbalancer.health-check 为前缀的属性。您可以为调度程序设置 initialDelay 和间隔。您可以通过设置 spring.cloud.loadbalancer.health-check.path.default 属性的值来设置健康检查 URL 的默认路径。您还可以通过设置 spring.cloud.loadbalancer.health-check.path.[SERVICE_ID] 属性的值，将 [SERVICE_ID] 替换为您的服务的正确 ID，为任何给定服务设置特定值。如果未设置路径，则默认使用 /actuator/health。</p>
<p>如果您依赖默认路径 (/actuator/health)，请确保将 spring-boot-starter-actuator 添加到协作者的依赖项中，除非您计划自行添加此类端点。</p>
<p>为了使用健康检查调度程序方法，您必须在自定义配置中实例化 HealthCheckServiceInstanceListSupplier bean。</p>
<p>我们使用委托来处理 ServiceInstanceListSupplier bean。我们建议在 HealthCheckServiceInstanceListSupplier 的构造函数中传递一个 DiscoveryClientServiceInstanceListSupplier 委托。</p>
<p>您可以使用此示例配置进行设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoadBalancerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstanceListSupplier <span class="title">discoveryClientServiceInstanceListSupplier</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceInstanceListSupplier.builder()</span><br><span class="line">                    .withDiscoveryClient()</span><br><span class="line">                    .withHealthChecks()</span><br><span class="line">                    .build(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于非反应式堆栈，使用 withBlockingHealthChecks() 创建此供应商。您还可以传递您自己的 WebClient 或 RestTemplate 实例以用于检查。</p>
<p>HealthCheckServiceInstanceListSupplier 有自己的基于 Reactor Flux replay() 的缓存机制。因此，如果正在使用它，您可能希望跳过使用 CachingServiceInstanceListSupplier 包装该供应商。</p>
<h4 id="3-6-LoadBalancer-的相同实例首选项"><a href="#3-6-LoadBalancer-的相同实例首选项" class="headerlink" title="3.6. LoadBalancer 的相同实例首选项"></a>3.6. LoadBalancer 的相同实例首选项</h4><p>您可以设置 LoadBalancer，使其更喜欢先前选择的实例（如果该实例可用）。</p>
<p>为此，您需要使用 SameInstancePreferenceServiceInstanceListSupplier。您可以通过将 spring.cloud.loadbalancer.configurations 的值设置为 same-instance-preference 或提供您自己的 ServiceInstanceListSupplier bean — 来配置它，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoadBalancerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstanceListSupplier <span class="title">discoveryClientServiceInstanceListSupplier</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceInstanceListSupplier.builder()</span><br><span class="line">                    .withDiscoveryClient()</span><br><span class="line">                    .withSameInstancePreference()</span><br><span class="line">                    .build(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这也是 Zookeeper StickyRule 的替代品。</p>
<h4 id="3-7-LoadBalancer-的基于请求的粘性会话"><a href="#3-7-LoadBalancer-的基于请求的粘性会话" class="headerlink" title="3.7. LoadBalancer 的基于请求的粘性会话"></a>3.7. LoadBalancer 的基于请求的粘性会话</h4><p>您可以设置 LoadBalancer，使其更喜欢在请求 cookie 中提供 instanceId 的实例。如果请求通过 ClientRequestContext 或 ServerHttpRequestContext 传递给 LoadBalancer，我们当前支持此功能，SC LoadBalancer 交换过滤器功能和过滤器使用它们。</p>
<p>为此，您需要使用 RequestBasedStickySessionServiceInstanceListSupplier。您可以通过将 spring.cloud.loadbalancer.configurations 的值设置为 request-based-sticky-session 或通过提供您自己的 ServiceInstanceListSupplier bean — 来配置它，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoadBalancerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstanceListSupplier <span class="title">discoveryClientServiceInstanceListSupplier</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceInstanceListSupplier.builder()</span><br><span class="line">                    .withDiscoveryClient()</span><br><span class="line">                    .withRequestBasedStickySession()</span><br><span class="line">                    .build(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于该功能，在转发请求之前更新选定的服务实例（如果原始请求 cookie 不可用，则该实例可能与原始请求 cookie 中的服务实例不同）很有用。为此，请将 spring.cloud.loadbalancer.sticky-session.add-service-instance-cookie 的值设置为 true。</p>
<p>默认情况下，cookie 的名称是 sc-lb-instance-id。您可以通过更改 spring.cloud.loadbalancer.instance-id-cookie-name 属性的值来修改它。</p>
<p>WebClient 支持的负载平衡当前支持此功能。</p>
<h4 id="3-8-Spring-Cloud-LoadBalancer-提示"><a href="#3-8-Spring-Cloud-LoadBalancer-提示" class="headerlink" title="3.8. Spring Cloud LoadBalancer 提示"></a>3.8. Spring Cloud LoadBalancer 提示</h4><p>Spring Cloud LoadBalancer 允许您设置传递给 Request 对象内的 LoadBalancer 的字符串提示，稍后可以在可以处理它们的 ReactiveLoadBalancer 实现中使用。</p>
<p>您可以通过设置 spring.cloud.loadbalancer.hint.default 属性的值来为所有服务设置默认提示。您还可以通过设置 spring.cloud.loadbalancer.hint.[SERVICE_ID] 属性的值，将 [SERVICE_ID] 替换为您的服务的正确 ID，为任何给定服务设置特定值。如果用户未设置提示，则使用默认值。</p>
<h4 id="3-9-基于提示的负载平衡"><a href="#3-9-基于提示的负载平衡" class="headerlink" title="3.9.基于提示的负载平衡"></a>3.9.基于提示的负载平衡</h4><p>我们还提供了一个 HintBasedServiceInstanceListSupplier，它是一个 ServiceInstanceListSupplier 实现，用于基于提示的实例选择。</p>
<p>HintBasedServiceInstanceListSupplier 检查提示请求标头（默认标头名称为 X-SC-LB-Hint，但您可以通过更改 spring.cloud.loadbalancer.hint-header-name 属性的值来修改它），如果是找到一个提示请求头，使用头中传递的提示值过滤服务实例。</p>
<p>如果没有添加提示头，HintBasedServiceInstanceListSupplier 使用属性中的提示值来过滤服务实例。</p>
<p>如果头或属性没有设置提示，则返回委托提供的所有服务实例。</p>
<p>在过滤时，HintBasedServiceInstanceListSupplier 查找在其 metadataMap 中的提示键下设置了匹配值的服务实例。如果没有找到匹配的实例，则返回委托提供的所有实例。</p>
<p>您可以使用以下示例配置进行设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoadBalancerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstanceListSupplier <span class="title">discoveryClientServiceInstanceListSupplier</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceInstanceListSupplier.builder()</span><br><span class="line">                    .withDiscoveryClient()</span><br><span class="line">                    .withHints()</span><br><span class="line">                    .withCaching()</span><br><span class="line">                    .build(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-转换负载均衡的-HTTP-请求"><a href="#3-10-转换负载均衡的-HTTP-请求" class="headerlink" title="3.10.转换负载均衡的 HTTP 请求"></a>3.10.转换负载均衡的 HTTP 请求</h4><p>您可以使用选定的 ServiceInstance 来转换负载均衡的 HTTP 请求。</p>
<p>对于 RestTemplate，需要实现和定义 LoadBalancerRequestTransformer 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerRequestTransformer <span class="title">transformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerRequestTransformer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HttpRequest <span class="title">transformRequest</span><span class="params">(HttpRequest request, ServiceInstance instance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpRequestWrapper(request) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">                    headers.putAll(<span class="keyword">super</span>.getHeaders());</span><br><span class="line">                    headers.add(<span class="string">&quot;X-InstanceId&quot;</span>, instance.getInstanceId());</span><br><span class="line">                    <span class="keyword">return</span> headers;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于WebClient，需要实现和定义LoadBalancerClientRequestTransformer如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerClientRequestTransformer <span class="title">transformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerClientRequestTransformer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ClientRequest <span class="title">transformRequest</span><span class="params">(ClientRequest request, ServiceInstance instance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ClientRequest.from(request)</span><br><span class="line">                    .header(<span class="string">&quot;X-InstanceId&quot;</span>, instance.getInstanceId())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果定义了多个转换器，它们将按照定义 Bean 的顺序应用。或者，您可以使用 LoadBalancerRequestTransformer.DEFAULT_ORDER 或 LoadBalancerClientRequestTransformer.DEFAULT_ORDER 来指定顺序。</p>
<h4 id="3-11-Spring-Cloud-LoadBalancer-启动器"><a href="#3-11-Spring-Cloud-LoadBalancer-启动器" class="headerlink" title="3.11. Spring Cloud LoadBalancer 启动器"></a>3.11. Spring Cloud LoadBalancer 启动器</h4><p>我们还提供了一个启动器，允许您在 Spring Boot 应用程序中轻松添加 Spring Cloud LoadBalancer。为了使用它，只需将 org.springframework.cloud:spring-cloud-starter-loadbalancer 添加到构建文件中的 Spring Cloud 依赖项中。</p>
<p>Spring Cloud LoadBalancer starter 包括 Spring Boot Caching 和 Evictor。</p>
<h4 id="3-12-传递你自己的-Spring-Cloud-LoadBalancer-配置"><a href="#3-12-传递你自己的-Spring-Cloud-LoadBalancer-配置" class="headerlink" title="3.12.传递你自己的 Spring Cloud LoadBalancer 配置"></a>3.12.传递你自己的 Spring Cloud LoadBalancer 配置</h4><p>也可以使用@LoadBalancerClient注解传递自己的负载均衡客户端配置，传递负载均衡客户端的名称和配置类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@LoadBalancerClient(value = &quot;stores&quot;, configuration = CustomLoadBalancerConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> WebClient.<span class="function">Builder <span class="title">loadBalancedWebClientBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> WebClient.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示</p>
<p>为了更轻松地处理您自己的 LoadBalancer 配置，我们在 ServiceInstanceListSupplier 类中添加了 builder() 方法。</p>
<p>提示</p>
<p>您还可以使用我们的替代预定义配置代替默认配置，方法是将 spring.cloud.loadbalancer.configurations 属性的值设置为 zone-preference 以使用 ZonePreferenceServiceInstanceListSupplier 与缓存或健康检查以使用 HealthCheckServiceInstanceListSupplier 与缓存。</p>
<p>您可以使用此功能来实例化 ServiceInstanceListSupplier 或 ReactorLoadBalancer 的不同实现，它们可以由您编写，也可以由我们作为替代方案提供（例如 ZonePreferenceServiceInstanceListSupplier）以覆盖默认设置。</p>
<p>您可以在此处查看自定义配置示例。</p>
<p>注释值参数（存储在上面的示例中）指定了我们应该使用给定的自定义配置向其发送请求的服务的服务 ID。</p>
<p>您还可以通过 @LoadBalancerClients 注释传递多个配置（用于多个负载均衡器客户端），如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@LoadBalancerClients(&#123;@LoadBalancerClient(value = &quot;stores&quot;, configuration = StoresLoadBalancerClientConfiguration.class), @LoadBalancerClient(value = &quot;customers&quot;, configuration = CustomersLoadBalancerClientConfiguration.class)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> WebClient.<span class="function">Builder <span class="title">loadBalancedWebClientBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> WebClient.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您作为 @LoadBalancerClient 或 @LoadBalancerClients 配置参数传递的类不应使用 @Configuration 进行注释或不在组件扫描范围内。</p>
<h4 id="3-13-Spring-Cloud-LoadBalancer-生命周期"><a href="#3-13-Spring-Cloud-LoadBalancer-生命周期" class="headerlink" title="3.13. Spring Cloud LoadBalancer 生命周期"></a>3.13. Spring Cloud LoadBalancer 生命周期</h4><p>使用自定义 LoadBalancer 配置注册可能有用的一种 bean 是 LoadBalancerLifecycle。</p>
<p>LoadBalancerLifecycle bean 提供回调方法，名为 onStart(Request<RC> request)、onStartRequest(Request<RC> request, Response<T> lbResponse) 和 onComplete(CompletionContext&lt;RES, T, RC&gt; completionContext)，您应该实现这些方法指定在负载平衡之前和之后应该执行的操作。</p>
<p>onStart(Request<RC> request) 将 Request 对象作为参数。它包含用于选择适当实例的数据，包括下游客户端请求和提示。 onStartRequest 还接受 Request 对象和 Response<T> 对象作为参数。另一方面，为 onComplete(CompletionContext&lt;RES, T, RC&gt; completionContext) 方法提供了一个 CompletionContext 对象。它包含 LoadBalancer 响应，包括选定的服务实例、针对该服务实例执行的请求的状态和（如果可用）返回到下游客户端的响应，以及（如果发生异常）相应的 Throwable。</p>
<p>supports(Class requestContextClass, Class responseClass, Class serverTypeClass) 方法可用于确定相关处理器是否处理所提供类型的对象。如果没有被用户覆盖，则返回 true。</p>
<p>上述方法调用中，RC表示RequestContext类型，RES表示客户端响应类型，T表示返回服务器类型。</p>
<h4 id="3-14-Spring-Cloud-LoadBalancer-统计"><a href="#3-14-Spring-Cloud-LoadBalancer-统计" class="headerlink" title="3.14. Spring Cloud LoadBalancer 统计"></a>3.14. Spring Cloud LoadBalancer 统计</h4><p>我们提供了一个名为 MicrometerStatsLoadBalancerLifecycle 的 LoadBalancerLifecycle bean，它使用 Micrometer 为负载平衡调用提供统计信息。</p>
<p>为了将此 bean 添加到您的应用程序上下文中，请将 spring.cloud.loadbalancer.stats.micrometer.enabled 的值设置为 true 并使用 MeterRegistry（例如，通过将 Spring Boot Actuator 添加到您的项目中）。</p>
<p>MicrometerStatsLoadBalancerLifecycle 在 MeterRegistry 中注册以下仪表：</p>
<ul>
<li>loadbalancer.requests.active：允许您监控任何服务实例的当前活动请求数量的量表（服务实例数据可通过标签获得）； </li>
<li>loadbalancer.requests.success：一个计时器，用于测量已结束将响应传递给底层客户端的任何负载平衡请求的执行时间； </li>
<li>loadbalancer.requests.failed：一个计时器，用于测量任何以异常结束的负载平衡请求的执行时间； </li>
<li>loadbalancer.requests.discard：一个计数器，用于测量被丢弃的负载平衡请求的数量，即负载均衡器尚未检索到运行请求的服务实例的请求。</li>
</ul>
<p>只要可用，有关服务实例、请求数据和响应数据的附加信息就会通过标签添加到指标中。</p>
<p>对于某些实现，例如 BlockingLoadBalancerClient，请求和响应数据可能不可用，因为我们从参数建立泛型类型并且可能无法确定类型并读取数据。</p>
<p>当为给定仪表添加至少一个记录时，仪表将在注册表中注册。</p>
<p>您可以通过添加 MeterFilters 进一步配置这些指标的行为（例如，添加发布百分位数和直方图）</p>
<h3 id="4-Spring-Cloud-断路器"><a href="#4-Spring-Cloud-断路器" class="headerlink" title="4. Spring Cloud 断路器"></a>4. Spring Cloud 断路器</h3><h4 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1.介绍"></a>4.1.介绍</h4><p>Spring Cloud 断路器提供了跨不同断路器实现的抽象。它提供了在您的应用程序中使用的一致 API，让您（开发人员）可以选择最适合您的应用程序需求的断路器实现。</p>
<h5 id="4-1-1-支持的实现"><a href="#4-1-1-支持的实现" class="headerlink" title="4.1.1.支持的实现"></a>4.1.1.支持的实现</h5><p>Spring Cloud 支持以下断路器实现：</p>
<ul>
<li><a href="https://github.com/resilience4j/resilience4j">Resilience4J</a></li>
<li><a href="https://github.com/alibaba/Sentinel">Sentinel</a></li>
<li><a href="https://github.com/spring-projects/spring-retry">Spring Retry</a></li>
</ul>
<h4 id="4-2-核心概念"><a href="#4-2-核心概念" class="headerlink" title="4.2.核心概念"></a>4.2.核心概念</h4><p>要在您的代码中创建断路器，您可以使用 CircuitBreakerFactory API。当您在类路径中包含 Spring Cloud Circuit Breaker starter 时，会自动为您创建一个实现此 API 的 bean。以下示例显示了如何使用此 API 的简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoControllerService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestTemplate rest;</span><br><span class="line">    <span class="keyword">private</span> CircuitBreakerFactory cbFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoControllerService</span><span class="params">(RestTemplate rest, CircuitBreakerFactory cbFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rest = rest;</span><br><span class="line">        <span class="keyword">this</span>.cbFactory = cbFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">slow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cbFactory.create(<span class="string">&quot;slow&quot;</span>).run(() -&gt; rest.getForObject(<span class="string">&quot;/slow&quot;</span>, String.class), throwable -&gt; <span class="string">&quot;fallback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CircuitBreakerFactory.create API 创建了一个名为 CircuitBreaker 的类的实例。 run 方法接受一个供应商和一个函数。供应商是您要包装在断路器中的代码。该功能是在断路器跳闸时运行的回退。该函数传递了引发回退的 Throwable。如果您不想提供后备，您可以选择排除后备。</p>
<h5 id="4-2-1-反应式代码中的断路器"><a href="#4-2-1-反应式代码中的断路器" class="headerlink" title="4.2.1.反应式代码中的断路器"></a>4.2.1.反应式代码中的断路器</h5><p>如果 Project Reactor 在类路径上，您还可以将 ReactiveCircuitBreakerFactory 用于您的反应式代码。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoControllerService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReactiveCircuitBreakerFactory cbFactory;</span><br><span class="line">    <span class="keyword">private</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoControllerService</span><span class="params">(WebClient webClient, ReactiveCircuitBreakerFactory cbFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webClient = webClient;</span><br><span class="line">        <span class="keyword">this</span>.cbFactory = cbFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">slow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webClient.get().uri(<span class="string">&quot;/slow&quot;</span>).retrieve().bodyToMono(String.class).transform(</span><br><span class="line">        it -&gt; cbFactory.create(<span class="string">&quot;slow&quot;</span>).run(it, throwable -&gt; <span class="keyword">return</span> Mono.just(<span class="string">&quot;fallback&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReactiveCircuitBreakerFactory.create API 创建了一个名为 ReactiveCircuitBreaker 的类的实例。 run 方法采用 Mono 或 Flux 并将其包装在断路器中。您可以选择配置回退函数，如果断路器跳闸并传递导致故障的 Throwable，则将调用该函数。</p>
<h4 id="4-3-配置"><a href="#4-3-配置" class="headerlink" title="4.3.配置"></a>4.3.配置</h4><p>您可以通过创建自定义程序类型的 bean 来配置断路器。定制器接口有一个方法（称为定制），可以让对象进行定制。</p>
<p>有关如何自定义给定实现的详细信息，请参阅以下文档：</p>
<ul>
<li><a href="https://docs.spring.io/spring-cloud-commons/spring-cloud-circuitbreaker/current/reference/html/spring-cloud-circuitbreaker.html#configuring-resilience4j-circuit-breakers">Resilience4J</a></li>
<li><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-docs/src/main/asciidoc/circuitbreaker-sentinel.adoc#circuit-breaker-spring-cloud-circuit-breaker-with-sentinel%E2%80%94configuring-sentinel-circuit-breakers">Sentinal</a></li>
<li><a href="https://docs.spring.io/spring-cloud-circuitbreaker/docs/current/reference/html/spring-cloud-circuitbreaker.html#configuring-spring-retry-circuit-breakers">Spring Retry</a></li>
</ul>
<p>每次调用 CircuitBreaker#run 时，某些 CircuitBreaker 实现（例如 Resilience4JCircuitBreaker）都会调用自定义方法。它可能效率低下。在这种情况下，您可以使用 CircuitBreaker#once 方法。在多次调用自定义没有意义的情况下很有用，例如，在使用 Resilience4j 的事件的情况下。</p>
<p>下面的例子展示了每个 io.github.resilience4j.circuitbreaker.CircuitBreaker 消费事件的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Customizer.once(circuitBreaker -&gt; &#123;</span><br><span class="line">  circuitBreaker.getEventPublisher()</span><br><span class="line">    .onStateTransition(event -&gt; log.info(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, event.getCircuitBreakerName(), event.getStateTransition()));</span><br><span class="line">&#125;, CircuitBreaker::getName)</span><br></pre></td></tr></table></figure>

<h3 id="5-CachedRandomPropertySource"><a href="#5-CachedRandomPropertySource" class="headerlink" title="5. CachedRandomPropertySource"></a>5. CachedRandomPropertySource</h3><p>Spring Cloud Context 提供了一个 PropertySource，它根据一个键缓存随机值。在缓存功能之外，它的工作方式与 Spring Boot 的 RandomValuePropertySource 相同。如果您想要一个即使在 Spring 应用程序上下文重新启动后也保持一致的随机值，则此随机值可能很有用。属性值采用 cachedrandom.[yourkey].[type] 的形式，其中 yourkey 是缓存中的键。类型值可以是 Spring Boot 的 RandomValuePropertySource 支持的任何类型。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">myrandom</span>=<span class="string">$&#123;cachedrandom.appname.value&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-Security"><a href="#6-Security" class="headerlink" title="6. Security"></a><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-security">6. Security</a></h3><h4 id="6-1-Single-Sign-On"><a href="#6-1-Single-Sign-On" class="headerlink" title=" 6.1. Single Sign On"></a><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-security-single-sign-on"> 6.1. Single Sign On</a></h4><p>所有 OAuth2 SSO 和资源服务器功能都在 1.3 版中移至 Spring Boot。您可以在 Spring Boot 用户指南中找到文档。</p>
<h5 id="6-1-1-客户端令牌中继relay"><a href="#6-1-1-客户端令牌中继relay" class="headerlink" title="6.1.1.客户端令牌中继relay"></a>6.1.1.客户端令牌中继relay</h5><p>如果您的应用是面向 OAuth2 客户端的用户（即已声明 @EnableOAuth2Sso 或 @EnableOAuth2Client），则它在 Spring Boot 的请求范围内具有 OAuth2ClientContext。您可以从此上下文创建自己的 OAuth2RestTemplate 和自动装配的 OAuth2ProtectedResourceDetails，然后上下文将始终向下游转发访问令牌，并在访问令牌过期时自动刷新访问令牌。 （这些是 Spring Security 和 Spring Boot 的特性。）</p>
<h5 id="6-1-2-资源服务器令牌中继relay"><a href="#6-1-2-资源服务器令牌中继relay" class="headerlink" title="6.1.2.资源服务器令牌中继relay"></a>6.1.2.资源服务器令牌中继relay</h5><p>如果您的应用程序具有 @EnableResourceServer，您可能希望将传入的令牌向下游中继到其他服务。如果您使用 RestTemplate 来联系下游服务，那么这只是如何使用正确的上下文创建模板的问题。</p>
<p>如果您的服务使用 UserInfoTokenServices 来验证传入的令牌（即它使用 security.oauth2.user-info-uri 配置），那么您可以简单地使用自动装配的 OAuth2ClientContext 创建一个 OAuth2RestTemplate（它将在命中之前由身份验证过程填充后端代码）。等效地（使用 Spring Boot 1.4），您可以注入 UserInfoRestTemplateFactory 并在您的配置中获取其 OAuth2RestTemplate。例如：</p>
<p><strong>MyConfiguration.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OAuth2RestTemplate <span class="title">restTemplate</span><span class="params">(UserInfoRestTemplateFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factory.getUserInfoRestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 rest 模板将具有与身份验证过滤器使用的相同的 OAuth2ClientContext（请求范围），因此您可以使用它来发送具有相同访问令牌的请求。</p>
<p>如果您的应用程序没有使用 UserInfoTokenServices 但仍然是客户端（即它声明了 @EnableOAuth2Client 或 @EnableOAuth2Sso），那么使用 Spring Security Cloud，用户从 @Autowired OAuth2Context 创建的任何 OAuth2RestOperations 也将转发令牌。这个特性默认实现为一个MVC处理程序拦截器，所以它只适用于Spring MVC。如果您不使用 MVC，您可以使用自定义过滤器或 AOP 拦截器包装 AccessTokenContextRelay 来提供相同的功能。</p>
<p>这是一个基本示例，展示了使用在别处创建的自动装配的休息模板（“foo.com”是一个资源服务器，接受与周围应用程序相同的令牌）：</p>
<p><strong>MyController.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OAuth2RestOperations restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/relay&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">relay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResponseEntity&lt;String&gt; response =</span><br><span class="line">      restTemplate.getForEntity(<span class="string">&quot;https://foo.com/bar&quot;</span>, String.class);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Success! (&quot;</span> + response.getBody() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您不想转发令牌（这是一个有效的选择，因为您可能想扮演自己的角色，而不是向您发送令牌的客户端），那么您只需要创建自己的 OAuth2Context 而不是自动装配默认一个。</p>
<p>如果可用，Feign 客户端还将选择使用 OAuth2ClientContext 的拦截器，因此他们还应该在 RestTemplate 所在的任何地方进行令牌中继。</p>
<h3 id="7-配置属性"><a href="#7-配置属性" class="headerlink" title="7. 配置属性"></a>7. 配置属性</h3><p>附录 A：常见的应用程序属性</p>
<p>可以在 application.properties 文件、application.yml 文件或命令行开关中指定各种属性。本附录提供了常见 Spring Cloud Commons 属性的列表以及对使用它们的底层类的引用。</p>
<p>属性贡献可以来自类路径上的其他 jar 文件，因此您不应认为这是一个详尽的列表。此外，您可以定义自己的属性。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">spring.cloud.compatibility-verifier.compatible-boot-versions</td>
<td align="left"></td>
<td align="left">Spring Boot 依赖项的默认接受版本。如果不想指定具体值，可以为补丁版本设置 {@code x}。示例：{@code 3.4.x}</td>
</tr>
<tr>
<td align="left">spring.cloud.compatibility-verifier.enabled</td>
<td align="left"><code>false</code></td>
<td align="left">启用创建 Spring Cloud 兼容性验证。</td>
</tr>
<tr>
<td align="left">spring.cloud.config.allow-override</td>
<td align="left"><code>true</code></td>
<td align="left">指示可以使用 {@link #isOverrideSystemProperties() systemPropertiesOverride} 的标志。设置为 false 以防止用户意外更改默认值。默认为真。</td>
</tr>
<tr>
<td align="left">spring.cloud.config.override-none</td>
<td align="left"><code>false</code></td>
<td align="left">标记以指示当 {@link #setAllowOverride(boolean) allowOverride} 为 true 时，外部属性应具有最低优先级并且不应覆盖任何现有属性源（包括本地配置文件）。默认为假。</td>
</tr>
<tr>
<td align="left">spring.cloud.config.override-system-properties</td>
<td align="left"><code>true</code></td>
<td align="left">标志以指示外部属性应覆盖系统属性。默认为真。</td>
</tr>
<tr>
<td align="left">spring.cloud.decrypt-environment-post-processor.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">启用 DecryptEnvironmentPostProcessor。</td>
</tr>
<tr>
<td align="left">spring.cloud.discovery.client.composite-indicator.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">启用发现客户端复合健康指标。</td>
</tr>
<tr>
<td align="left">spring.cloud.discovery.client.health-indicator.enabled</td>
<td align="left"><code>true</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">spring.cloud.discovery.client.health-indicator.include-description</td>
<td align="left"><code>false</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">spring.cloud.discovery.client.health-indicator.use-services-query</td>
<td align="left"><code>true</code></td>
<td align="left">指标是否应使用 {@link DiscoveryClient#getServices} 来检查其健康状况。当设置为 {@code false} 时，指示器会使用较轻的 {@link DiscoveryClient#probe()}。这在返回的服务数量使操作不必要地繁重的大型部署中很有帮助。</td>
</tr>
<tr>
<td align="left">spring.cloud.discovery.client.simple.instances</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">spring.cloud.discovery.client.simple.order</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">spring.cloud.discovery.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">启用发现客户端健康指标。</td>
</tr>
<tr>
<td align="left">spring.cloud.features.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">启用功能端点。</td>
</tr>
<tr>
<td align="left">spring.cloud.httpclientfactories.apache.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">允许创建 Apache Http 客户端工厂 bean。</td>
</tr>
<tr>
<td align="left">spring.cloud.httpclientfactories.ok.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">启用 OK Http Client 工厂 bean 的创建。</td>
</tr>
<tr>
<td align="left">spring.cloud.hypermedia.refresh.fixed-delay</td>
<td align="left"><code>5000</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">spring.cloud.hypermedia.refresh.initial-delay</td>
<td align="left"><code>10000</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">spring.cloud.inetutils.default-hostname</td>
<td align="left"><code>localhost</code></td>
<td align="left">默认主机名。发生错误时使用。</td>
</tr>
<tr>
<td align="left">spring.cloud.inetutils.default-ip-address</td>
<td align="left"><code>127.0.0.1</code></td>
<td align="left">默认 IP 地址。发生错误时使用。</td>
</tr>
<tr>
<td align="left">spring.cloud.inetutils.ignored-interfaces</td>
<td align="left"></td>
<td align="left">将被忽略的网络接口的 Java 正则表达式列表。</td>
</tr>
<tr>
<td align="left">spring.cloud.inetutils.preferred-networks</td>
<td align="left"></td>
<td align="left">首选网络地址的 Java 正则表达式列表。</td>
</tr>
<tr>
<td align="left">spring.cloud.inetutils.timeout-seconds</td>
<td align="left"><code>1</code></td>
<td align="left">计算主机名的超时时间，以秒为单位。</td>
</tr>
<tr>
<td align="left">spring.cloud.inetutils.use-only-site-local-interfaces</td>
<td align="left"><code>false</code></td>
<td align="left">是否仅使用具有站点本地地址的接口。有关更多详细信息，请参阅 {@link InetAddress#isSiteLocalAddress()}。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.cache.caffeine.spec</td>
<td align="left"></td>
<td align="left">用于创建缓存的规范。有关规范格式的更多详细信息，请参阅 CaffeineSpec。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.cache.capacity</td>
<td align="left"><code>256</code></td>
<td align="left">初始缓存容量表示为 int。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.cache.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">启用 Spring Cloud LoadBalancer 缓存机制</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.cache.ttl</td>
<td align="left"><code>35s</code></td>
<td align="left">生存时间 - 从写入记录开始计算的时间，之后缓存条目过期，表示为 {@link Duration}。属性 {@link String} 必须符合 Spring Boot <code>StringToDurationConverter</code> 中指定的适当语法。 @see <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/convert /StringToDurationConverter.java">StringToDurationConverter.java</a></td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.configurations</td>
<td align="left"><code>default</code></td>
<td align="left">启用预定义的 LoadBalancer 配置。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">启用 Spring Cloud LoadBalancer。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.health-check.initial-delay</td>
<td align="left"><code>0</code></td>
<td align="left">HealthCheck 调度程序的初始延迟值。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.health-check.interval</td>
<td align="left"><code>25s</code></td>
<td align="left">重新运行 HealthCheck 调度程序的时间间隔。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.health-check.path</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.health-check.refetch-instances</td>
<td align="left"><code>false</code></td>
<td align="left">指示是否应由 <code>HealthCheckServiceInstanceListSupplier</code> 重新获取实例。如果实例可以更新并且底层委托不提供持续的流量，则可以使用此方法。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.health-check.refetch-instances-interval</td>
<td align="left"><code>25s</code></td>
<td align="left">重新获取可用服务实例的时间间隔。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.health-check.repeat-health-check</td>
<td align="left"><code>true</code></td>
<td align="left">指示是否应继续重复运行状况检查。如果定期重新获取实例，将其设置为 <code>false</code> 可能会很有用，因为每次重新获取也会触发健康检查。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.hint</td>
<td align="left"></td>
<td align="left">允许设置传递给 LoadBalancer 请求的 <code>hint</code> 值，随后可以在 {@link ReactiveLoadBalancer} 实现中使用。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.hint-header-name</td>
<td align="left"><code>X-SC-LB-Hint</code></td>
<td align="left">允许设置用于传递基于提示的服务实例过滤提示的标头名称。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.retry.avoid-previous-instance</td>
<td align="left"><code>true</code></td>
<td align="left">如果 Spring-Retry 在类路径中，则启用使用 RetryAwareServiceInstanceListSupplier 包装 ServiceInstanceListSupplier bean。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.retry.backoff.enabled</td>
<td align="left"><code>false</code></td>
<td align="left">指示是否应应用反应器重试退避。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.retry.backoff.jitter</td>
<td align="left"><code>0.5</code></td>
<td align="left">用于设置 {@link RetryBackoffSpec#jitter}。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.retry.backoff.max-backoff</td>
<td align="left"></td>
<td align="left">用于设置 {@link RetryBackoffSpec#maxBackoff}。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.retry.backoff.min-backoff</td>
<td align="left"><code>5ms</code></td>
<td align="left">用于设置 {@link RetryBackoffSpec#minBackoff}。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.retry.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">启用 LoadBalancer 重试。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.retry.max-retries-on-next-service-instance</td>
<td align="left"><code>1</code></td>
<td align="left">要在下一个 <code>ServiceInstance</code> 上执行的重试次数。在每次重试调用之前选择一个 <code>ServiceInstance</code>。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.retry.max-retries-on-same-service-instance</td>
<td align="left"><code>0</code></td>
<td align="left">要在同一 <code>ServiceInstance</code> 上执行的重试次数。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.retry.retry-on-all-operations</td>
<td align="left"><code>false</code></td>
<td align="left">表示应尝试对除 {@link HttpMethod#GET} 以外的操作进行重试。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.retry.retryable-status-codes</td>
<td align="left"></td>
<td align="left">应触发重试的状态代码 {@link Set}。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.service-discovery.timeout</td>
<td align="left"></td>
<td align="left">调用服务发现的超时时间的字符串表示形式。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.sticky-session.add-service-instance-cookie</td>
<td align="left"><code>false</code></td>
<td align="left">指示 SC LoadBalancer 是否应添加带有新选择实例的 cookie。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.sticky-session.instance-id-cookie-name</td>
<td align="left"><code>sc-lb-instance-id</code></td>
<td align="left">保存首选实例 ID 的 cookie 的名称。</td>
</tr>
<tr>
<td align="left">spring.cloud.loadbalancer.zone</td>
<td align="left"></td>
<td align="left">Spring Cloud LoadBalancer 区域。</td>
</tr>
<tr>
<td align="left">spring.cloud.refresh.additional-property-sources-to-retain</td>
<td align="left"></td>
<td align="left">刷新期间要保留的其他属性源。通常只保留系统属性源。此属性还允许保留属性源，例如由 EnvironmentPostProcessors 创建的属性源。</td>
</tr>
<tr>
<td align="left">spring.cloud.refresh.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">启用刷新范围和相关功能的自动配置。</td>
</tr>
<tr>
<td align="left">spring.cloud.refresh.extra-refreshable</td>
<td align="left"><code>true</code></td>
<td align="left">用于将处理后处理到刷新范围的 bean 的其他类名。</td>
</tr>
<tr>
<td align="left">spring.cloud.refresh.never-refreshable</td>
<td align="left"><code>true</code></td>
<td align="left">逗号分隔的 bean 类名列表，永远不会被刷新或反弹。</td>
</tr>
<tr>
<td align="left">spring.cloud.service-registry.auto-registration.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">是否开启服务自动注册。默认为真。</td>
</tr>
<tr>
<td align="left">spring.cloud.service-registry.auto-registration.fail-fast</td>
<td align="left"><code>false</code></td>
<td align="left">如果没有 AutoServiceRegistration，是否启动失败。默认为假。</td>
</tr>
<tr>
<td align="left">spring.cloud.service-registry.auto-registration.register-management</td>
<td align="left"><code>true</code></td>
<td align="left">是否将管理注册为服务。默认为真。</td>
</tr>
<tr>
<td align="left">spring.cloud.util.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">启用创建 Spring Cloud 实用程序 bean。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudOpenFeign基本使用</title>
    <url>/2021/11/09/SpringCloudOpenFeign%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-OpenFeign基本使用"><a href="#Spring-Cloud-OpenFeign基本使用" class="headerlink" title="Spring Cloud OpenFeign基本使用"></a>Spring Cloud OpenFeign基本使用</h1><p>该项目通过自动配置和绑定到 Spring Environment 和其他 Spring 编程模型，为 Spring Boot 应用程序提供 OpenFeign 集成。</p>
<h2 id="1、声明式-REST-客户端：Feign"><a href="#1、声明式-REST-客户端：Feign" class="headerlink" title="1、声明式 REST 客户端：Feign"></a>1、声明式 REST 客户端：Feign</h2><p>Feign 是一个声明式 Web 服务客户端。它使编写 Web 服务客户端变得更容易。要使用 Feign 创建一个接口并对其进行注释。它具有可插入的注释支持，包括 Feign 注释和 JAX-RS 注释。 Feign 还支持可插拔的编码器和解码器。 Spring Cloud 添加了对 Spring MVC 注释的支持，并支持使用 Spring Web 中默认使用的相同 HttpMessageConverters。 Spring Cloud 集成了 Eureka、Spring Cloud CircuitBreaker 和 Spring Cloud LoadBalancer，在使用 Feign 时提供负载均衡的 http 客户端。</p>
<h3 id="1-1、如何集成-Feign"><a href="#1-1、如何集成-Feign" class="headerlink" title="1.1、如何集成 Feign"></a>1.1、如何集成 Feign</h3><p>要将 Feign 包含在您的项目中，请使用带有group org.springframework.cloud 和artifact ID spring-cloud-starter-openfeign 的 starter。有关使用当前 Spring Cloud Release Train 设置构建系统的详细信息，请参阅 Spring Cloud 项目页面。 </p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>StoreClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;stores&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StoreClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Store&gt; <span class="title">getStores</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)</span></span><br><span class="line">    <span class="function">Page&lt;Store&gt; <span class="title">getStores</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.POST, value = &quot;/stores/&#123;storeId&#125;&quot;, consumes = &quot;application/json&quot;)</span></span><br><span class="line">    <span class="function">Store <span class="title">update</span><span class="params">(<span class="meta">@PathVariable(&quot;storeId&quot;)</span> Long storeId, Store store)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在@FeignClient 注释中，String 值（上面的“stores”）是任意客户端名称，用于创建 Spring Cloud LoadBalancer 客户端。您还可以使用 url 属性（绝对值或仅主机名）指定 URL。应用程序上下文中 bean 的名称是接口的完全限定名称。要指定您自己的别名值，您可以使用 @FeignClient 注释的限定符值。</p>
<p>上面的负载平衡器客户端将想要发现“stores”服务的物理地址。如果您的应用程序是 Eureka 客户端，那么它将解析 Eureka 服务注册表中的服务。如果不想使用 Eureka，可以使用 SimpleDiscoveryClient 在外部配置中配置服务器列表。</p>
<p>要在 @Configuration-annotated-classes 上使用 @EnableFeignClients 注释，请确保指定客户端所在的位置，例如：@EnableFeignClients(basePackages = “com.example.clients”) 或明确列出它们：@EnableFeignClients(clients = InventoryServiceFeignClient .class）</p>
<h3 id="1-2-覆盖-Feign-默认值"><a href="#1-2-覆盖-Feign-默认值" class="headerlink" title="1.2.覆盖 Feign 默认值"></a>1.2.覆盖 Feign 默认值</h3><p>Spring Cloud 的 Feign 支持的一个核心概念是命名客户端。每个 feign 客户端都是一个组件集合的一部分，这些组件一起工作以根据需要联系远程服务器，并且集合有一个名称，您可以使用 @FeignClient 注释作为应用程序开发人员为其指定。 Spring Cloud 使用 FeignClientsConfiguration 为每个命名的客户端按需创建一个新的集成作为 ApplicationContext。这包含（除其他外）一个 feign.Decoder、一个 feign.Encoder 和一个 feign.Contract。可以使用 @FeignClient 注释的 contextId 属性来覆盖该集合的名称。</p>
<p>Spring Cloud 允许您通过使用 @FeignClient 声明额外的配置（在 FeignClientsConfiguration 之上）来完全控制 feign 客户端。例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;stores&quot;, configuration = FooConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StoreClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，客户端由 FeignClientsConfiguration 中已有的组件和 FooConfiguration 中的任何组件组成（后者将覆盖前者）。</p>
<p>FooConfiguration 不需要用@Configuration 注释。但是，如果是，那么请注意将其从任何包含此配置的@ComponentScan 中排除，因为在指定时它将成为 feign.Decoder、feign.Encoder、feign.Contract 等的默认源。这可以通过将它放在与任何 @ComponentScan 或 @SpringBootApplication 分开的、不重叠的包中来避免，或者可以在 @ComponentScan 中明确排除它。</p>
<p>除了更改 ApplicationContext 集合的名称之外，使用 @FeignClient 注释的 contextId 属性，它将覆盖客户端名称的别名，并将用作为该客户端创建的配置 bean 名称的一部分。</p>
<p>name 和 url 属性支持占位符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;$&#123;feign.name&#125;&quot;, url = &quot;$&#123;feign.url&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StoreClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Cloud OpenFeign 默认为 feign 提供了以下 bean（BeanType beanName: ClassName）：</p>
<ul>
<li><code>Decoder</code>feignDecoder: <code>ResponseEntityDecoder</code>( 包装了一个<code>SpringDecoder</code>)</li>
<li><code>Encoder</code> feignEncoder： <code>SpringEncoder</code></li>
<li><code>Logger</code> feignLogger： <code>Slf4jLogger</code></li>
<li><code>MicrometerCapability</code>micrometerCapability：如果<code>feign-micrometer</code>在类路径上并且<code>MeterRegistry</code>可用</li>
<li><code>Contract</code> feignContract： <code>SpringMvcContract</code></li>
<li><code>Feign.Builder</code> feignBuilder： <code>FeignCircuitBreaker.Builder</code></li>
<li><code>Client</code>feignClient：如果 Spring Cloud LoadBalancer 在类路径上，<code>FeignBlockingLoadBalancerClient</code>则使用。如果它们都不在类路径上，则使用默认的 feign 客户端。</li>
</ul>
<p>spring-cloud-starter-openfeign 支持 spring-cloud-starter-loadbalancer。但是，作为一个可选的依赖项，如果您想使用它，您需要确保将其添加到您的项目中。</p>
<p>OkHttpClient 和 ApacheHttpClient 以及 ApacheHC5 feign 客户端可以通过将 feign.okhttp.enabled 或 feign.httpclient.enabled 或 feign.httpclient.hc5.enabled 分别设置为 true 并将它们放在类路径上来使用。您可以通过在使用 Apache 时提供 org.apache.http.impl.client.CloseableHttpClient 或 okhttp3.OkHttpClient 在使用 OK HTTP 或 org.apache.hc.client5.http.impl.classic 时提供 bean 来自定义使用的 HTTP 客户端。使用 Apache HC5 时的 CloseableHttpClient。</p>
<p>Spring Cloud OpenFeign 默认没有为 feign 提供以下 bean，但仍然会从应用程序上下文中查找这些类型的 bean 来创建 feign 客户端：</p>
<ul>
<li><code>Logger.Level</code></li>
<li><code>Retryer</code></li>
<li><code>ErrorDecoder</code></li>
<li><code>Request.Options</code></li>
<li><code>Collection&lt;RequestInterceptor&gt;</code></li>
<li><code>SetterFactory</code></li>
<li><code>QueryMapEncoder</code></li>
<li><code>Capability</code> (<code>MicrometerCapability</code> is provided by default)</li>
</ul>
<p>默认情况下会创建 Retryer.NEVER_RETRY 类型为 Retryer 的 bean，这将禁用重试。请注意，这种重试行为与 Feign 默认行为不同，它会自动重试 IOExceptions，将它们视为与网络相关的瞬态异常，以及从 ErrorDecoder 抛出的任何 RetryableException。</p>
<p>创建其中一种类型的 bean 并将其放置在 @FeignClient 配置中（例如上面的 FooConfiguration）允许您覆盖所描述的每个 bean。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> feign.Contract.Default();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将 SpringMvcContract 替换为 feign.Contract.Default 并将 RequestInterceptor 添加到 RequestInterceptor 的集合中。</p>
<p>@FeignClient 也可以使用配置属性进行配置。</p>
<p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">            <span class="attr">feignName:</span></span><br><span class="line">                <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line">                <span class="attr">errorDecoder:</span> <span class="string">com.example.SimpleErrorDecoder</span></span><br><span class="line">                <span class="attr">retryer:</span> <span class="string">com.example.SimpleRetryer</span></span><br><span class="line">                <span class="attr">defaultQueryParameters:</span></span><br><span class="line">                    <span class="attr">query:</span> <span class="string">queryValue</span></span><br><span class="line">                <span class="attr">defaultRequestHeaders:</span></span><br><span class="line">                    <span class="attr">header:</span> <span class="string">headerValue</span></span><br><span class="line">                <span class="attr">requestInterceptors:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">com.example.FooRequestInterceptor</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">com.example.BarRequestInterceptor</span></span><br><span class="line">                <span class="attr">decode404:</span> <span class="literal">false</span></span><br><span class="line">                <span class="attr">encoder:</span> <span class="string">com.example.SimpleEncoder</span></span><br><span class="line">                <span class="attr">decoder:</span> <span class="string">com.example.SimpleDecoder</span></span><br><span class="line">                <span class="attr">contract:</span> <span class="string">com.example.SimpleContract</span></span><br><span class="line">                <span class="attr">capabilities:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">com.example.FooCapability</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">com.example.BarCapability</span></span><br><span class="line">                <span class="attr">metrics.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>可以以与上述类似的方式在 @EnableFeignClients 属性 defaultConfiguration 中指定默认配置。不同之处在于此配置将适用于所有 feign 客户端。</p>
<p>如果您更喜欢使用配置属性来配置所有 @FeignClient，您可以使用默认的 feign 名称创建配置属性。</p>
<p>您可以使用 feign.client.config.feignName.defaultQueryParameters 和 feign.client.config.feignName.defaultRequestHeaders 来指定将与名为 feignName 的客户端的每个请求一起发送的查询参数和标头。</p>
<p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">            <span class="attr">default:</span></span><br><span class="line">                <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">loggerLevel:</span> <span class="string">basic</span></span><br></pre></td></tr></table></figure>

<p>如果我们同时创建@Configuration bean 和配置属性，配置属性将获胜。它将覆盖@Configuration 值。但是如果你想把优先级改成@Configuration，你可以把feign.client.default-to-properties改成false。</p>
<p>如果我们想创建多个具有相同名称或 url 的 feign 客户端，以便它们指向同一服务器但每个具有不同的自定义配置，那么我们必须使用 @FeignClient 的 contextId 属性以避免这些配置的名称冲突Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(contextId = &quot;fooClient&quot;, name = &quot;stores&quot;, configuration = FooConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FooClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(contextId = &quot;barClient&quot;, name = &quot;stores&quot;, configuration = BarConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BarClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以将 FeignClient 配置为不从父上下文继承 bean。您可以通过覆盖 FeignClientConfigurer bean 中的 inheritParentConfiguration() 以返回 false 来实现此目的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConfiguration</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FeignClientConfigurer <span class="title">feignClientConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FeignClientConfigurer() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inheritParentConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，Feign 客户端不编码斜杠/字符。您可以通过将 feign.client.decodeSlash 的值设置为 false 来更改此行为。</p>
<h4 id="1-2-1-SpringEncoder-配置"><a href="#1-2-1-SpringEncoder-配置" class="headerlink" title="1.2.1. SpringEncoder 配置"></a>1.2.1. SpringEncoder 配置</h4><p>在我们提供的 SpringEncoder 中，我们为二进制内容类型设置空字符集，为所有其他类型设置 UTF-8。</p>
<p>您可以修改此行为以通过将 feign.encoder.charset-from-content-type 的值设置为 true 来从 Content-Type 标头字符集派生字符集。</p>
<h3 id="1-3-超时处理"><a href="#1-3-超时处理" class="headerlink" title="1.3.超时处理"></a>1.3.超时处理</h3><p>我们可以在默认客户端和命名客户端上配置超时。 OpenFeign 使用两个超时参数：</p>
<ul>
<li><code>connectTimeout</code> 防止由于服务器处理时间长而阻塞调用者。</li>
<li><code>readTimeout</code> 从连接建立时开始应用，在返回响应时间过长时触发。</li>
</ul>
<p>如果服务器未运行或不可用，则数据包会导致连接被拒绝。通信以错误消息或回退结束。如果它设置得非常低，这可能会在 connectTimeout 之前发生。执行查找和接收此类数据包所花费的时间会导致此延迟的很大一部分。它可能会根据涉及 DNS 查找的远程主机进行更改。</p>
<h3 id="1-4-手动创建-Feign-客户端"><a href="#1-4-手动创建-Feign-客户端" class="headerlink" title="1.4.手动创建 Feign 客户端"></a>1.4.手动创建 Feign 客户端</h3><p>在某些情况下，可能需要以使用上述方法无法实现的方式自定义您的 Feign Client。在这种情况下，您可以使用 Feign Builder API 创建客户端。下面是一个示例，它创建了两个具有相同接口的 Feign 客户端，但为每个客户端配置了一个单独的请求拦截器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(FeignClientsConfiguration.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FooClient fooClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FooClient adminClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooController</span><span class="params">(Client client, Encoder encoder, Decoder decoder, Contract contract, MicrometerCapability micrometerCapability)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fooClient = Feign.builder().client(client)</span><br><span class="line">                .encoder(encoder)</span><br><span class="line">                .decoder(decoder)</span><br><span class="line">                .contract(contract)</span><br><span class="line">                .addCapability(micrometerCapability)</span><br><span class="line">                .requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;user&quot;</span>))</span><br><span class="line">                .target(FooClient.class, <span class="string">&quot;https://PROD-SVC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.adminClient = Feign.builder().client(client)</span><br><span class="line">                .encoder(encoder)</span><br><span class="line">                .decoder(decoder)</span><br><span class="line">                .contract(contract)</span><br><span class="line">                .addCapability(micrometerCapability)</span><br><span class="line">                .requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;admin&quot;</span>))</span><br><span class="line">                .target(FooClient.class, <span class="string">&quot;https://PROD-SVC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中的 FeignClientsConfiguration.class 是 Spring Cloud OpenFeign 提供的默认配置。</p>
<p>PROD-SVC 是客户端将向其发出请求的服务的名称。</p>
<p>Feign Contract 对象定义了接口上哪些注解和值是有效的。自动装配的 Contract bean 提供对 SpringMVC 注释的支持，而不是默认的 Feign 原生注释。</p>
<p>您还可以使用 Builder<code>将 FeignClient 配置为不从父上下文继承 bean。您可以通过在 Builder 上覆盖调用</code>inheritParentContext(false) 来做到这一点。</p>
<h3 id="1-5-Feign-Spring-Cloud-断路器支持"><a href="#1-5-Feign-Spring-Cloud-断路器支持" class="headerlink" title="1.5. Feign Spring Cloud 断路器支持"></a>1.5. Feign Spring Cloud 断路器支持</h3><p>如果 Spring Cloud CircuitBreaker 在类路径上并且 feign.circuitbreaker.enabled=true，Feign 将使用断路器包装所有方法。 要在每个客户端的基础上禁用 Spring Cloud CircuitBreaker 支持，请创建一个具有“prototype”范围的 vanilla Feign.Builder，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Feign.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断路器名称遵循此模式 <feignClientClassName>#<CalledMethod>(<parameterTypes>)。当调用带有 FooClient 接口的 @FeignClient 并且被调用的没有参数的接口方法是 bar 时，断路器名称将是 FooClient#bar()。</p>
<p>从 2020.0.2 开始，断路器名称模式已从 <feignClientName>_<CalledMethod> 更改。使用 2020.0.4 中引入的 CircuitBreakerNameResolver，断路器名称可以保留旧模式。</p>
<p>提供 CircuitBreakerNameResolver 的 bean，您可以更改断路器名称模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CircuitBreakerNameResolver <span class="title">circuitBreakerNameResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String feignClientName, Target&lt;?&gt; target, Method method) -&gt; feignClientName + <span class="string">&quot;_&quot;</span> + method.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要启用 Spring Cloud CircuitBreaker 组，请将 feign.circuitbreaker.group.enabled 属性设置为 true（默认为 false）。</p>
<h3 id="1-6-Feign-Spring-Cloud-断路器Fallbacks"><a href="#1-6-Feign-Spring-Cloud-断路器Fallbacks" class="headerlink" title="1.6. Feign Spring Cloud 断路器Fallbacks"></a>1.6. Feign Spring Cloud 断路器Fallbacks</h3><p>Spring Cloud CircuitBreaker 支持fallback的概念：当电路打开或出现错误时执行的默认代码路径。要为给定的 @FeignClient 启用回退，请将回退属性设置为实现回退的类名。您还需要将您的实现声明为 Spring bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;test&quot;, url = &quot;http://localhost:$&#123;server.port&#125;/&quot;, fallback = Fallback.class)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/hello&quot;)</span></span><br><span class="line">        <span class="function">Hello <span class="title">getHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/hellonotfound&quot;)</span></span><br><span class="line">        <span class="function">String <span class="title">getException</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Fallback</span> <span class="keyword">implements</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Hello <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoFallbackAvailableException(<span class="string">&quot;Boom!&quot;</span>, <span class="keyword">new</span> RuntimeException());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Fixed response&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>If one needs access to the cause that made the fallback trigger, one can use the <code>fallbackFactory</code> attribute inside <code>@FeignClient</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;testClientWithFactory&quot;, url = &quot;http://localhost:$&#123;server.port&#125;/&quot;,</span></span><br><span class="line"><span class="meta">            fallbackFactory = TestFallbackFactory.class)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestClientWithFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/hello&quot;)</span></span><br><span class="line">        <span class="function">Hello <span class="title">getHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/hellonotfound&quot;)</span></span><br><span class="line">        <span class="function">String <span class="title">getException</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">FallbackWithFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FallbackWithFactory <span class="title">create</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FallbackWithFactory();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FallbackWithFactory</span> <span class="keyword">implements</span> <span class="title">TestClientWithFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Hello <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoFallbackAvailableException(<span class="string">&quot;Boom!&quot;</span>, <span class="keyword">new</span> RuntimeException());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Fixed response&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-Feign-和-Primary"><a href="#1-7-Feign-和-Primary" class="headerlink" title="1.7. Feign 和@Primary"></a>1.7. Feign 和@Primary</h3><p>将 Feign 与 Spring Cloud CircuitBreaker fallback一起使用时，ApplicationContext 中有多个相同类型的 bean。这将导致 @Autowired 无法工作，因为没有一个 bean，或者一个标记为主要的 bean。为了解决这个问题，Spring Cloud OpenFeign 将所有 Feign 实例标记为 @Primary，因此 Spring Framework 将知道要注入哪个 bean。在某些情况下，这可能是不可取的。要关闭此行为，请将 @FeignClient 的主要属性设置为 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;hello&quot;, primary = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// methods here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-Feign-继承支持"><a href="#1-8-Feign-继承支持" class="headerlink" title="1.8. Feign 继承支持"></a>1.8. Feign 继承支持</h3><p>Feign 通过单继承接口支持样板 API。这允许将常见操作分组到方便的基本接口中。</p>
<p>UserService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value =&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserResource.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserResource</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserClient.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> project.user;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> <span class="keyword">extends</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常不建议在服务器和客户端之间共享一个接口。它引入了紧耦合，也不是所有维护的 Spring MVC 版本都支持（某些版本没有继承方法参数映射）。</p>
<h3 id="1-9-Feign-请求-响应压缩"><a href="#1-9-Feign-请求-响应压缩" class="headerlink" title="1.9. Feign 请求/响应压缩"></a>1.9. Feign 请求/响应压缩</h3><p>您可以考虑为您的 Feign 请求启用请求或响应 GZIP 压缩。您可以通过启用以下属性之一来执行此操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">feign.compression.request.enabled=<span class="keyword">true</span></span><br><span class="line">feign.compression.response.enabled=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>Feign 请求压缩为您提供类似于您为 Web 服务器设置的设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">feign.compression.request.enabled=<span class="keyword">true</span></span><br><span class="line">feign.compression.request.mime-types=text/xml,application/xml,application/json</span><br><span class="line">feign.compression.request.min-request-size=<span class="number">2048</span></span><br></pre></td></tr></table></figure>

<p>这些属性允许您选择压缩媒体类型和最小请求阈值长度。</p>
<p>对于除了 OkHttpClient 之外的 http 客户端，可以启用默认的 gzip 解码器来解码 UTF-8 编码的 gzip 响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">feign.compression.response.enabled=<span class="keyword">true</span></span><br><span class="line">feign.compression.response.useGzipDecoder=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h3 id="1-10-Feign-logging"><a href="#1-10-Feign-logging" class="headerlink" title="1.10.Feign logging"></a>1.10.Feign logging</h3><p>为每个创建的 Feign 客户端创建一个记录器。默认情况下，记录器的名称是用于创建 Feign 客户端的接口的完整类名。 Feign logging 只响应 DEBUG 级别。</p>
<p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.level.project.user.UserClient:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>您可以为每个客户端配置的 Logger.Level 对象告诉 Feign 要记录多少。选择是：</p>
<ul>
<li><code>NONE</code>, 无日志记录（默认）。</li>
<li><code>BASIC</code>, 仅记录请求方法和 URL 以及响应状态代码和执行时间。</li>
<li><code>HEADERS</code>, 记录基本信息以及请求和响应标头。</li>
<li><code>FULL</code>, 记录请求和响应的标头、正文和元数据。</li>
</ul>
<p>例如，以下内容会将 Logger.Level 设置为 FULL：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-11-Feign-Capability支持"><a href="#1-11-Feign-Capability支持" class="headerlink" title="1.11. Feign Capability支持"></a>1.11. Feign Capability支持</h3><p>Feign 功能公开了核心 Feign 组件，以便可以修改这些组件。例如，功能可以获取客户端，对其进行装饰，并将装饰后的实例返回给 Feign。对指标库的支持是一个很好的现实例子。请参阅 Feign 指标。</p>
<p>创建一个或多个 Capability bean 并将它们放置在 @FeignClient 配置中，让您可以注册它们并修改相关客户端的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Capability <span class="title">customCapability</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomCapability();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-12-Feign-指标"><a href="#1-12-Feign-指标" class="headerlink" title="1.12. Feign 指标"></a>1.12. Feign 指标</h3><p>如果以下所有条件都为真，则会创建并注册 MicrometerCapability bean，以便您的 Feign 客户端将指标发布到 Micrometer：</p>
<ul>
<li><code>feign-micrometer</code> 在classpath上</li>
<li>A <code>MeterRegistry</code> bean可用</li>
<li>feign 指标属性设置为 true（默认情况下）<ul>
<li><code>feign.metrics.enabled=true</code> (作用所有客户端)</li>
<li><code>feign.client.config.feignName.metrics.enabled=true</code> (作用单个客户端)</li>
</ul>
</li>
</ul>
<p>如果您的应用程序已经使用 Micrometer，那么启用指标就像将 feign-micrometer 放到您的类路径中一样简单。</p>
<p>您还可以通过以下任一方式禁用该功能：</p>
<ul>
<li>从您的类路径中排除 feign-micrometer</li>
<li>将 feign 指标属性之一设置为 false<ul>
<li><code>feign.metrics.enabled=false</code></li>
<li><code>feign.client.config.feignName.metrics.enabled=false</code></li>
</ul>
</li>
</ul>
<p>feign.metrics.enabled=false 禁用对所有 Feign 客户端的度量支持，而不管客户端级别标志的值：feign.client.config.feignName.metrics.enabled。如果要为每个客户端启用或禁用 merics，请不要设置 feign.metrics.enabled 并使用 feign.client.config.feignName.metrics.enabled。</p>
<p>您还可以通过注册自己的 bean 来自定义 MicrometerCapability：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MicrometerCapability <span class="title">micrometerCapability</span><span class="params">(MeterRegistry meterRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MicrometerCapability(meterRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-13-Feign-QueryMap-支持"><a href="#1-13-Feign-QueryMap-支持" class="headerlink" title="1.13. Feign @QueryMap 支持"></a>1.13. Feign @QueryMap 支持</h3><p>OpenFeign @QueryMap 注释支持将 POJO 用作 GET 参数映射。不幸的是，默认的 OpenFeign QueryMap 注释与 Spring 不兼容，因为它缺少 value 属性。</p>
<p>Spring Cloud OpenFeign 提供了一个等效的 @SpringQueryMap 注解，用于将 POJO 或 Map 参数注解为查询参数映射。</p>
<p>例如：</p>
<p>Params 类定义了参数 param1 和 param2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Params.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Params</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String param1;</span><br><span class="line">    <span class="keyword">private</span> String param2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [Getters and setters omitted for brevity]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下 feign 客户端通过使用 @SpringQueryMap 注解来使用 Params 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(path = &quot;/demo&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">demoEndpoint</span><span class="params">(<span class="meta">@SpringQueryMap</span> Params params)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您需要对生成的查询参数映射进行更多控制，则可以实现自定义 QueryMapEncoder bean。</p>
<h3 id="1-14-HATEOAS-支持"><a href="#1-14-HATEOAS-支持" class="headerlink" title="1.14. HATEOAS 支持"></a>1.14. HATEOAS 支持</h3><p>Spring 提供了一些 API 来创建遵循 HATEOAS 原则、Spring Hateoas 和 Spring Data REST 的 REST 表示。</p>
<p>如果您的项目使用 org.springframework.boot:spring-boot-starter-hateoas starter 或 org.springframework.boot:spring-boot-starter-data-rest starter，则默认启用 Feign HATEOAS 支持。</p>
<p>启用 HATEOAS 支持后，允许 Feign 客户端序列化和反序列化 HATEOAS 表示模型：EntityModel、CollectionModel 和 PagedModel。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(path = &quot;/stores&quot;)</span></span><br><span class="line">    <span class="function">CollectionModel&lt;Store&gt; <span class="title">getStores</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-15-Spring-MatrixVariable-支持"><a href="#1-15-Spring-MatrixVariable-支持" class="headerlink" title="1.15. Spring @MatrixVariable 支持"></a>1.15. Spring @MatrixVariable 支持</h3><p>Spring Cloud OpenFeign 提供对 Spring @MatrixVariable 注解的支持。</p>
<p>如果映射作为方法参数传递，@MatrixVariable 路径段是通过使用 = 连接映射中的键值对来创建的。</p>
<p>如果传递了不同的对象，则@MatrixVariable 批注（如果已定义）中提供的名称或带批注的变量名称使用 = 与提供的方法参数连接。</p>
<p>即使在服务器端，Spring 不要求用户将路径段占位符命名为与matrix variable名称相同的名称，因为它在客户端过于模糊，Spring Cloud OpenFeign 要求您添加一个路径段占位符与@MatrixVariable 注释（如果已定义）中提供的名称或带注释的变量名称匹配的名称。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/objects/links/&#123;matrixVars&#125;&quot;)</span></span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; getObjects(<span class="meta">@MatrixVariable</span> Map&lt;String, List&lt;String&gt;&gt; matrixVars);</span><br></pre></td></tr></table></figure>

<p>请注意，变量名称和路径段占位符都称为 matrixVars。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(path = &quot;/stores&quot;)</span></span><br><span class="line">    <span class="function">CollectionModel&lt;Store&gt; <span class="title">getStores</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-16-Feign-CollectionFormat-支持"><a href="#1-16-Feign-CollectionFormat-支持" class="headerlink" title="1.16. Feign CollectionFormat 支持"></a>1.16. Feign CollectionFormat 支持</h3><p>我们通过提供 @CollectionFormat 注释来支持 feign.CollectionFormat。您可以通过传递所需的 feign.CollectionFormat 作为注释值来注释 Feign 客户端方法。</p>
<p>在以下示例中，使用 CSV 格式而不是默认的 EXPLODED 来处理方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;demo&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">interface</span> <span class="title">PageableFeignClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@CollectionFormat(feign.CollectionFormat.CSV)</span></span><br><span class="line">        <span class="meta">@GetMapping(path = &quot;/page&quot;)</span></span><br><span class="line">        <span class="function">ResponseEntity <span class="title">performRequest</span><span class="params">(Pageable page)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在发送 Pageable 作为查询参数时设置 CSV 格式，以便正确编码。</p>
<p>1.17.Reactive支持</p>
<p>由于 OpenFeign 项目目前不支持响应式客户端，例如 Spring WebClient，Spring Cloud OpenFeign 也不支持。我们将在核心项目中尽快添加对它的支持。</p>
<p>在完成之前，我们建议使用 feign-reactive 来支持 Spring WebClient。</p>
<h4 id="1-17-1-早期初始化错误"><a href="#1-17-1-早期初始化错误" class="headerlink" title="1.17.1.早期初始化错误"></a>1.17.1.早期初始化错误</h4><p>根据您使用 Feign 客户端的方式，您可能会在启动应用程序时看到初始化错误。要解决此问题，您可以在自动装配客户端时使用 ObjectProvider。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectProvider&lt;TestFeginClient&gt; testFeginClient;</span><br></pre></td></tr></table></figure>

<h3 id="1-18-Spring-Data支持"><a href="#1-18-Spring-Data支持" class="headerlink" title="1.18.Spring Data支持"></a>1.18.Spring Data支持</h3><p>您可以考虑启用 Jackson Modules 以支持 org.springframework.data.domain.Page 和 org.springframework.data.domain.Sort 解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">feign.autoconfiguration.jackson.enabled=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h3 id="1-19-Spring-RefreshScope-支持"><a href="#1-19-Spring-RefreshScope-支持" class="headerlink" title="1.19. Spring @RefreshScope 支持"></a>1.19. Spring @RefreshScope 支持</h3><p>如果启用了 Feign 客户端刷新，则使用 feign.Request.Options 作为刷新范围的 bean 创建每个 feign 客户端。这意味着可以通过 POST /actuator/refresh 针对任何 Feign 客户端实例刷新诸如 connectTimeout 和 readTimeout 之类的属性。</p>
<p>默认情况下，Feign 客户端中的刷新行为是禁用的。使用以下属性启用刷新行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">feign.client.refresh-enabled=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>不要用@RefreshScope 注释来注释@FeignClient 接口。</p>
<h2 id="2、配置属性"><a href="#2、配置属性" class="headerlink" title="2、配置属性"></a>2、配置属性</h2><p>可以在 application.properties 文件、application.yml 文件或命令行开关中指定各种属性。本附录提供了常见 Spring Cloud OpenFeign 属性的列表以及对使用它们的底层类的引用。</p>
<p>属性贡献可以来自类路径上的其他 jar 文件，因此您不应认为这是一个详尽的列表。此外，您可以定义自己的属性。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">feign.autoconfiguration.jackson.enabled</td>
<td align="left"><code>false</code></td>
<td align="left">如果为 true，将为 Jackson 页面解码提供 PageJacksonModule 和 SortJacksonModule bean。</td>
</tr>
<tr>
<td align="left">feign.circuitbreaker.enabled</td>
<td align="left"><code>false</code></td>
<td align="left">如果为 true，则 OpenFeign 客户端将使用 Spring Cloud CircuitBreaker 断路器包装。</td>
</tr>
<tr>
<td align="left">feign.circuitbreaker.group.enabled</td>
<td align="left"><code>false</code></td>
<td align="left">如果为 true，则 OpenFeign 客户端将使用带有组的 Spring Cloud CircuitBreaker 断路器包装。</td>
</tr>
<tr>
<td align="left">feign.client.config</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.client.decode-slash</td>
<td align="left"><code>true</code></td>
<td align="left">Feign 客户端默认不编码斜杠/字符。要更改此行为，请将 decodeSlash 设置为 false。</td>
</tr>
<tr>
<td align="left">feign.client.default-config</td>
<td align="left"><code>default</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.client.default-to-properties</td>
<td align="left"><code>true</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.client.refresh-enabled</td>
<td align="left"><code>false</code></td>
<td align="left">为 Feign 启用选项值刷新功能。</td>
</tr>
<tr>
<td align="left">feign.compression.request.enabled</td>
<td align="left"><code>false</code></td>
<td align="left">使 Feign 发送的请求能够被压缩。</td>
</tr>
<tr>
<td align="left">feign.compression.request.mime-types</td>
<td align="left"><code>[text/xml, application/xml, application/json]</code></td>
<td align="left">支持的 MIME 类型列表。</td>
</tr>
<tr>
<td align="left">feign.compression.request.min-request-size</td>
<td align="left"><code>2048</code></td>
<td align="left">最小阈值内容大小。</td>
</tr>
<tr>
<td align="left">feign.compression.response.enabled</td>
<td align="left"><code>false</code></td>
<td align="left">使来自 Feign 的响应能够被压缩。</td>
</tr>
<tr>
<td align="left">feign.compression.response.useGzipDecoder</td>
<td align="left"><code>false</code></td>
<td align="left">启用要使用的默认 gzip 解码器。</td>
</tr>
<tr>
<td align="left">feign.encoder.charset-from-content-type</td>
<td align="left"><code>false</code></td>
<td align="left">指示字符集是否应从 {@code Content-Type} 标头派生。</td>
</tr>
<tr>
<td align="left">feign.httpclient.connection-timeout</td>
<td align="left"><code>2000</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.httpclient.connection-timer-repeat</td>
<td align="left"><code>3000</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.httpclient.disable-ssl-validation</td>
<td align="left"><code>false</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.httpclient.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">允许 Feign 使用 Apache HTTP 客户端。</td>
</tr>
<tr>
<td align="left">feign.httpclient.follow-redirects</td>
<td align="left"><code>true</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.httpclient.hc5.enabled</td>
<td align="left"><code>false</code></td>
<td align="left">允许 Feign 使用 Apache HTTP Client 5。</td>
</tr>
<tr>
<td align="left">feign.httpclient.hc5.pool-concurrency-policy</td>
<td align="left"></td>
<td align="left">池并发策略。</td>
</tr>
<tr>
<td align="left">feign.httpclient.hc5.pool-reuse-policy</td>
<td align="left"></td>
<td align="left">池连接重用策略。</td>
</tr>
<tr>
<td align="left">feign.httpclient.hc5.socket-timeout</td>
<td align="left"><code>5</code></td>
<td align="left">Socket超时的默认值。</td>
</tr>
<tr>
<td align="left">feign.httpclient.hc5.socket-timeout-unit</td>
<td align="left"></td>
<td align="left">Socket超时单位的默认值。</td>
</tr>
<tr>
<td align="left">feign.httpclient.max-connections</td>
<td align="left"><code>200</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.httpclient.max-connections-per-route</td>
<td align="left"><code>50</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.httpclient.time-to-live</td>
<td align="left"><code>900</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.httpclient.time-to-live-unit</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">feign.metrics.enabled</td>
<td align="left"><code>true</code></td>
<td align="left">为 Feign 启用指标功能。</td>
</tr>
<tr>
<td align="left">feign.okhttp.enabled</td>
<td align="left"><code>false</code></td>
<td align="left">允许 Feign 使用 OK HTTP Client。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Feign</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>STOMP协议</title>
    <url>/2021/11/09/STOMP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="STOMP协议"><a href="#STOMP协议" class="headerlink" title="STOMP协议"></a>STOMP协议</h1><h1 id="STOMP-协议规范，版本-1-2"><a href="#STOMP-协议规范，版本-1-2" class="headerlink" title="STOMP 协议规范，版本 1.2"></a>STOMP 协议规范，版本 1.2</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>STOMP 源于需要从 Ruby、Python 和 Perl 等脚本语言连接到企业消息代理。在这样的环境中，通常执行逻辑上简单的操作，例如“可靠地发送单个消息并断开连接”或“使用给定目的地上的所有消息”。</p>
<p>它是其他开放消息传递协议（如 AMQP）和 JMS 代理（如 OpenWire）中使用的特定于实现的线路协议的替代方案。它通过覆盖一小部分常用消息传递操作而不是提供全面的消息传递 API 来区分自己。</p>
<p>最近，STOMP 已经成熟为一种协议，该协议可以在其现在提供的线级功能方面超越这些简单的用例，但仍保持其简单性和互操作性的核心设计原则。</p>
<h3 id="协议概述"><a href="#协议概述" class="headerlink" title="协议概述"></a>协议概述</h3><p>STOMP 是一种基于帧的协议，其帧以 HTTP 为模型。一个帧由一个命令、一组可选标题和一个可选正文组成。 STOMP 是基于文本的，但也允许传输二进制消息。 STOMP 的默认编码是 UTF-8，但它支持消息正文的替代编码规范。</p>
<p>STOMP 服务器被建模为一组可以发送消息的目的地。 STOMP 协议将目的地视为不透明字符串，它们的语法是特定于服务器实现的。此外，STOMP 没有定义目的地的交付语义应该是什么。目的地的传递或“消息交换”语义可能因服务器而异，甚至因目的地而异。这允许服务器在他们可以用 STOMP 支持的语义上进行创造性的工作。</p>
<p>STOMP 客户端是一个用户代理，可以在两种（可能同时）模式下运行：</p>
<ul>
<li>作为生产者，通过 SEND 帧将消息发送到服务器上的目的地</li>
<li>作为消费者，为给定的目的地发送一个订阅帧，并从服务器接收消息作为 MESSAGE 帧。</li>
</ul>
<h3 id="协议的变化"><a href="#协议的变化" class="headerlink" title="协议的变化"></a>协议的变化</h3><p>STOMP 1.2 主要向后兼容 STOMP 1.1。只有两个不兼容的更改：</p>
<ul>
<li>现在可以使用回车加换行而不是仅换行来结束帧行</li>
<li>消息确认已被简化，现在使用专用标头</li>
</ul>
<p>除此之外，STOMP 1.2 没有引入任何新特性，而是着重于阐明规范的一些领域，例如：</p>
<ul>
<li>重复的帧头条目</li>
<li>使用 content-length 和 content-type 标头</li>
<li>需要服务器支持 STOMP 框架</li>
<li>持续连接</li>
<li>订阅和transaction标识符的范围和唯一性</li>
<li>RECEIPT 帧相对于先前帧的意义</li>
</ul>
<h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><p>推动 STOMP 设计的主要理念是简单性和互操作性。</p>
<p>STOMP 被设计为一种轻量级协议，易于在客户端和服务器端以多种语言实现。这尤其意味着，对服务器架构的约束并不多，而且许多特性（例如目标命名和可靠性语义）是特定于实现的。</p>
<p>在本规范中，我们将注意 STOMP 1.2 未明确定义的服务器功能。您应该查阅 STOMP 服务器的文档以了解这些功能的实现特定细节。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>本文档中的关键词“MUST”、“MUST NOT”、“REQUIRED”、“SHALL”、“SHALL NOT”、“SHOULD”、“SHOULD NOT”、“RECOMMENDED”、“MAY”和“OPTIONAL”是按照 RFC 2119 中的描述进行解释。</p>
<p>实现可能会对不受约束的输入施加特定于实现的限制，例如以防止拒绝服务攻击、防止内存不足或解决特定于平台的限制。</p>
<p>本规范定义的一致性类是 STOMP 客户端和 STOMP 服务器。</p>
<h2 id="STOMP帧"><a href="#STOMP帧" class="headerlink" title="STOMP帧"></a>STOMP帧</h2><p>STOMP 是一种基于帧的协议，它在下面假定了一个可靠的 2-way 流网络协议（例如 TCP）。客户端和服务器将使用通过流发送的 STOMP 帧进行通信。框架的结构如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COMMAND</span><br><span class="line">header1:value1</span><br><span class="line">header2:value2</span><br><span class="line"></span><br><span class="line">Body^</span><br></pre></td></tr></table></figure>

<p>该帧以一个以行尾 (EOL) 结尾的命令字符串开始，它由一个可选的回车（octet 13）和一个必需的换行符（octet 10）组成。命令后面是 <key>:<value> 格式的零个或多个标头条目。每个报头条目都由一个 EOL 终止。空行（即额外的 EOL）表示标题的结尾和正文的开头。正文之后是 NULL 八位字节。本文档中的示例将使用 ASCII 中的 ^@、control-@ 来表示 NULL 八位字节。 NULL 八位字节可以有选择地跟随多个 EOL。有关如何解析 STOMP 帧的更多详细信息，请参阅本文档的Augmented BNF 部分。</p>
<p>本文档中引用的所有命令和标题名称均区分大小写。</p>
<h3 id="值编码"><a href="#值编码" class="headerlink" title="值编码"></a>值编码</h3><p>命令和标头以 UTF-8 编码。除 CONNECT 和 CONNECTED 帧之外的所有帧也将转义在生成的 UTF-8 编码标头中找到的任何回车、换行或冒号。</p>
<p>需要转义以允许标题键和值包含那些作为值分隔八位字节的帧标题。 CONNECT 和 CONNECTED 帧不会转义回车、换行或冒号八位字节，以保持与 STOMP 1.0 的向后兼容。</p>
<p>C 样式字符串文字转义用于对在 UTF-8 编码标头中找到的任何回车、换行或冒号进行编码。解码帧头时，必须应用以下转换：</p>
<ul>
<li><code>\r</code> (octet 92 and 114) 翻译成回车 (octet 13)</li>
<li><code>\n</code> (octet 92 and 110) 转换为换行 (octet 10)</li>
<li><code>\c</code> (octet 92 and 99) 翻译成 <code>:</code> (octet 58)</li>
<li><code>\\</code> (octet 92 and 92) 翻译成 <code>\</code> (octet 92)</li>
</ul>
<p>未定义的转义序列如 \t（octet 92 and 116）必须被视为致命的协议错误。相反，在编码帧头时，必须应用逆向转换。</p>
<p>STOMP 1.0 规范包括许多在标头中填充的示例帧，并且实现了许多服务器和客户端来修剪或填充标头值。如果应用程序想要发送不应被修剪的标头，这会导致问题。在 STOMP 1.2 中，客户端和服务器绝不能用空格修剪或填充标头。</p>
<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>只有 SEND、MESSAGE 和 ERROR 帧可能有正文。所有其他帧不得有主体。</p>
<h3 id="标准头"><a href="#标准头" class="headerlink" title="标准头"></a>标准头</h3><p>对于大多数帧，可以使用某些标题并且具有特殊含义。</p>
<h4 id="Header-content-length"><a href="#Header-content-length" class="headerlink" title="Header content-length"></a>Header content-length</h4><p>所有的帧都可以包含一个内容长度的头部。此标头是消息正文长度的八位字节计数。如果包含内容长度标头，则必须读取此八位字节数，无论正文中是否存在 NULL 八位字节。该帧仍需要以 NULL 八位字节结束。</p>
<p>如果存在帧体，则 SEND、MESSAGE 和 ERROR 帧应该包含内容长度标头以简化帧解析。如果帧体包含 NULL 八位字节，则帧必须包含内容长度头。</p>
<h4 id="Header-content-type"><a href="#Header-content-type" class="headerlink" title="Header content-type"></a>Header content-type</h4><p>如果存在帧体，则 SEND、MESSAGE 和 ERROR 帧应该包含一个内容类型的头，以帮助帧的接收者解释其体。如果设置了 content-type 标头，它的值必须是描述正文格式的 MIME 类型。否则，接收者应该将主体视为二进制 blob。</p>
<p>以 text/ 开头的 MIME 类型的隐含文本编码是 UTF-8。如果您使用具有不同编码的基于文本的 MIME 类型，那么您应该将 ;charset=<encoding> 附加到 MIME 类型。例如，如果您以 UTF-16 编码发送 HTML 正文，则应使用 text/html;charset=utf-16 。 ;charset=<encoding> 也应该附加到任何可以解释为文本的非文本/ MIME 类型。一个很好的例子是 UTF-8 编码的 XML。它的内容类型应该设置为 application/xml;charset=utf-8</p>
<p>所有 STOMP 客户端和服务器必须支持 UTF-8 编码和解码。因此，为了在异构计算环境中实现最大的互操作性，建议使用 UTF-8 对基于文本的内容进行编码。</p>
<h4 id="Header-receipt"><a href="#Header-receipt" class="headerlink" title="Header receipt"></a>Header receipt</h4><p>除了 CONNECT 之外的任何客户端框架都可以指定具有任意值的接收标头。这将导致服务器使用 RECEIPT 帧确认客户端帧的处理（有关更多详细信息，请参阅 RECEIPT 帧）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:/queue/a</span><br><span class="line">receipt:message-<span class="number">12345</span></span><br><span class="line"></span><br><span class="line">hello queue a^@</span><br></pre></td></tr></table></figure>

<h3 id="重复的头条目"><a href="#重复的头条目" class="headerlink" title="重复的头条目"></a>重复的头条目</h3><p>由于消息系统可以按照存储和转发拓扑进行组织，类似于 SMTP，因此消息在到达消费者之前可能会遍历多个消息服务器。 STOMP 服务器可以通过在消息中添加标头或在消息中就地修改标头来“更新”标头值。</p>
<p>如果客户端或服务器收到重复的帧头条目，则只有第一个头条目应该用作头条目的值。后续值仅用于维护标头状态更改的历史记录，可以忽略。</p>
<p>例如，如果客户端收到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MESSAGE</span><br><span class="line">foo:World</span><br><span class="line">foo:Hello</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>foo 头的值就是 World。</p>
<h3 id="大小限制"><a href="#大小限制" class="headerlink" title="大小限制"></a>大小限制</h3><p>为了防止恶意客户端利用服务器中的内存分配，服务器可以设置最大限制：</p>
<ul>
<li>单个帧中允许的帧头数</li>
<li>Header行的最大长度</li>
<li>帧体的最大尺寸</li>
</ul>
<p>如果超过这些限制，服务器应该向客户端发送一个 ERROR 帧，然后关闭连接。</p>
<h3 id="连接延迟"><a href="#连接延迟" class="headerlink" title="连接延迟"></a>连接延迟</h3><p>STOMP 服务器必须能够支持快速连接和断开连接的客户端。</p>
<p>这意味着服务器可能只允许关闭的连接在连接重置之前短暂停留。</p>
<p>因此，在套接字重置之前，客户端可能不会收到服务器发送的最后一帧（例如，错误帧或响应断开帧的接收帧）。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>STOMP 客户端通过发送 CONNECT 帧来启动与服务器的流或 TCP 连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONNECT</span><br><span class="line">accept-version:<span class="number">1.2</span></span><br><span class="line">host:stomp.github.org</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>如果服务器接受连接尝试，它将以 CONNECTED 帧响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONNECTED</span><br><span class="line">version:<span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>服务器可以拒绝任何连接尝试。服务器应该用一个 ERROR 帧来响应，解释连接被拒绝的原因，然后关闭连接。</p>
<h3 id="CONNECT或STOMP帧"><a href="#CONNECT或STOMP帧" class="headerlink" title="CONNECT或STOMP帧"></a>CONNECT或STOMP帧</h3><p>STOMP 服务器必须以与 CONNECT 帧相同的方式处理 STOMP 帧。 STOMP 1.2 客户端应该继续使用 CONNECT 命令来保持与 STOMP 1.0 服务器的向后兼容。</p>
<p>使用 STOMP 帧而不是 CONNECT 帧的客户端将只能连接到 STOMP 1.2 服务器（以及一些 STOMP 1.1 服务器），但优点是协议嗅探器/鉴别器将能够将 STOMP 连接与HTTP 连接。</p>
<p>STOMP 1.2 客户端必须设置以下标头：</p>
<ul>
<li><code>accept-version</code> : 客户端支持的 STOMP 协议版本。有关更多详细信息，请参阅协议协商</li>
<li><code>host</code> : 客户端希望连接的虚拟主机的名称。建议客户端将其设置为建立套接字所针对的主机名，或他们选择的任何名称。如果此标头与已知虚拟主机不匹配，则支持虚拟主机的服务器可以选择默认虚拟主机或拒绝连接。</li>
</ul>
<p>STOMP 1.2 客户端可以设置以下标头：</p>
<ul>
<li><code>login</code> : 用于针对安全 STOMP 服务器进行身份验证的用户标识符。</li>
<li><code>passcode</code> : 用于对安全 STOMP 服务器进行身份验证的密码。</li>
<li><code>heart-beat</code> : 心跳设置。</li>
</ul>
<h3 id="连接帧"><a href="#连接帧" class="headerlink" title="连接帧"></a>连接帧</h3><p>STOMP 1.2 服务器必须设置以下标头：</p>
<ul>
<li><code>version</code> : 会话将使用的 STOMP 协议的版本。有关更多详细信息，请参阅协议协商。</li>
</ul>
<p>STOMP 1.2 服务器可以设置以下标头：</p>
<ul>
<li><p><code>heart-beat</code> : 心跳设置。</p>
</li>
<li><p><code>session</code> : 唯一标识会话的会话标识符。</p>
</li>
<li><p><code>server</code> : 包含有关 STOMP 服务器的信息的字段。该字段必须包含一个服务器名称字段，并且可以跟随着由空格八位字节分隔的可选注释字段。</p>
<p>server-name 字段由一个名称标记和一个可选的版本号标记组成。</p>
<p><code>server = name [&quot;/&quot; version] *(comment)</code></p>
<p>例子:</p>
<p><code>server:Apache/1.3.9</code></p>
</li>
</ul>
<h3 id="协议交互"><a href="#协议交互" class="headerlink" title="协议交互"></a>协议交互</h3><p>从 STOMP 1.1 开始，CONNECT 帧必须包含 accept-version 标头。它应该设置为客户端支持的递增 STOMP 协议版本的逗号分隔列表。如果缺少accept-version 头，则表示客户端仅支持1.0 版协议。</p>
<p>将用于会话其余部分的协议将是客户端和服务器共有的最高协议版本。</p>
<p>例如，如果客户端发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONNECT</span><br><span class="line">accept-version:<span class="number">1.0</span>,<span class="number">1.1</span>,<span class="number">2.0</span></span><br><span class="line">host:stomp.github.org</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>服务器将使用与客户端相同的协议的最高版本进行响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONNECTED</span><br><span class="line">version:<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>如果客户端和服务器不共享任何公共协议版本，则服务器必须以类似于以下的 ERROR 帧响应，然后关闭连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ERROR</span><br><span class="line">version:<span class="number">1.2</span>,<span class="number">2.1</span></span><br><span class="line">content-type:text/plain</span><br><span class="line"></span><br><span class="line">Supported protocol versions are <span class="number">1.2</span> <span class="number">2.1</span>^@</span><br></pre></td></tr></table></figure>

<h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>可以选择使用心跳来测试底层 TCP 连接的健康状况，并确保远程端处于活动状态并正常运行。</p>
<p>为了启用心跳，每一方都必须声明它可以做什么以及希望另一方做什么。这发生在 STOMP 会话的最开始时，通过向 CONNECT 和 CONNECTED 帧添加心跳标头。</p>
<p>使用时，心跳头必须包含两个用逗号分隔的正整数。</p>
<p>第一个数字代表帧的发送者可以做什么（传出心跳）：</p>
<ul>
<li><p>0 表示不能发送心跳</p>
</li>
<li><p>否则它是它可以保证的心跳之间的最小毫秒数 第二个数字代表帧的发送者想要得到什么（传入的心跳）：</p>
<ul>
<li><p>0 表示它不想接收心跳</p>
</li>
<li><p>否则它是心跳之间所需的毫秒数</p>
</li>
</ul>
</li>
</ul>
<p>心跳报头是可选的。丢失的心跳报头必须以与“heart-beat:0,0”报头相同的方式处理，即：一方不能发送也不想接收心跳。</p>
<p>心跳报头提供了足够的信息，以便每一方都可以查明是否可以使用心跳、在哪个方向以及以哪个频率使用。</p>
<p>更正式地说，初始帧如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONNECT</span><br><span class="line">heart-beat:&lt;cx&gt;,&lt;cy&gt;</span><br><span class="line"></span><br><span class="line">CONNECTED</span><br><span class="line">heart-beat:&lt;sx&gt;,&lt;sy&gt;</span><br></pre></td></tr></table></figure>

<p>对于从客户端到服务器的心跳：</p>
<ul>
<li>如果 <cx> 为 0（客户端无法发送心跳）或 <sy> 为 0（服务器不想接收心跳），则不会有</li>
<li>否则，每 MAX(<cx>,<sy>) 毫秒就会有一次心跳</li>
</ul>
<p>在另一个方向上，<sx> 和 <cy> 的用法相同。</p>
<p>关于心跳本身，通过网络连接接收到的任何新数据都表明远程端处于活动状态。在给定的方向上，如果每 <n> 毫秒需要一次心跳：</p>
<ul>
<li>发送方必须至少每 <n> 毫秒通过网络连接发送新数据</li>
<li>如果发送方没有真正的 STOMP 帧要发送，它必须发送一个行尾（EOL）</li>
<li>如果在至少 <n> 毫秒的时间窗口内，接收器没有收到任何新数据，它可以认为连接已死</li>
<li>由于时序不准确，接收器应该容忍并考虑误差容限</li>
</ul>
<h2 id="客户端帧"><a href="#客户端帧" class="headerlink" title="客户端帧"></a>客户端帧</h2><p>客户端可以发送不在这个列表中的帧，但是对于这样的帧，STOMP 1.2 服务器可以响应一个 ERROR 帧，然后关闭连接。</p>
<ul>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#SEND"><code>SEND</code></a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#SUBSCRIBE"><code>SUBSCRIBE</code></a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#UNSUBSCRIBE"><code>UNSUBSCRIBE</code></a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#BEGIN"><code>BEGIN</code></a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#COMMIT"><code>COMMIT</code></a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#ABORT"><code>ABORT</code></a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#ACK"><code>ACK</code></a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#NACK"><code>NACK</code></a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#DISCONNECT"><code>DISCONNECT</code></a></li>
</ul>
<h3 id="SEND"><a href="#SEND" class="headerlink" title="SEND"></a>SEND</h3><p>SEND 帧将消息发送到消息系统中的目的地。它有一个 REQUIRED 标头，即目的地，指示将消息发送到何处。 SEND 帧的主体是要发送的消息。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:/queue/a</span><br><span class="line">content-type:text/plain</span><br><span class="line"></span><br><span class="line">hello queue a</span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>这会向名为 /queue/a 的目的地发送一条消息。请注意，STOMP 将此目的地视为不透明字符串，并且目的地名称不假定传递语义。您应该查阅 STOMP 服务器的文档以了解如何构造一个目标名称，该名称为您提供应用程序所需的传递语义。</p>
<p>消息的可靠性语义也是特定于服务器的，将取决于正在使用的目标值和其他消息头，例如事务头或其他服务器特定的消息头。</p>
<p>SEND 支持允许事务发送的事务标头。</p>
<p>如果正文存在，SEND 帧应该包括一个<a href="https://stomp.github.io/stomp-specification-1.2.html#Header_content-length"><code>content-length</code></a> 标头和一个<a href="https://stomp.github.io/stomp-specification-1.2.html#Header_content-type"><code>content-type</code></a> 标头。</p>
<p>应用程序可以向 SEND 帧添加任意用户定义的标头。用户定义的标头通常用于允许消费者使用订阅帧上的选择器根据应用程序定义的标头过滤消息。用户定义的头必须在 MESSAGE 帧中传递。</p>
<p>如果服务器由于任何原因无法成功处理 SEND 帧，则服务器必须向客户端发送一个 ERROR 帧，然后关闭连接。</p>
<h3 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h3><p>SUBSCRIBE 帧用于注册以侦听给定的目的地。与 SEND 帧一样，SUBSCRIBE 帧需要一个目的地标头，指示客户端想要订阅的目的地。在订阅目标上收到的任何消息将作为 MESSAGE 帧从服务器传递到客户端。 ack 头控制消息确认模式。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE</span><br><span class="line">id:<span class="number">0</span></span><br><span class="line">destination:/queue/foo</span><br><span class="line">ack:client</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>如果服务器无法成功创建订阅，则服务器必须向客户端发送一个 ERROR 帧，然后关闭连接。</p>
<p>STOMP 服务器可以支持额外的特定于服务器的标头来定制订阅的交付语义。有关详细信息，请参阅服务器的文档。</p>
<h4 id="SUBSCRIBE-id-Header"><a href="#SUBSCRIBE-id-Header" class="headerlink" title="SUBSCRIBE id Header"></a>SUBSCRIBE id Header</h4><p>由于单个连接可以与服务器有多个开放订阅，因此帧中必须包含一个 id 标头以唯一标识订阅。 id 头允许客户端和服务器将后续的 MESSAGE 或 UNSUBSCRIBE 帧与原始订阅相关联。</p>
<p>在同一个连接中，不同的订阅必须使用不同的订阅标识符。</p>
<h4 id="SUBSCRIBE-ack-Header"><a href="#SUBSCRIBE-ack-Header" class="headerlink" title="SUBSCRIBE ack Header"></a>SUBSCRIBE ack Header</h4><p>ack 标头的有效值为 auto、client 或 client-individual。如果未设置标头，则默认为自动。</p>
<p>当 ack 模式为 auto 时，客户端不需要为它收到的消息发送服务器 ACK 帧。服务器将在将消息发送给客户端后立即假定客户端已收到该消息。这种确认模式可能会导致传输到客户端的消息被丢弃。</p>
<p>当 ack 模式为客户端时，客户端必须为它处理的消息发送服务器 ACK 帧。如果在客户端发送消息的 ACK 帧之前连接失败，服务器将假定消息尚未处理，并可以将消息重新传递给另一个客户端。客户端发送的 ACK 帧将被视为累积确认。这意味着确认对 ACK 帧中指定的消息以及在 ACK 消息之前发送到订阅的所有消息进行操作。</p>
<p>如果客户端没有处理一些消息，它应该发送 NACK 帧来告诉服务器它没有使用这些消息。</p>
<p>当 ack 模式为 client-individual 时，除了客户端发送的 ACK 或 NACK 帧不累积之外，确认的操作与客户端确认模式相同。这意味着后续消息的 ACK 或 NACK 帧不得导致先前消息得到确认。</p>
<h3 id="UNSUBSCRIBE"><a href="#UNSUBSCRIBE" class="headerlink" title="UNSUBSCRIBE"></a>UNSUBSCRIBE</h3><p>UNSUBSCRIBE 帧用于删除现有订阅。一旦订阅被删除，STOMP 连接将不再接收来自该订阅的消息。</p>
<p>由于单个连接可以与服务器有多个开放订阅，因此帧中必须包含一个 id 标头以唯一标识要删除的订阅。此标头必须与现有订阅的订阅标识符匹配。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UNSUBSCRIBE</span><br><span class="line">id:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<h3 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h3><p>ACK 用于使用客户端或客户端个人确认来确认来自订阅的消息的消耗。在通过 ACK 确认消息之前，不会认为从此类订阅接收到的任何消息已被消费。</p>
<p>ACK 帧必须包含一个与被确认的 MESSAGE 的 ack 头匹配的 id 头。可选地，可以指定一个事务头，表明消息确认应该是命名事务的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ACK</span><br><span class="line">id:<span class="number">12345</span></span><br><span class="line">transaction:tx1</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<h3 id="NACK"><a href="#NACK" class="headerlink" title="NACK"></a>NACK</h3><p>NACK 是 ACK 的反义词。它用于告诉服务器客户端没有消费该消息。然后，服务器可以将消息发送到不同的客户端、丢弃它或将其放入死信队列。确切的行为是特定于服务器的。</p>
<p>NACK 采用与 ACK 相同的标头：id（必需）和交易（可选）。</p>
<p>NACK 应用于单个消息（如果订阅的 ack 模式是客户端个人）或应用于之前发送但尚未确认或 NACK 的所有消息（如果订阅的确认模式是客户端）。</p>
<h3 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h3><p>BEGIN 用于启动事务。这种情况下的交易适用于发送和确认 - 在交易期间发送或确认的任何消息都将根据交易进行原子处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">transaction:tx1</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>事务标头是必需的，事务标识符将用于 SEND、COMMIT、ABORT、ACK 和 NACK 帧以将它们绑定到命名事务。在同一个连接中，不同的事务必须使用不同的事务标识符。</p>
<p>如果客户端发送 DISCONNECT 帧或 TCP 连接因任何原因失败，则任何尚未提交的已启动事务都将隐式中止。</p>
<h3 id="COMMIT"><a href="#COMMIT" class="headerlink" title="COMMIT"></a>COMMIT</h3><p>COMMIT 用于提交正在进行的事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COMMIT</span><br><span class="line">transaction:tx1</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>事务头是必需的，并且必须指定要提交的事务的标识符。</p>
<h3 id="ABORT"><a href="#ABORT" class="headerlink" title="ABORT"></a>ABORT</h3><p>ABORT 用于回滚正在进行的事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ABORT</span><br><span class="line">transaction:tx1</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>事务头是必需的，并且必须指定要中止的事务的标识符。</p>
<h3 id="DISCONNECT"><a href="#DISCONNECT" class="headerlink" title="DISCONNECT"></a>DISCONNECT</h3><p>客户端可以随时通过关闭套接字与服务器断开连接，但不能保证先前发送的帧已被服务器接收。要进行正常关闭，客户端确保服务器已收到所有先前的帧，客户端应该：</p>
<ol>
<li><p>发送带有接收标头集的 DISCONNECT 帧。例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DISCONNECT</span><br><span class="line">receipt:77</span><br><span class="line">^@</span><br></pre></td></tr></table></figure></li>
<li><p>等待 RECEIPT 帧对 DISCONNECT 的响应。例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECEIPT</span><br><span class="line">receipt-id:77</span><br><span class="line">^@</span><br></pre></td></tr></table></figure></li>
<li><p>关闭套接字。</p>
</li>
</ol>
<p>请注意，如果服务器过快地关闭套接字的末尾，客户端可能永远不会收到预期的 RECEIPT 帧。有关更多信息，请参阅连接延迟部分。</p>
<p>发送 DISCONNECT 帧后，客户端不得再发送任何帧。</p>
<h2 id="服务端帧"><a href="#服务端帧" class="headerlink" title="服务端帧"></a>服务端帧</h2><p>服务器有时会向客户端发送帧（除了初始的 CONNECTED 帧）。这些帧可能是以下之一：</p>
<ul>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#MESSAGE"><code>MESSAGE</code></a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#RECEIPT"><code>RECEIPT</code></a></li>
<li><a href="https://stomp.github.io/stomp-specification-1.2.html#ERROR"><code>ERROR</code></a></li>
</ul>
<h3 id="MESSAGE"><a href="#MESSAGE" class="headerlink" title="MESSAGE"></a>MESSAGE</h3><p>MESSAGE 帧用于将消息从订阅传送到客户端。</p>
<p>MESSAGE 帧必须包含一个目的地标头，指示消息被发送到的目的地。如果消息是使用 STOMP 发送的，则此目标标头应该与相应 SEND 帧中使用的标头相同。</p>
<p>MESSAGE 帧还必须包含一个 message-id 标头，该标头具有该消息的唯一标识符和一个与接收消息的订阅标识符匹配的订阅标头。</p>
<p>如果从需要显式确认的订阅接收消息（客户端或客户端个人模式），则 MESSAGE 帧还必须包含具有任意值的 ack 标头。该报头将用于将消息与后续 ACK 或 NACK 帧相关联。</p>
<p>帧体包含消息的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MESSAGE</span><br><span class="line">subscription:<span class="number">0</span></span><br><span class="line">message-id:<span class="number">007</span></span><br><span class="line">destination:/queue/a</span><br><span class="line">content-type:text/plain</span><br><span class="line"></span><br><span class="line">hello queue a^@</span><br></pre></td></tr></table></figure>

<p>如果正文存在，MESSAGE 帧应该包括一个<a href="https://stomp.github.io/stomp-specification-1.2.html#Header_content-length"><code>content-length</code></a>标头和一个<a href="https://stomp.github.io/stomp-specification-1.2.html#Header_content-type"><code>content-type</code></a>标头。</p>
<p>MESSAGE 帧还将包括所有用户定义的头，这些头在消息发送到目的地时出现，除了可能被添加到帧中的服务器特定头。查阅您的服务器的文档以找出它添加到消息中的特定于服务器的标头。</p>
<h3 id="RECEIPT"><a href="#RECEIPT" class="headerlink" title="RECEIPT"></a>RECEIPT</h3><p>一旦服务器成功处理了请求接收的客户端帧，就会从服务器向客户端发送一个 RECEIPT 帧。一个 RECEIPT 帧必须包含首部receipt-id，其中的值是作为接收的帧中的接收首部的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RECEIPT</span><br><span class="line">receipt-id:message-<span class="number">12345</span></span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>RECEIPT 帧是对相应客户端帧已被服务器处理的确认。由于 STOMP 是基于流的，因此接收也是服务器已接收到所有先前帧的累积确认。然而，这些先前的帧可能还没有被完全处理。如果客户端断开连接，先前收到的帧应该继续由服务器处理。</p>
<h3 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h3><p>如果出现问题，服务器可能会发送 ERROR 帧。在这种情况下，它必须在发送 ERROR 帧后立即关闭连接。请参阅有关连接延迟的下一节。</p>
<p>ERROR 帧应该包含一个带有错误简短描述的消息头，并且主体可以包含更详细的信息（或者可以为空）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ERROR</span><br><span class="line">receipt-id:message-<span class="number">12345</span></span><br><span class="line">content-type:text/plain</span><br><span class="line">content-length:<span class="number">170</span></span><br><span class="line">message:malformed frame received</span><br><span class="line"></span><br><span class="line">The message:</span><br><span class="line">-----</span><br><span class="line">MESSAGE</span><br><span class="line">destined:/queue/a</span><br><span class="line">receipt:message-<span class="number">12345</span></span><br><span class="line"></span><br><span class="line">Hello queue a!</span><br><span class="line">-----</span><br><span class="line">Did not contain a destination header, which is REQUIRED</span><br><span class="line"><span class="keyword">for</span> message propagation.</span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>如果错误与客户端发送的特定帧有关，则服务器应该添加额外的标头以帮助识别导致错误的原始帧。例如，如果帧包含接收头，则错误帧应该设置接收标识头以匹配与错误相关的帧的接收头的值。</p>
<p>如果正文存在，则错误帧应该包括内容长度标头和内容类型标头。</p>
<h2 id="Frames-and-Headers"><a href="#Frames-and-Headers" class="headerlink" title="Frames and Headers"></a>Frames and Headers</h2><p>除了上面描述的标准头（内容长度、内容类型和接收）之外，这里是本规范中定义的每个帧必须或可以使用的所有头：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONNECT` or `STOMP</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: <code>accept-version</code>, <code>host</code></li>
<li>OPTIONAL: <code>login</code>, <code>passcode</code>, <code>heart-beat</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONNECTED</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: <code>version</code></li>
<li>OPTIONAL: <code>session</code>, <code>server</code>, <code>heart-beat</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SEND</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: <code>destination</code></li>
<li>OPTIONAL: <code>transaction</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: <code>destination</code>, <code>id</code></li>
<li>OPTIONAL: <code>ack</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UNSUBSCRIBE</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: <code>id</code></li>
<li>OPTIONAL: none</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ACK` or `NACK</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: <code>id</code></li>
<li>OPTIONAL: <code>transaction</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BEGIN` or `COMMIT` or `ABORT</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: <code>transaction</code></li>
<li>OPTIONAL: none</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DISCONNECT</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: none</li>
<li>OPTIONAL: <code>receipt</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MESSAGE</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: <code>destination</code>, <code>message-id</code>, <code>subscription</code></li>
<li>OPTIONAL: <code>ack</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RECEIPT</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: <code>receipt-id</code></li>
<li>OPTIONAL: none</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ERROR</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED: none</li>
<li>OPTIONAL: <code>message</code></li>
</ul>
<p>此外，SEND 和 MESSAGE 帧可以包含任意用户定义的头部，这些头部应该被认为是承载消息的一部分。此外，ERROR 帧应该包括额外的头以帮助识别导致错误的原始帧。</p>
<p>最后，STOMP 服务器可以使用额外的标头来访问诸如持久性或过期等功能。有关详细信息，请参阅服务器的文档。</p>
<h2 id="Augmented-BNF"><a href="#Augmented-BNF" class="headerlink" title="Augmented BNF"></a>Augmented BNF</h2><p>可以使用 HTTP/1.1 RFC 2616 中使用的 Backus-Naur Form (BNF) 语法更正式地描述 STOMP 会话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NULL                = &lt;US-<span class="function">ASCII <span class="title">null</span> <span class="params">(octet <span class="number">0</span>)</span>&gt;</span></span><br><span class="line"><span class="function">LF                  </span>= &lt;US-<span class="function">ASCII line <span class="title">feed</span> <span class="params">(aka newline)</span> <span class="params">(octet <span class="number">10</span>)</span>&gt;</span></span><br><span class="line"><span class="function">CR                  </span>= &lt;US-<span class="function">ASCII carriage <span class="title">return</span> <span class="params">(octet <span class="number">13</span>)</span>&gt;</span></span><br><span class="line"><span class="function">EOL                 </span>= [CR] LF </span><br><span class="line">OCTET               = &lt;any <span class="number">8</span>-bit sequence of data&gt;</span><br><span class="line"></span><br><span class="line">frame-stream        = <span class="number">1</span>*frame</span><br><span class="line"></span><br><span class="line">frame               = command EOL</span><br><span class="line">                      *( header EOL )</span><br><span class="line">                      EOL</span><br><span class="line">                      *OCTET</span><br><span class="line">                      NULL</span><br><span class="line">                      *( EOL )</span><br><span class="line"></span><br><span class="line">command             = client-command | server-command</span><br><span class="line"></span><br><span class="line">client-command      = <span class="string">&quot;SEND&quot;</span></span><br><span class="line">                      | <span class="string">&quot;SUBSCRIBE&quot;</span></span><br><span class="line">                      | <span class="string">&quot;UNSUBSCRIBE&quot;</span></span><br><span class="line">                      | <span class="string">&quot;BEGIN&quot;</span></span><br><span class="line">                      | <span class="string">&quot;COMMIT&quot;</span></span><br><span class="line">                      | <span class="string">&quot;ABORT&quot;</span></span><br><span class="line">                      | <span class="string">&quot;ACK&quot;</span></span><br><span class="line">                      | <span class="string">&quot;NACK&quot;</span></span><br><span class="line">                      | <span class="string">&quot;DISCONNECT&quot;</span></span><br><span class="line">                      | <span class="string">&quot;CONNECT&quot;</span></span><br><span class="line">                      | <span class="string">&quot;STOMP&quot;</span></span><br><span class="line"></span><br><span class="line">server-command      = <span class="string">&quot;CONNECTED&quot;</span></span><br><span class="line">                      | <span class="string">&quot;MESSAGE&quot;</span></span><br><span class="line">                      | <span class="string">&quot;RECEIPT&quot;</span></span><br><span class="line">                      | <span class="string">&quot;ERROR&quot;</span></span><br><span class="line"></span><br><span class="line">header              = header-name <span class="string">&quot;:&quot;</span> header-value</span><br><span class="line">header-name         = <span class="number">1</span>*&lt;any OCTET except CR or LF or <span class="string">&quot;:&quot;</span>&gt;</span><br><span class="line">header-value        = *&lt;any OCTET except CR or LF or <span class="string">&quot;:&quot;</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络协议</category>
        <category>STOMP</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>STOMP</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket基本使用</title>
    <url>/2021/11/09/WebSocket%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="WebSocket基本使用"><a href="#WebSocket基本使用" class="headerlink" title="WebSocket基本使用"></a>WebSocket基本使用</h1><h2 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h2><p>文档涵盖了对 Servlet 堆栈的支持、包含原始 WebSocket 交互的 WebSocket 消息传递、通过 SockJS 的 WebSocket 模拟以及通过作为 WebSocket 子协议的 STOMP 的发布订阅消息传递。</p>
<h3 id="WebSocket-简介"><a href="#WebSocket-简介" class="headerlink" title="WebSocket 简介"></a>WebSocket 简介</h3><p>WebSocket 协议 RFC 6455 提供了一种标准化方法，可通过单个 TCP 连接在客户端和服务器之间建立全双工、双向通信通道。它是与 HTTP 不同的 TCP 协议，但旨在通过 HTTP 工作，使用端口 80 和 443，并允许重新使用现有的防火墙规则。</p>
<p>WebSocket 交互以 HTTP 请求开始，该请求使用 HTTP Upgrade header进行升级，或者在本例中切换到 WebSocket 协议。以下示例显示了这样的交互：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">GET</span> <span class="string">/spring-websocket-portfolio/portfolio</span> <span class="string">HTTP/1.1</span></span><br><span class="line"><span class="attr">Host:</span> <span class="string">localhost:8080</span></span><br><span class="line"><span class="attr">Upgrade:</span> <span class="string">websocket</span> </span><br><span class="line"><span class="attr">Connection:</span> <span class="string">Upgrade</span> </span><br><span class="line"><span class="attr">Sec-WebSocket-Key:</span> <span class="string">Uc9l9TMkWGbHFD2qnFHltg==</span></span><br><span class="line"><span class="attr">Sec-WebSocket-Protocol:</span> <span class="string">v10.stomp,</span> <span class="string">v11.stomp</span></span><br><span class="line"><span class="attr">Sec-WebSocket-Version:</span> <span class="number">13</span></span><br><span class="line"><span class="attr">Origin:</span> <span class="string">http://localhost:8080</span></span><br></pre></td></tr></table></figure>

<p>与通常的 200 状态代码不同，具有 WebSocket 支持的服务器返回类似于以下内容的输出：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">HTTP/1.1</span> <span class="number">101</span> <span class="string">Switching</span> <span class="string">Protocols</span> </span><br><span class="line"><span class="attr">Upgrade:</span> <span class="string">websocket</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">Upgrade</span></span><br><span class="line"><span class="attr">Sec-WebSocket-Accept:</span> <span class="string">1qVdfYHU9hPOl4JYYNXF623Gzn0=</span></span><br><span class="line"><span class="attr">Sec-WebSocket-Protocol:</span> <span class="string">v10.stomp</span></span><br></pre></td></tr></table></figure>

<p>成功握手后，HTTP 升级请求底层的 TCP 套接字保持打开状态，客户端和服务器都可以继续发送和接收消息。</p>
<p>对 WebSockets 工作原理的完整介绍超出了本文档的范围。请参阅 RFC 6455、HTML5 的 WebSocket 章节或 Web 上的许多介绍和教程中的任何一个。</p>
<p>请注意，如果 WebSocket 服务器在 Web 服务器（例如 nginx）后面运行，您可能需要将其配置为将 WebSocket 升级请求传递到 WebSocket 服务器。同样，如果应用程序在云环境中运行，请查看与 WebSocket 支持相关的云提供商的说明。</p>
<h4 id="HTTP-与-WebSocket"><a href="#HTTP-与-WebSocket" class="headerlink" title="HTTP 与 WebSocket"></a>HTTP 与 WebSocket</h4><p>尽管 WebSocket 被设计为与 HTTP 兼容并从 HTTP 请求开始，但重要的是要了解这两种协议会导致非常不同的架构和应用程序编程模型。</p>
<p>在 HTTP 和 REST 中，一个应用程序被建模为多个 URL。为了与应用程序交互，客户端访问这些 URL，请求-响应样式。服务器根据 HTTP URL、方法和标头将请求路由到适当的处理程序。</p>
<p>相比之下，在 WebSockets 中，通常只有一个 URL 用于初始连接。随后，所有应用程序消息都在同一个 TCP 连接上流动。这指向一个完全不同的异步、事件驱动、消息传递架构。</p>
<p>WebSocket 也是一种低级传输协议，与 HTTP 不同，它不对消息内容规定任何语义。这意味着除非客户端和服务器就消息语义达成一致，否则无法路由或处理消息。</p>
<p>WebSocket 客户端和服务器可以通过 HTTP 握手请求上的 Sec-WebSocket-Protocol 标头协商使用更高级别的消息传递协议（例如，STOMP）。如果没有，他们需要提出自己的约定。</p>
<h4 id="何时使用-WebSocket"><a href="#何时使用-WebSocket" class="headerlink" title="何时使用 WebSocket"></a>何时使用 WebSocket</h4><p>WebSockets 可以使网页具有动态性和交互性。但是，在许多情况下，Ajax 和 HTTP 流或长轮询的组合可以提供简单有效的解决方案。</p>
<p>例如，新闻、邮件和社交提要需要动态更新，但每隔几分钟更新一次可能完全没问题。另一方面，协作、游戏和金融应用程序需要更接近实时。</p>
<p>延迟本身并不是决定性因素。如果消息量相对较低（例如监控网络故障），HTTP 流或轮询可以提供有效的解决方案。低延迟、高频率和高容量的组合是使用 WebSocket 的最佳案例。</p>
<p>还请记住，在 Internet 上，不受您控制的限制性代理可能会阻止 WebSocket 交互，因为它们未配置为传递 Upgrade 标头，或者因为它们关闭了看似空闲的长期连接。这意味着将 WebSocket 用于防火墙内的内部应用程序是一个比面向公众的应用程序更直接的决定。</p>
<h3 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h3><p>Spring Framework 提供了一个 WebSocket API，您可以使用它来编写处理 WebSocket 消息的客户端和服务器端应用程序。</p>
<h4 id="WebSocketHandler"><a href="#WebSocketHandler" class="headerlink" title="WebSocketHandler"></a>WebSocketHandler</h4><p>创建 WebSocket 服务器就像实现 WebSocketHandler 一样简单，或者更有可能扩展 TextWebSocketHandler 或 BinaryWebSocketHandler。以下示例使用 TextWebSocketHandler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有专用的 WebSocket Java 配置和 XML 命名空间支持，用于将前面的 WebSocket 处理程序映射到特定 URL，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(myHandler(), <span class="string">&quot;/myHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">myHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了与前面示例等效的 XML 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">&quot;http://www.springframework.org/schema/websocket&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/websocket/spring-websocket.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/myHandler&quot;</span> <span class="attr">handler</span>=<span class="string">&quot;myHandler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.MyHandler&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前面的示例用于 Spring MVC 应用程序，应包含在 DispatcherServlet 的配置中。但是，Spring 的 WebSocket 支持不依赖于 Spring MVC。在 WebSocketHttpRequestHandler 的帮助下，将 WebSocketHandler 集成到其他 HTTP 服务环境中相对简单。</p>
<p>直接与间接使用 WebSocketHandler API 时，例如通过 STOMP 消息传递，应用程序必须同步消息的发送，因为底层标准 WebSocket 会话 (JSR-356) 不允许并发发送。一种选择是使用 ConcurrentWebSocketSessionDecorator 包装 WebSocketSession。</p>
<h4 id="WebSocket-握手"><a href="#WebSocket-握手" class="headerlink" title="WebSocket 握手"></a>WebSocket 握手</h4><p>自定义初始 HTTP WebSocket 握手请求的最简单方法是通过 HandshakeInterceptor，它公开握手“之前”和“之后”的方法。您可以使用此类拦截器来阻止握手或使任何属性可用于 WebSocketSession。以下示例使用内置拦截器将 HTTP 会话属性传递给 WebSocket 会话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(<span class="keyword">new</span> MyHandler(), <span class="string">&quot;/myHandler&quot;</span>)</span><br><span class="line">            .addInterceptors(<span class="keyword">new</span> HttpSessionHandshakeInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了与前面示例等效的 XML 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">&quot;http://www.springframework.org/schema/websocket&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/websocket/spring-websocket.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/myHandler&quot;</span> <span class="attr">handler</span>=<span class="string">&quot;myHandler&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:handshake-interceptors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">websocket:handshake-interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.MyHandler&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个更高级的选项是扩展 DefaultHandshakeHandler，它执行 WebSocket 握手的步骤，包括验证客户端来源、协商子协议和其他细节。如果应用程序需要配置自定义 RequestUpgradeStrategy 以适应尚不支持的 WebSocket 服务器引擎和版本，则它也可能需要使用此选项（有关此主题的更多信息，请参阅部署）。 Java 配置和 XML 命名空间都可以配置自定义 HandshakeHandler。</p>
<p>Spring 提供了一个 WebSocketHandlerDecorator 基类，您可以使用它来装饰具有附加行为的 WebSocketHandler。使用 WebSocket Java 配置或 XML 命名空间时，默认提供并添加日志记录和异常处理实现。 ExceptionWebSocketHandlerDecorator 捕获任何 WebSocketHandler 方法产生的所有未捕获的异常，并关闭状态为 1011 的 WebSocket 会话，这表示服务器错误。</p>
<h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><p>Spring WebSocket API 很容易集成到 Spring MVC 应用程序中，其中 DispatcherServlet 为 HTTP WebSocket 握手和其他 HTTP 请求提供服务。通过调用 WebSocketHttpRequestHandler 也很容易集成到其他 HTTP 处理场景中。这很方便，也很容易理解。但是，对于 JSR-356 运行时需要特殊考虑。</p>
<p>Java WebSocket API (JSR-356) 提供了两种部署机制。第一个涉及启动时的 Servlet 容器类路径扫描（Servlet 3 特性）。另一个是在 Servlet 容器初始化时使用的注册 API。这两种机制都无法使用单个“前端控制器”进行所有 HTTP 处理 — 包括 WebSocket 握手和所有其他 HTTP 请求 — ，例如 Spring MVC 的 DispatcherServlet。</p>
<p>这是 JSR-356 的一个重大限制，即使在 JSR-356 运行时中运行时，Spring 的 WebSocket 支持也可以解决特定于服务器的 RequestUpgradeStrategy 实现。 Tomcat、Jetty、GlassFish、WebLogic、WebSphere 和 Undertow（以及 WildFly）目前存在此类策略。</p>
<p>已经创建了克服 Java WebSocket API 中上述限制的请求，可以在 eclipse-ee4j/websocket-api#211 中遵循该请求。 Tomcat、Undertow 和 WebSphere 提供了它们自己的 API 替代方案，可以做到这一点，Jetty 也可以做到。我们希望更多的服务器能做同样的事情。</p>
<p>第二个考虑因素是，支持 JSR-356 的 Servlet 容器预计会执行 ServletContainerInitializer (SCI) 扫描，这会减慢应用程序启动速度 — 在某些情况下会显着降低。如果在升级到支持 JSR-356 的 Servlet 容器版本后观察到显着影响，应该可以通过使用 web 中的 <absolute-ordering /> 元素有选择地启用或禁用 web 片段（和 SCI 扫描） .xml，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">absolute-ordering</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，您可以按名称有选择地启用 Web 片段，例如 Spring 自己的 SpringServletContainerInitializer，它提供对 Servlet 3 Java 初始化 API 的支持。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">absolute-ordering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring_web<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">absolute-ordering</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h4><p>每个底层 WebSocket 引擎都公开控制运行时特性的配置属性，例如消息缓冲区大小、空闲超时等。</p>
<p>对于 Tomcat、WildFly 和 GlassFish，您可以将 ServletServerContainerFactoryBean 添加到您的 WebSocket Java 配置中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletServerContainerFactoryBean <span class="title">createWebSocketContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletServerContainerFactoryBean container = <span class="keyword">new</span> ServletServerContainerFactoryBean();</span><br><span class="line">        container.setMaxTextMessageBufferSize(<span class="number">8192</span>);</span><br><span class="line">        container.setMaxBinaryMessageBufferSize(<span class="number">8192</span>);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了与前面示例等效的 XML 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">&quot;http://www.springframework.org/schema/websocket&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/websocket/spring-websocket.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework...ServletServerContainerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTextMessageBufferSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;8192&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxBinaryMessageBufferSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;8192&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于客户端 WebSocket 配置，您应该使用 WebSocketContainerFactoryBean (XML) 或 ContainerProvider.getWebSocketContainer()（Java 配置）。</p>
<p>对于 Jetty，您需要提供一个预配置的 Jetty WebSocketServerFactory 并通过 WebSocket Java 配置将其插入 Spring 的 DefaultHandshakeHandler。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(echoWebSocketHandler(),</span><br><span class="line">            <span class="string">&quot;/echo&quot;</span>).setHandshakeHandler(handshakeHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultHandshakeHandler <span class="title">handshakeHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        WebSocketPolicy policy = <span class="keyword">new</span> WebSocketPolicy(WebSocketBehavior.SERVER);</span><br><span class="line">        policy.setInputBufferSize(<span class="number">8192</span>);</span><br><span class="line">        policy.setIdleTimeout(<span class="number">600000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultHandshakeHandler(</span><br><span class="line">                <span class="keyword">new</span> JettyRequestUpgradeStrategy(<span class="keyword">new</span> WebSocketServerFactory(policy)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了与前面示例等效的 XML 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">&quot;http://www.springframework.org/schema/websocket&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/websocket/spring-websocket.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/echo&quot;</span> <span class="attr">handler</span>=<span class="string">&quot;echoHandler&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:handshake-handler</span> <span class="attr">ref</span>=<span class="string">&quot;handshakeHandler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;handshakeHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework...DefaultHandshakeHandler&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;upgradeStrategy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;upgradeStrategy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework...JettyRequestUpgradeStrategy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;serverFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serverFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.eclipse.jetty...WebSocketServerFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.eclipse.jetty...WebSocketPolicy&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;SERVER&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;inputBufferSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;8092&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;idleTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;600000&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Allowed-Origins"><a href="#Allowed-Origins" class="headerlink" title="Allowed Origins"></a>Allowed Origins</h4><p>从 Spring Framework 4.1.5 开始，WebSocket 和 SockJS 的默认行为是仅接受同源请求。还可以允许所有或指定的来源列表。此检查主要是为浏览器客户端设计的。没有什么可以阻止其他类型的客户端修改 Origin 标头值（有关更多详细信息，请参阅 RFC 6454：Web Origin 概念）。</p>
<p>三种可能的行为是：</p>
<ul>
<li>仅允许同源请求（默认）：在这种模式下，当启用 SockJS 时，Iframe HTTP 响应头 X-Frame-Options 设置为 SAMEORIGIN，并且禁用 JSONP 传输，因为它不允许检查源要求。因此，启用此模式时不支持 IE6 和 IE7。</li>
<li>允许指定的来源列表：每个允许的来源必须以 http:// 或 https:// 开头。在这种模式下，当 SockJS 启用时，IFrame 传输被禁用。因此，启用此模式时，不支持 IE6 到 IE9。</li>
<li>允许所有来源：要启用此模式，您应该提供 * 作为允许的来源值。在这种模式下，所有传输都可用。</li>
</ul>
<p>您可以配置 WebSocket 和 SockJS 允许的来源，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(myHandler(), <span class="string">&quot;/myHandler&quot;</span>).setAllowedOrigins(<span class="string">&quot;https://mydomain.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">myHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了与前面示例等效的 XML 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">&quot;http://www.springframework.org/schema/websocket&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/websocket/spring-websocket.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span> <span class="attr">allowed-origins</span>=<span class="string">&quot;https://mydomain.com&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/myHandler&quot;</span> <span class="attr">handler</span>=<span class="string">&quot;myHandler&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.MyHandler&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="SockJS-Fallback"><a href="#SockJS-Fallback" class="headerlink" title="SockJS Fallback"></a>SockJS Fallback</h3><p>在公共 Internet 上，不受您控制的限制性代理可能会阻止 WebSocket 交互，因为它们未配置为传递 Upgrade 标头，或者因为它们关闭了看似空闲的长期连接。</p>
<p>该问题的解决方案是 WebSocket 模拟 — 即尝试首先使用 WebSocket，然后再使用基于 HTTP 的技术来模拟 WebSocket 交互并公开相同的应用程序级 API。</p>
<p>在 Servlet 堆栈上，Spring Framework 为 SockJS 协议提供服务器（和客户端）支持。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>SockJS 的目标是让应用程序使用 WebSocket API，但在运行时必要时回退到非 WebSocket 替代方案，而无需更改应用程序代码。</p>
<p>SockJS 包括：</p>
<ul>
<li>以可执行叙述测试的形式定义的 SockJS 协议。</li>
<li>SockJS JavaScript 客户端 — 用于浏览器的客户端库。</li>
<li>SockJS 服务器实现，包括 Spring Framework spring websocket 模块中的一个。</li>
<li>spring-websocket 模块中的 SockJS Java 客户端（自 4.1 版起）。</li>
</ul>
<p>SockJS 是为在浏览器中使用而设计的。它使用多种技术来支持广泛的浏览器版本。有关 SockJS 传输类型和浏览器的完整列表，请参阅 SockJS 客户端页面。传输分为三大类：WebSocket、HTTP 流和 HTTP 长轮询。</p>
<p>SockJS 客户端首先发送 GET /info 以从服务器获取基本信息。之后，它必须决定使用什么传输。如果可能，使用 WebSocket。如果没有，在大多数浏览器中，至少有一个 HTTP 流选项。如果不是，则使用 HTTP（长）轮询。</p>
<p>所有传输请求都具有以下 URL 结构：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://host:port/myApp/myEndpoint/&#123;server-id&#125;/&#123;session-id&#125;/&#123;transport&#125;</span><br></pre></td></tr></table></figure>

<p>在哪里：</p>
<ul>
<li><code>&#123;server-id&#125;</code> 用于在集群中路由请求，但不用于其他用途。</li>
<li><code>&#123;session-id&#125;</code> 关联属于 SockJS 会话的 HTTP 请求。</li>
<li><code>&#123;transport&#125;</code> 表示传输类型（例如，websocket、xhr-streaming 等）。</li>
</ul>
<p>WebSocket 传输只需要一个 HTTP 请求来进行 WebSocket 握手。此后的所有消息都在该socket上交换。</p>
<p>HTTP 传输需要更多请求。例如，Ajax/XHR 流依赖于对服务器到客户端消息的一个长时间运行的请求和对客户端到服务器消息的附加 HTTP POST 请求。长轮询类似，不同之处在于它在每次服务器到客户端发送后结束当前请求。</p>
<p>SockJS 添加了最少的消息框架。例如，服务器最初发送字母 o（“打开”帧），消息作为 [“message1”,”message2”]（JSON 编码数组）发送，如果没有消息，则发送字母 h（“心跳”帧）流 25 秒（默认情况下），并使用字母 c（“关闭”帧）关闭会话。</p>
<p>要了解更多信息，请在浏览器中运行示例并观察 HTTP 请求。 SockJS 客户端允许修复传输列表，因此可以一次查看每个传输一个。 SockJS 客户端还提供了一个调试标志，它可以在浏览器控制台中启用有用的消息。在服务器端，您可以为 org.springframework.web.socket 启用 TRACE 日志记录。有关更多详细信息，请参阅 SockJS 协议叙述测试。</p>
<h4 id="启用-SockJS"><a href="#启用-SockJS" class="headerlink" title="启用 SockJS"></a>启用 SockJS</h4><p>您可以通过 Java 配置启用 SockJS，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(myHandler(), <span class="string">&quot;/myHandler&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">myHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了与前面示例等效的 XML 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">&quot;http://www.springframework.org/schema/websocket&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/websocket/spring-websocket.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/myHandler&quot;</span> <span class="attr">handler</span>=<span class="string">&quot;myHandler&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:sockjs</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.MyHandler&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前面的示例用于 Spring MVC 应用程序，应包含在 DispatcherServlet 的配置中。但是，Spring 的 WebSocket 和 SockJS 支持不依赖于 Spring MVC。借助 SockJsHttpRequestHandler 集成到其他 HTTP 服务环境中相对简单。</p>
<p>在浏览器端，应用程序可以使用 sockjs-client（版本 1.0.x）。它模拟 W3C WebSocket API 并与服务器通信以选择最佳传输选项，具体取决于它运行的浏览器。请参阅 sockjs-client 页面和浏览器支持的传输类型列表。客户端还提供了几个配置选项 — ，例如，指定要包含哪些传输。</p>
<h4 id="IE-8-and-9"><a href="#IE-8-and-9" class="headerlink" title="IE 8 and 9"></a>IE 8 and 9</h4><p>Internet Explorer 8 和 9 仍在使用中。它们是拥有 SockJS 的一个关键原因。本节涵盖有关在这些浏览器中运行的重要注意事项。</p>
<p>SockJS 客户端通过使用 Microsoft 的 XDomainRequest 在 IE 8 和 9 中支持 Ajax/XHR 流。这适用于跨域，但不支持发送 cookie。 Cookie 对于 Java 应用程序通常是必不可少的。但是，由于 SockJS 客户端可以与许多服务器类型（不仅仅是 Java 类型）一起使用，因此它需要知道 cookie 是否重要。如果是这样，SockJS 客户端更喜欢使用 Ajax/XHR 进行流式处理。否则，它依赖于基于 iframe 的技术。</p>
<p>来自 SockJS 客户端的第一个 /info 请求是对可能影响客户端传输选择的信息的请求。这些细节之一是服务器应用程序是否依赖 cookie（例如，出于身份验证目的或使用粘性会话进行集群）。 Spring 的 SockJS 支持包括一个名为 sessionCookieNeeded 的属性。它默认启用，因为大多数 Java 应用程序依赖于 JSESSIONID cookie。如果您的应用程序不需要它，您可以关闭此选项，然后 SockJS 客户端应该在 IE 8 和 9 中选择 xdr-streaming。</p>
<p>如果您确实使用基于 iframe 的传输，请记住，可以通过将 HTTP 响应标头 X-Frame-Options 设置为 DENY、SAMEORIGIN 或 ALLOW-FROM &lt;origin 来指示浏览器阻止在给定页面上使用 IFrame &gt;.这用于防止点击劫持。</p>
<p>Spring Security 3.2+ 支持在每个响应上设置 X-Frame-Options。默认情况下，Spring Security Java 配置将其设置为 DENY。在 3.2 中，Spring Security XML 命名空间默认情况下不会设置该标头，但可以配置为这样做。将来，它可能会默认设置。</p>
<p>有关如何配置 X-Frame-Options 标头设置的详细信息，请参阅 Spring Security 文档的默认安全标头。您还可以查看 SEC-2501 以了解更多背景信息。</p>
<p>如果您的应用程序添加了 X-Frame-Options 响应标头（它应该如此！）并依赖于基于 iframe 的传输，则您需要将标头值设置为 SAMEORIGIN 或 ALLOW-FROM <origin>。 Spring SockJS 支持还需要知道 SockJS 客户端的位置，因为它是从 iframe 加载的。默认情况下，iframe 设置为从 CDN 位置下载 SockJS 客户端。将此选项配置为使用与应用程序同源的 URL 是个好主意。</p>
<p>以下示例显示了如何在 Java 配置中执行此操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/portfolio&quot;</span>).withSockJS()</span><br><span class="line">                .setClientLibraryUrl(<span class="string">&quot;http://localhost:8080/myapp/js/sockjs-client.js&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML 命名空间通过 <a href="websocket:sockjs">websocket:sockjs</a> 元素提供了类似的选项。</p>
<p>在初始开发期间，请启用 SockJS 客户端开发模式，以防止浏览器缓存原本会被缓存的 SockJS 请求（如 iframe）。有关如何启用它的详细信息，请参阅 SockJS 客户端页面。</p>
<h4 id="Heartbeats"><a href="#Heartbeats" class="headerlink" title="Heartbeats"></a>Heartbeats</h4><p>SockJS 协议要求服务器发送心跳消息以防止代理得出连接挂起的结论。 Spring SockJS 配置有一个名为 heartbeatTime 的属性，您可以使用它来自定义频率。默认情况下，心跳在 25 秒后发送，假设该连接上没有发送其他消息。这个 25 秒的值符合以下 IETF 对公共 Internet 应用程序的建议。</p>
<p>在 WebSocket 和 SockJS 上使用 STOMP 时，如果 STOMP 客户端和服务器协商要交换的心跳，则禁用 SockJS 心跳。</p>
<p>Spring SockJS 支持还允许您配置 TaskScheduler 以安排心跳任务。任务调度程序由线程池支持，默认设置基于可用处理器的数量。您应该考虑根据您的特定需求自定义设置。</p>
<h4 id="客户端断开连接"><a href="#客户端断开连接" class="headerlink" title="客户端断开连接"></a>客户端断开连接</h4><p>HTTP 流和 HTTP 长轮询 SockJS 传输要求连接比平时保持打开状态的时间更长。</p>
<p>在 Servlet 容器中，这是通过 Servlet 3 异步支持完成的，该支持允许退出 Servlet 容器线程、处理请求并继续写入来自另一个线程的响应。</p>
<p>一个特定的问题是 Servlet API 不为已消失的客户端提供通知。参见 eclipse-ee4j/servlet-api#44。但是，Servlet 容器在后续尝试写入响应时引发异常。由于 Spring 的 SockJS 服务支持服务器发送的心跳（默认情况下每 25 秒），这意味着通常会在该时间段内检测到客户端断开连接（或更早，如果消息发送更频繁）。</p>
<p>因此，由于客户端断开连接，可能会发生网络 I/O 故障，这可能会用不必要的堆栈跟踪填充日志。 Spring 尽最大努力识别代表客户端断开连接（特定于每个服务器）的此类网络故障，并通过使用专用日志类别 DISCONNECTED_CLIENT_LOG_CATEGORY（在 AbstractSockJsSession 中定义）记录最少的消息。如果您需要查看堆栈跟踪，可以将该日志类别设置为 TRACE。</p>
<h4 id="SockJS-和-CORS"><a href="#SockJS-和-CORS" class="headerlink" title="SockJS 和 CORS"></a>SockJS 和 CORS</h4><p>如果您允许跨域请求（请参阅 Allowed Origins），则 SockJS 协议使用 CORS 在 XHR 流和轮询传输中提供跨域支持。因此，除非检测到响应中存在 CORS 标头，否则会自动添加 CORS 标头。因此，如果应用程序已经配置为提供 CORS 支持（例如，通过 Servlet 过滤器），则 Spring 的 SockJsService 会跳过这部分。</p>
<p>也可以通过设置 Spring 的 SockJsService 中的 suppressCors 属性来禁用这些 CORS 标头的添加。</p>
<p>SockJS 需要以下header和值：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code>: 从 Origin 请求标头的值初始化。</li>
<li><code>Access-Control-Allow-Credentials</code>: 始终设置为真。</li>
<li><code>Access-Control-Request-Headers</code>: 从等效请求标头中的值初始化。</li>
<li><code>Access-Control-Allow-Methods</code>: 传输支持的 HTTP 方法（请参阅 TransportType 枚举）。</li>
<li><code>Access-Control-Max-Age</code>: 设置为 31536000（1 年）。</li>
</ul>
<p>有关确切的实现，请参阅 AbstractSockJsService 中的 addCorsHeaders 和源代码中的 TransportType 枚举。</p>
<p>或者，如果 CORS 配置允许，请考虑使用 SockJS 端点前缀排除 URL，从而让 Spring 的 SockJsService 处理它。</p>
<h4 id="SockJsClient"><a href="#SockJsClient" class="headerlink" title="SockJsClient"></a>SockJsClient</h4><p>Spring 提供了一个 SockJS Java 客户端，无需使用浏览器即可连接到远程 SockJS 端点。当需要在公共网络上的两个服务器之间进行双向通信时（即，网络代理可以阻止使用 WebSocket 协议），这尤其有用。 SockJS Java 客户端对于测试目的也非常有用（例如，模拟大量并发用户）。</p>
<p>SockJS Java 客户端支持 websocket、xhr-streaming 和 xhr-polling 传输。其余的仅在浏览器中使用才有意义。</p>
<p>您可以使用以下命令配置 WebSocketTransport：</p>
<ul>
<li><code>StandardWebSocketClient</code> 在 JSR-356 运行时中。</li>
<li><code>JettyWebSocketClient</code> 通过使用 Jetty 9+ 原生 WebSocket API。</li>
<li>Spring 的 WebSocketClient 的任何实现。</li>
</ul>
<p>根据定义，XhrTransport 支持 xhr-streaming 和 xhr-polling，因为从客户端的角度来看，除了用于连接到服务器的 URL 之外没有其他区别。目前有两种实现方式：</p>
<ul>
<li><code>RestTemplateXhrTransport</code> RestTemplateXhrTransport 使用 Spring 的 RestTemplate 来处理 HTTP 请求。</li>
<li><code>JettyXhrTransport</code> 使用 Jetty 的 HttpClient 进行 HTTP 请求。</li>
</ul>
<p>以下示例显示了如何创建 SockJS 客户端并连接到 SockJS 端点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Transport&gt; transports = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">transports.add(<span class="keyword">new</span> WebSocketTransport(<span class="keyword">new</span> StandardWebSocketClient()));</span><br><span class="line">transports.add(<span class="keyword">new</span> RestTemplateXhrTransport());</span><br><span class="line"></span><br><span class="line">SockJsClient sockJsClient = <span class="keyword">new</span> SockJsClient(transports);</span><br><span class="line">sockJsClient.doHandshake(<span class="keyword">new</span> MyWebSocketHandler(), <span class="string">&quot;ws://example.com:8080/sockjs&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>SockJS 对消息使用 JSON 格式的数组。默认情况下，使用 Jackson 2 并且需要在类路径上。或者，您可以配置 SockJsMessageCodec 的自定义实现并在 SockJsClient 上进行配置。</p>
<p>要使用 SockJsClient 模拟大量并发用户，您需要配置底层 HTTP 客户端（用于 XHR 传输）以允许足够数量的连接和线程。以下示例显示了如何使用 Jetty 执行此操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpClient jettyHttpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">jettyHttpClient.setMaxConnectionsPerDestination(<span class="number">1000</span>);</span><br><span class="line">jettyHttpClient.setExecutor(<span class="keyword">new</span> QueuedThreadPool(<span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>以下示例显示了您还应该考虑自定义的服务器端 SockJS 相关属性（有关详细信息，请参阅 javadoc）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">extends</span> <span class="title">WebSocketMessageBrokerConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/sockjs&quot;</span>).withSockJS()</span><br><span class="line">            .setStreamBytesLimit(<span class="number">512</span> * <span class="number">1024</span>) </span><br><span class="line">            .setHttpMessageCacheSize(<span class="number">1000</span>) </span><br><span class="line">            .setDisconnectDelay(<span class="number">30</span> * <span class="number">1000</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将 streamBytesLimit 属性设置为 512KB（默认为 128KB — 128 * 1024）。</li>
<li>将 httpMessageCacheSize 属性设置为 1,000（默认值为 100）。</li>
<li>将 disconnectDelay 属性设置为 30 属性秒（默认为 5 秒 — 5 * 1000）。</li>
</ul>
<h3 id="STOMP"><a href="#STOMP" class="headerlink" title="STOMP"></a>STOMP</h3><p>WebSocket 协议定义了两种类型的消息（文本和二进制），但它们的内容是未定义的。该协议定义了客户端和服务器协商一个子协议（即更高级别的消息协议）的机制，用于在 WebSocket 之上定义每个可以发送的消息类型，格式是什么，内容是什么。每条消息，等等。子协议的使用是可选的，但无论哪种方式，客户端和服务器都需要就定义消息内容的某些协议达成一致。</p>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>STOMP（面向简单文本的消息传递协议）最初是为脚本语言（例如 Ruby、Python 和 Perl）创建的，用于连接到企业消息代理。它旨在解决常用消息传递模式的最小子集。 STOMP 可用于任何可靠的双向流网络协议，例如 TCP 和 WebSocket。尽管 STOMP 是面向文本的协议，但消息有效负载可以是文本或二进制的。</p>
<p>STOMP 是一种基于帧的协议，其帧以 HTTP 为模型。以下清单显示了 STOMP 帧的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMAND</span><br><span class="line">header1:value1</span><br><span class="line">header2:value2</span><br><span class="line"></span><br><span class="line">Body^@</span><br></pre></td></tr></table></figure>

<p>客户端可以使用 SEND 或 SUBSCRIBE 命令发送或订阅消息，以及描述消息内容和接收者的目标头。这启用了一个简单的发布-订阅机制，您可以使用该机制通过代理将消息发送到其他连接的客户端，或将消息发送到服务器以请求执行某些工作。</p>
<p>当您使用 Spring 的 STOMP 支持时，Spring WebSocket 应用程序充当客户端的 STOMP 代理。消息被路由到@Controller 消息处理方法或一个简单的内存代理，该代理跟踪订阅并向订阅用户广播消息。您还可以将 Spring 配置为与专用的 STOMP 代理（例如 RabbitMQ、ActiveMQ 等）一起工作，以进行实际的消息广播。在这种情况下，Spring 维护与代理的 TCP 连接，将消息中继到它，并将消息从它向下传递到连接的 WebSocket 客户端。因此，Spring Web 应用程序可以依靠统一的基于 HTTP 的安全性、通用验证和熟悉的编程模型来处理消息。</p>
<p>以下示例显示订阅接收股票报价的客户端，服务器可能会定期发出该报价（例如，通过计划任务通过 SimpMessagingTemplate 向代理发送消息）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE</span><br><span class="line">id:sub-1</span><br><span class="line">destination:/topic/price.stock.*</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>以下示例显示了发送交易请求的客户端，服务器可以通过 @MessageMapping 方法处理该请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:/queue/trade</span><br><span class="line">content-type:application/json</span><br><span class="line">content-length:44</span><br><span class="line"></span><br><span class="line">&#123;&quot;action&quot;:&quot;BUY&quot;,&quot;ticker&quot;:&quot;MMM&quot;,&quot;shares&quot;,44&#125;^@</span><br></pre></td></tr></table></figure>

<p>执行后，服务器可以向客户端广播交易确认消息和详细信息。</p>
<p>在 STOMP 规范中，目的地的含义故意不透明。它可以是任何字符串，完全由 STOMP 服务器来定义它们支持的目的地的语义和语法。然而，目的地是类似路径的字符串是很常见的，其中 /topic/.. 意味着发布-订阅（一对多）和 /queue/ 意味着点对点（一对一）消息交流。</p>
<p>STOMP 服务器可以使用 MESSAGE 命令向所有订阅者广播消息。以下示例显示服务器向订阅的客户端发送股票报价：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MESSAGE</span><br><span class="line">message-id:nxahklf6-1</span><br><span class="line">subscription:sub-1</span><br><span class="line">destination:/topic/price.stock.MMM</span><br><span class="line"></span><br><span class="line">&#123;&quot;ticker&quot;:&quot;MMM&quot;,&quot;price&quot;:129.45&#125;^@</span><br></pre></td></tr></table></figure>

<p>服务器不能发送未经请求的消息。来自服务器的所有消息都必须响应特定的客户端订阅，并且服务器消息的 subscription-id 标头必须与客户端订阅的 id 标头匹配。</p>
<p>前面的概述旨在提供对 STOMP 协议最基本的理解。我们建议全面审查协议规范。</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>与使用原始 WebSockets 相比，使用 STOMP 作为子协议可以让 Spring Framework 和 Spring Security 提供更丰富的编程模型。对于 HTTP 与原始 TCP 以及它如何让 Spring MVC 和其他 Web 框架提供丰富的功能，可以提出同样的观点。以下是福利清单：</p>
<ul>
<li>无需发明自定义消息传递协议和消息格式。</li>
<li>可以使用 STOMP 客户端，包括 Spring 框架中的 Java 客户端。</li>
<li>您可以（可选）使用消息代理（例如 RabbitMQ、ActiveMQ 等）来管理订阅和广播消息。</li>
<li>应用程序逻辑可以组织在任意数量的 @Controller 实例中，并且可以根据 STOMP 目标标头将消息路由到它们，而不是使用单个 WebSocketHandler 处理给定连接的原始 WebSocket 消息。</li>
<li>您可以使用 Spring Security 根据 STOMP 目标和消息类型来保护消息。</li>
</ul>
<h4 id="启用-STOMP"><a href="#启用-STOMP" class="headerlink" title="启用 STOMP"></a>启用 STOMP</h4><p>STOMP over WebSocket 支持在 spring-messaging 和 spring-websocket 模块中可用。一旦有了这些依赖项，就可以通过 WebSocket 和 SockJS Fallback 公开 STOMP 端点，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.StompEndpointRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/portfolio&quot;</span>).withSockJS();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry config)</span> </span>&#123;</span><br><span class="line">        config.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>); </span><br><span class="line">        config.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>/portfolio 是 WebSocket（或 SockJS）到的端点的 HTTP URL 客户端需要连接以进行 WebSocket 握手。</li>
<li>目标标头以 /app 开头的 STOMP 消息被路由到 @Controller 类中的 @MessageMapping 方法。</li>
<li>使用内置的消息代理进行订阅和广播以及 将目标标头以 /topic <code>或</code>/queue 开头的消息路由到代理。</li>
</ul>
<p>以下示例显示了与前面示例等效的 XML 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">&quot;http://www.springframework.org/schema/websocket&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/websocket/spring-websocket.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:message-broker</span> <span class="attr">application-destination-prefix</span>=<span class="string">&quot;/app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:stomp-endpoint</span> <span class="attr">path</span>=<span class="string">&quot;/portfolio&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">websocket:sockjs</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">websocket:stomp-endpoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:simple-broker</span> <span class="attr">prefix</span>=<span class="string">&quot;/topic, /queue&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:message-broker</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于内置的简单代理，/topic 和 /queue 前缀没有任何特殊含义。它们只是一种区分发布-订阅与点对点消息传递（即许多订阅者与一个消费者）的约定。当您使用外部代理时，请查看代理的 STOMP 页面以了解其支持的 STOMP 目的地和前缀类型。</p>
<p>要从浏览器连接，对于 SockJS，您可以使用 sockjs-client。对于 STOMP，许多应用程序使用了 jmesnil/stomp-websocket 库（也称为 stomp.js），该库功能完备，已在生产中使用多年但不再维护。目前，JSteunou/webstomp-client 是该库最积极维护和发展的继承者。以下示例代码基于它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS(<span class="string">&quot;/spring-websocket-portfolio/portfolio&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> stompClient = webstomp.over(socket);</span><br><span class="line"></span><br><span class="line">stompClient.connect(&#123;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">frame</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，如果您通过 WebSocket（不带 SockJS）连接，则可以使用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;/spring-websocket-portfolio/portfolio&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> stompClient = Stomp.over(socket);</span><br><span class="line"></span><br><span class="line">stompClient.connect(&#123;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">frame</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，前面示例中的 stompClient 不需要指定登录和密码标头。即使这样做了，它们也会在服务器端被忽略（或者更确切地说，被覆盖）。有关身份验证的更多信息，请参阅连接到代理和身份验证。</p>
<h4 id="WebSocket服务"><a href="#WebSocket服务" class="headerlink" title="WebSocket服务"></a>WebSocket服务</h4><p>要配置底层 WebSocket 服务器，服务器配置中的信息适用。但是，对于 Jetty，您需要通过 StompEndpointRegistry 设置 HandshakeHandler 和 WebSocketPolicy：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/portfolio&quot;</span>).setHandshakeHandler(handshakeHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultHandshakeHandler <span class="title">handshakeHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        WebSocketPolicy policy = <span class="keyword">new</span> WebSocketPolicy(WebSocketBehavior.SERVER);</span><br><span class="line">        policy.setInputBufferSize(<span class="number">8192</span>);</span><br><span class="line">        policy.setIdleTimeout(<span class="number">600000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultHandshakeHandler(</span><br><span class="line">                <span class="keyword">new</span> JettyRequestUpgradeStrategy(<span class="keyword">new</span> WebSocketServerFactory(policy)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息流"><a href="#消息流" class="headerlink" title="消息流"></a>消息流</h4><p>一旦暴露了 STOMP 端点，Spring 应用程序就成为连接客户端的 STOMP 代理。本节介绍服务器端的消息流向。</p>
<p>spring-messaging 模块包含对源自 Spring Integration 的消息传递应用程序的基础支持，后来被提取并合并到 Spring 框架中，以便在许多 Spring 项目和应用程序场景中更广泛地使用。以下列表简要描述了一些可用的消息传递抽象：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.12/javadoc-api/org/springframework/messaging/Message.html">Message</a>: 消息的简单表示，包括标头和有效负载。</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.12/javadoc-api/org/springframework/messaging/MessageHandler.html">MessageHandler</a>: 处理消息的合同。</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.12/javadoc-api/org/springframework/messaging/MessageChannel.html">MessageChannel</a>: 用于发送消息的合同，可以在生产者和消费者之间实现松散耦合。</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.12/javadoc-api/org/springframework/messaging/SubscribableChannel.html">SubscribableChannel</a>: 带有 MessageHandler 订阅者的 MessageChannel。</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.12/javadoc-api/org/springframework/messaging/support/ExecutorSubscribableChannel.html">ExecutorSubscribableChannel</a>: 使用 Executor 传递消息的 SubscribableChannel。</li>
</ul>
<p>Java 配置（即@EnableWebSocketMessageBroker）和XML 命名空间配置（即<a href="websocket:message-broker">websocket:message-broker</a>）都使用前面的组件来组装消息工作流。下图显示了启用简单内置消息代理时使用的组件：</p>
<p><img src="https://docs.spring.io/spring-framework/docs/current/reference/html/images/message-flow-simple-broker.png" alt="message flow simple broker"></p>
<p>上图显示了三个消息通道：</p>
<ul>
<li><code>clientInboundChannel</code>: 用于传递从 WebSocket 客户端接收的消息。</li>
<li><code>clientOutboundChannel</code>: 用于向 WebSocket 客户端发送服务器消息。</li>
<li><code>brokerChannel</code>: 用于从服务器端应用程序代码中向消息代理发送消息。</li>
</ul>
<p>下图显示了在配置外部代理（例如 RabbitMQ）以管理订阅和广播消息时使用的组件：</p>
<p><img src="https://docs.spring.io/spring-framework/docs/current/reference/html/images/message-flow-broker-relay.png" alt="message flow broker relay"></p>
<p>前面两个图之间的主要区别是使用“代理中继”通过 TCP 将消息向上传递到外部 STOMP 代理，以及将消息从代理向下传递到订阅的客户端。</p>
<p>当从 WebSocket 连接接收到消息时，它们被解码为 STOMP 帧，转换为 Spring Message 表示，并发送到 clientInboundChannel 进行进一步处理。例如，目标标头以 /app 开头的 STOMP 消息可以路由到带注释的控制器中的 @MessageMapping 方法，而 /topic 和 /queue 消息可以直接路由到消息代理。</p>
<p>处理来自客户端的 STOMP 消息的带注释的 @Controller 可以通过 brokerChannel 向消息代理发送消息，并且代理通过 clientOutboundChannel 将消息广播给匹配的订阅者。同一个控制器也可以响应HTTP请求做同样的事情，所以客户端可以执行HTTP POST，然后@PostMapping方法可以向消息代理发送消息广播给订阅的客户端。</p>
<p>我们可以通过一个简单的例子来追踪流程。考虑以下示例，它设置了一个服务器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/portfolio&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;/greeting&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(String greeting)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + getTimestamp() + <span class="string">&quot;: &quot;</span> + greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的示例支持以下流程：</p>
<ol>
<li>客户端连接到 <a href="http://localhost:8080/portfolio%EF%BC%8C%E4%B8%80%E6%97%A6%E5%BB%BA%E7%AB%8B%E4%BA%86">http://localhost:8080/portfolio，一旦建立了</a> WebSocket 连接，STOMP 帧就开始在其上流动。</li>
<li>客户端发送一个带有 /topic/greeting 目标头的 SUBSCRIBE 帧。收到并解码后，消息将发送到 clientInboundChannel，然后路由到存储客户端订阅的消息代理。</li>
<li>客户端向 /app/greeting 发送 SEND 帧。 /app 前缀有助于将其路由到带注释的控制器。去掉 /app 前缀后，目的地的剩余 /greeting 部分映射到 GreetingController 中的 @MessageMapping 方法。</li>
<li>从 GreetingController 返回的值根据返回值和 /topic/greeting 的默认目标标头（从 /app 替换为 /topic 的输入目标派生）转换为带有有效负载的 Spring 消息。结果消息被发送到 brokerChannel 并由消息代理处理。</li>
<li>消息代理找到所有匹配的订阅者并通过 clientOutboundChannel 向每个订阅者发送一个 MESSAGE 帧，从那里消息被编码为 STOMP 帧并通过 WebSocket 连接发送。</li>
</ol>
<h4 id="带注释的Controllers"><a href="#带注释的Controllers" class="headerlink" title="带注释的Controllers"></a>带注释的Controllers</h4><p>应用程序可以使用带注释的 @Controller 类来处理来自客户端的消息。此类类可以声明 @MessageMapping、@SubscribeMapping 和 @ExceptionHandler 方法，如以下主题中所述：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-message-mapping"><code>@MessageMapping</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-subscribe-mapping"><code>@SubscribeMapping</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-exception-handler"><code>@MessageExceptionHandler</code></a></li>
</ul>
<h5 id="MessageMapping"><a href="#MessageMapping" class="headerlink" title="@MessageMapping"></a><code>@MessageMapping</code></h5><p>您可以使用 @MessageMapping 注释根据目的地路由消息的方法。它在方法级别和类型级别都受支持。在类型级别，@MessageMapping 用于表示控制器中所有方法之间的共享映射。</p>
<p>默认情况下，映射值是 Ant 样式的路径模式（例如 /thing*、/thing/**），包括对模板变量的支持（例如 /thing/{id}）。可以通过@DestinationVariable 方法参数引用这些值。应用程序还可以切换到以点分隔的目标约定进行映射，如点作为分隔符中所述。</p>
<p>支持的方法参数</p>
<p>下表描述了方法参数：</p>
<table>
<thead>
<tr>
<th align="left">方法参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Message</code></td>
<td align="left">用于访问完整的消息。</td>
</tr>
<tr>
<td align="left"><code>MessageHeaders</code></td>
<td align="left">用于访问消息中的标题。</td>
</tr>
<tr>
<td align="left"><code>MessageHeaderAccessor</code>, <code>SimpMessageHeaderAccessor</code>, and <code>StompHeaderAccessor</code></td>
<td align="left">用于通过类型化访问器方法访问标头。</td>
</tr>
<tr>
<td align="left"><code>@Payload</code></td>
<td align="left">用于访问消息的有效负载，由配置的 MessageConverter 转换（例如，从 JSON）。 不需要此注释的存在，因为默认情况下，如果没有其他参数匹配，则假定它存在。 您可以使用 @javax.validation.Valid 或 Spring 的 @Validated 注释负载参数，以自动验证负载参数。</td>
</tr>
<tr>
<td align="left"><code>@Header</code></td>
<td align="left">用于访问特定标头值 — 以及使用 org.springframework.core.convert.converter.Converter 进行类型转换（如有必要）。</td>
</tr>
<tr>
<td align="left"><code>@Headers</code></td>
<td align="left">用于访问消息中的所有标头。此参数必须可分配给 java.util.Map。</td>
</tr>
<tr>
<td align="left"><code>@DestinationVariable</code></td>
<td align="left">用于访问从消息目标中提取的模板变量。根据需要将值转换为声明的方法参数类型。</td>
</tr>
<tr>
<td align="left"><code>java.security.Principal</code></td>
<td align="left">反映在 WebSocket HTTP 握手时登录的用户。</td>
</tr>
</tbody></table>
<p>返回值</p>
<p>默认情况下，@MessageMapping 方法的返回值通过匹配的 MessageConverter 序列化为有效负载，并作为消息发送到 brokerChannel，从那里广播给订阅者。出站消息的目的地与入站消息的目的地相同，但以 /topic 为前缀。</p>
<p>您可以使用 @SendTo 和 @SendToUser 注释来自定义输出消息的目的地。 @SendTo 用于自定义目标目的地或指定多个目的地。 @SendToUser 用于将输出消息定向到与输入消息关联的用户。</p>
<p>您可以在同一方法上同时使用 @SendTo 和 @SendToUser，并且在类级别都支持两者，在这种情况下，它们充当类中方法的默认值。但是，请记住，任何方法级别的 @SendTo 或 @SendToUser 注释都会覆盖类级别的任何此类注释。</p>
<p>消息可以异步处理，@MessageMapping 方法可以返回 ListenableFuture、CompletableFuture 或 CompletionStage。</p>
<p>请注意，@SendTo 和@SendToUser 只是一种便利，相当于使用 SimpMessagingTemplate 发送消息。如有必要，对于更高级的场景，@MessageMapping 方法可以直接使用 SimpMessagingTemplate。这可以代替返回值来完成，或者除了返回值之外。请参阅发送消息。</p>
<h5 id="SubscribeMapping"><a href="#SubscribeMapping" class="headerlink" title="@SubscribeMapping"></a><code>@SubscribeMapping</code></h5><p>@SubscribeMapping 与@MessageMapping 类似，但将映射范围缩小到仅订阅消息。它支持与@MessageMapping 相同的方法参数。但是对于返回值，默认情况下，消息直接发送到客户端（通过 clientOutboundChannel，响应订阅）而不是发送到代理（通过 brokerChannel，作为匹配订阅的广播）。添加 @SendTo 或 @SendToUser 会覆盖此行为并改为发送到代理。</p>
<p>这什么时候有用？假设代理映射到 /topic 和 /queue，而应用程序控制器映射到 /app。在此设置中，代理存储所有用于重复广播的 /topic 和 /queue 订阅，应用程序无需参与。客户端还可以订阅某个 /app 目的地，并且控制器可以返回一个值来响应该订阅，而无需代理再次存储或使用订阅（实际上是一次请求-回复交换）。一个用例是在启动时使用初始数据填充 UI。</p>
<p>这什么时候没用？不要尝试将代理和控制器映射到相同的目标前缀，除非您出于某种原因希望两者独立处理消息，包括订阅。入站消息是并行处理的。不能保证是代理还是控制器首先处理给定的消息。如果目标是在订阅存储并准备好广播时收到通知，如果服务器支持，客户端应该要求收据（简单代理不支持）。例如，使用 Java STOMP 客户端，您可以执行以下操作来添加收据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TaskScheduler messageBrokerTaskScheduler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// During initialization..</span></span><br><span class="line">stompClient.setTaskScheduler(<span class="keyword">this</span>.messageBrokerTaskScheduler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// When subscribing..</span></span><br><span class="line">StompHeaders headers = <span class="keyword">new</span> StompHeaders();</span><br><span class="line">headers.setDestination(<span class="string">&quot;/topic/...&quot;</span>);</span><br><span class="line">headers.setReceipt(<span class="string">&quot;r1&quot;</span>);</span><br><span class="line">FrameHandler handler = ...;</span><br><span class="line">stompSession.subscribe(headers, handler).addReceiptTask(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Subscription ready...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>服务器端选项是在 brokerChannel 上注册一个 ExecutorChannelInterceptor 并实现 afterMessageHandled 方法，该方法在处理消息（包括订阅）后调用。</p>
<h5 id="MessageExceptionHandler"><a href="#MessageExceptionHandler" class="headerlink" title="@MessageExceptionHandler"></a><code>@MessageExceptionHandler</code></h5><p>应用程序可以使用@MessageExceptionHandler 方法来处理来自@MessageMapping 方法的异常。如果您想访问异常实例，您可以在注释本身或通过方法参数声明异常。以下示例通过方法参数声明异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationError <span class="title">handleException</span><span class="params">(MyException exception)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> appError;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@MessageExceptionHandler 方法支持灵活的方法签名，并支持与@MessageMapping 方法相同的方法参数类型和返回值。</p>
<p>通常，@MessageExceptionHandler 方法应用于声明它们的 @Controller 类（或类层次结构）中。如果您希望这些方法在全局范围内（跨控制器）应用，您可以在标有 @ControllerAdvice 的类中声明它们。这与 Spring MVC 中可用的类似支持相当。</p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>如果您想从应用程序的任何部分向连接的客户端发送消息怎么办？任何应用程序组件都可以向 brokerChannel 发送消息。最简单的方法是注入一个 SimpMessagingTemplate 并使用它来发送消息。通常，您会按类型注入它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimpMessagingTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreetingController</span><span class="params">(SimpMessagingTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path=&quot;/greetings&quot;, method=POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(String greeting)</span> </span>&#123;</span><br><span class="line">        String text = <span class="string">&quot;[&quot;</span> + getTimestamp() + <span class="string">&quot;]:&quot;</span> + greeting;</span><br><span class="line">        <span class="keyword">this</span>.template.convertAndSend(<span class="string">&quot;/topic/greetings&quot;</span>, text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果存在另一个相同类型的 bean，您也可以通过其名称 (brokerMessagingTemplate) 对其进行限定。</p>
<h4 id="Simple-Broker"><a href="#Simple-Broker" class="headerlink" title="Simple Broker"></a>Simple Broker</h4><p>内置的简单消息代理处理来自客户端的订阅请求，将它们存储在内存中，并将消息广播到具有匹配目的地的连接客户端。代理支持类似路径的目的地，包括订阅 Ant 风格的目的地模式。</p>
<p>应用程序还可以使用点分隔（而不是斜线分隔）目标。将点视为分隔符。</p>
<p>如果配置了任务调度程序，则简单代理支持 STOMP 心跳。为此，您可以声明自己的调度程序或使用自动声明并在内部使用的调度程序。以下示例显示了如何声明您自己的调度程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TaskScheduler messageBrokerTaskScheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageBrokerTaskScheduler</span><span class="params">(TaskScheduler taskScheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageBrokerTaskScheduler = taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/queue/&quot;</span>, <span class="string">&quot;/topic/&quot;</span>)</span><br><span class="line">                .setHeartbeatValue(<span class="keyword">new</span> <span class="keyword">long</span>[] &#123;<span class="number">10000</span>, <span class="number">20000</span>&#125;)</span><br><span class="line">                .setTaskScheduler(<span class="keyword">this</span>.messageBrokerTaskScheduler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="External-Broker"><a href="#External-Broker" class="headerlink" title="External Broker"></a>External Broker</h4><p>simple broker 非常适合入门，但仅支持 STOMP 命令的一个子集（它不支持 acks、receipts 和一些其他功能），依赖于简单的消息发送循环，并且不适合集群。作为替代方案，您可以升级您的应用程序以使用功能齐全的消息代理。</p>
<p>请参阅您选择的消息代理（例如 RabbitMQ、ActiveMQ 等）的 STOMP 文档，安装代理，并在启用 STOMP 支持的情况下运行它。然后你可以在 Spring 配置中启用 STOMP 代理中继（而不是简单的代理）。</p>
<p>以下示例配置启用全功能代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/portfolio&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.enableStompBrokerRelay(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>);</span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下示例显示了与前面示例等效的 XML 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">&quot;http://www.springframework.org/schema/websocket&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/websocket/spring-websocket.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:message-broker</span> <span class="attr">application-destination-prefix</span>=<span class="string">&quot;/app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:stomp-endpoint</span> <span class="attr">path</span>=<span class="string">&quot;/portfolio&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">websocket:sockjs</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">websocket:stomp-endpoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:stomp-broker-relay</span> <span class="attr">prefix</span>=<span class="string">&quot;/topic,/queue&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:message-broker</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前面配置中的 STOMP 代理中继是一个 Spring MessageHandler，它通过将消息转发到外部消息代理来处理消息。为此，它会与代理建立 TCP 连接，将所有消息转发给它，然后通过客户端的 WebSocket 会话将从代理收到的所有消息转发给客户端。本质上，它充当双向转发消息的“中继”。</p>
<p>将 io.projectreactor.netty:reactor-netty 和 io.netty:netty-all 依赖项添加到您的项目中以进行 TCP 连接管理。</p>
<p>此外，应用程序组件（例如 HTTP 请求处理方法、业务服务等）还可以将消息发送到代理中继，如发送消息中所述，以向订阅的 WebSocket 客户端广播消息。</p>
<p>实际上，代理中继实现了强大且可扩展的消息广播。</p>
]]></content>
      <categories>
        <category>网络协议</category>
        <category>websocket</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudGateway基本使用</title>
    <url>/2021/11/09/SpringCloudGateway%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-Gateway基本使用"><a href="#Spring-Cloud-Gateway基本使用" class="headerlink" title="Spring Cloud Gateway基本使用"></a>Spring Cloud Gateway基本使用</h1><p>本项目提供了一个构建在 Spring 生态系统之上的 API 网关，包括：Spring 5、Spring Boot 2 和 Project Reactor。 Spring Cloud Gateway 旨在提供一种简单而有效的方式来路由到 API 并为它们提供交叉关注点，例如：安全性、监控/指标和弹性。</p>
<h2 id="1-如何集成Spring-Cloud-Gateway"><a href="#1-如何集成Spring-Cloud-Gateway" class="headerlink" title="1.如何集成Spring Cloud Gateway"></a>1.如何集成Spring Cloud Gateway</h2><p>要将 Spring Cloud Gateway 包含在您的项目中，请使用具有 org.springframework.cloud 的组 ID 和 spring-cloud-starter-gateway 的工件 ID 的 starter。有关使用当前 Spring Cloud Release Train 设置构建系统的详细信息，请参阅 Spring Cloud 项目页面。</p>
<p>如果包含启动器，但不希望启用网关，请设置 spring.cloud.gateway.enabled=false。</p>
<p>Spring Cloud Gateway 基于 Spring Boot 2.x、Spring WebFlux 和 Project Reactor 构建。因此，当您使用 Spring Cloud Gateway 时，您所知道的许多熟悉的同步库（例如 Spring Data 和 Spring Security）和模式可能不适用。如果您不熟悉这些项目，我们建议您在使用 Spring Cloud Gateway 之前先阅读他们的文档以熟悉一些新概念。</p>
<p>Spring Cloud Gateway 需要 Spring Boot 和 Spring Webflux 提供的 Netty 运行时。它不适用于传统的 Servlet 容器或构建为 WAR 时。</p>
<h2 id="2-词汇表"><a href="#2-词汇表" class="headerlink" title="2. 词汇表"></a>2. 词汇表</h2><ul>
<li><strong>Route</strong>: 网关的基本构建块。它由 ID、目标 URI、谓词集合和过滤器集合定义。如果聚合谓词为真，则匹配路由。</li>
<li><strong>Predicate</strong>: 这是一个 Java 8 函数谓词。输入类型是 Spring Framework ServerWebExchange。这使您可以匹配来自 HTTP 请求的任何内容，例如标头或参数。</li>
<li><strong>Filter</strong>: 这些是使用特定工厂构建的 GatewayFilter 实例。在这里，您可以在发送下游请求之前或之后修改请求和响应。</li>
</ul>
<h2 id="3-工作原理"><a href="#3-工作原理" class="headerlink" title="3. 工作原理"></a>3. 工作原理</h2><p>下图提供了 Spring Cloud Gateway 工作原理的高级概述：</p>
<p><img src="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/images/spring_cloud_gateway_diagram.png" alt="Spring Cloud Gateway Diagram"></p>
<p>客户端向 Spring Cloud Gateway 发出请求。如果网关处理程序映射确定请求与路由匹配，则将其发送到网关 Web 处理程序。此处理程序通过特定于请求的过滤器链运行请求。过滤器被虚线分隔的原因是过滤器可以在发送代理请求之前和之后运行逻辑。执行所有“预”过滤器逻辑。然后进行代理请求。发出代理请求后，将运行“post”过滤器逻辑。</p>
<p>在没有端口的路由中定义的 URI 分别获得 HTTP 和 HTTPS URI 的默认端口值 80 和 443。</p>
<h2 id="4-配置路由谓词工厂和网关过滤工厂"><a href="#4-配置路由谓词工厂和网关过滤工厂" class="headerlink" title="4. 配置路由谓词工厂和网关过滤工厂"></a>4. 配置路由谓词工厂和网关过滤工厂</h2><p>有两种方法可以配置谓词和过滤器：快捷方式和完全扩展的参数。下面的大多数示例都使用快捷方式。</p>
<p>名称和参数名称将在每个部分的第一句或第二句中作为代码列出。参数通常按快捷方式配置所需的顺序列出。</p>
<h3 id="4-1-快捷方式配置"><a href="#4-1-快捷方式配置" class="headerlink" title="4.1.快捷方式配置"></a>4.1.快捷方式配置</h3><p>快捷方式配置由过滤器名称识别，后跟等号 (=)，后跟由逗号 (,) 分隔的参数值。</p>
<p><strong>application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=mycookie,mycookievalue</span></span><br></pre></td></tr></table></figure>

<p>前面的示例使用两个参数定义了 Cookie 路由谓词工厂，即 cookie 名称、mycookie 和匹配 mycookievalue 的值。</p>
<h3 id="4-2-完全展开的参数"><a href="#4-2-完全展开的参数" class="headerlink" title="4.2.完全展开的参数"></a>4.2.完全展开的参数</h3><p>完全扩展的参数看起来更像是带有名称/值对的标准 yaml 配置。通常，会有一个 name 键和一个 args 键。 args 键是键值对的映射，用于配置谓词或过滤器。</p>
<p><strong>application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cookie</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">mycookie</span></span><br><span class="line">            <span class="attr">regexp:</span> <span class="string">mycookievalue</span></span><br></pre></td></tr></table></figure>

<p>这就是上面显示的 Cookie 谓词的快捷配置的完整配置。</p>
<h2 id="5-路由谓词工厂"><a href="#5-路由谓词工厂" class="headerlink" title="5. 路由谓词工厂"></a>5. 路由谓词工厂</h2><p>Spring Cloud Gateway 匹配路由作为 Spring WebFlux HandlerMapping 基础结构的一部分。 Spring Cloud Gateway 包含许多内置的路由谓词工厂。所有这些谓词都匹配 HTTP 请求的不同属性。您可以将多个路由谓词工厂与逻辑和语句组合在一起。</p>
<h3 id="5-1-after路由谓词工厂"><a href="#5-1-after路由谓词工厂" class="headerlink" title="5.1.after路由谓词工厂"></a>5.1.after路由谓词工厂</h3><p>After 路由谓词工厂接受一个参数，一个日期时间（这是一个 java ZonedDateTime）。此谓词匹配在指定日期时间之后发生的请求。以下示例配置了一个 after 路由谓词：</p>
<p><strong>Example 1. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure>

<p>此路由匹配Jan 20, 2017 17:42 Mountain Time (Denver)之后提出的任何请求。</p>
<h3 id="5-2-before路由谓词工厂"><a href="#5-2-before路由谓词工厂" class="headerlink" title="5.2.before路由谓词工厂"></a>5.2.before路由谓词工厂</h3><p>Before 路由谓词工厂接受一个参数，一个日期时间（它是一个 java ZonedDateTime）。此谓词匹配在指定日期时间之前发生的请求。以下示例配置了一个 before 路由谓词：</p>
<p><strong>Example 2. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">before_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Before=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure>

<p>此路由匹配  Jan 20, 2017 17:42 Mountain Time (Denver)之前提出的任何请求。</p>
<h3 id="5-3-between路由谓词工厂"><a href="#5-3-between路由谓词工厂" class="headerlink" title="5.3.between路由谓词工厂"></a>5.3.between路由谓词工厂</h3><p>路由谓词工厂之间有两个参数，datetime1 和 datetime2，它们是 java ZonedDateTime 对象。此谓词匹配发生在 datetime1 之后和 datetime2 之前的请求。 datetime2 参数必须在 datetime1 之后。以下示例配置了一个 between 路由谓词：</p>
<p><strong>Example 3. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">between_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="number">2017-01-21T17:42:47.789-07:00</span>[<span class="string">America/Denver</span>]</span><br></pre></td></tr></table></figure>

<p>此路由匹配 2017-01-20T17:42:47.789-07:00[America/Denver]之后和 2017-01-21T17:42:47.789-07:00[America/Denver]之前提出的任何请求。这对于维护窗口可能很有用。</p>
<h3 id="5-4-Cookie-路由谓词工厂"><a href="#5-4-Cookie-路由谓词工厂" class="headerlink" title="5.4. Cookie 路由谓词工厂"></a>5.4. Cookie 路由谓词工厂</h3><p>Cookie 路由谓词工厂有两个参数，即 cookie 名称和一个 regexp（这是一个 Java 正则表达式）。此谓词匹配具有给定名称且其值与正则表达式匹配的 cookie。以下示例配置 cookie 路由谓词工厂：</p>
<p><strong>Example 4. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cookie_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=chocolate,</span> <span class="string">ch.p</span></span><br></pre></td></tr></table></figure>

<p>此路由匹配具有名为 Chocolate 的 cookie 的请求，该 cookie 的值与 ch.p 正则表达式匹配。</p>
<h3 id="5-5-header路由谓词工厂"><a href="#5-5-header路由谓词工厂" class="headerlink" title="5.5.header路由谓词工厂"></a>5.5.header路由谓词工厂</h3><p>Header 路由谓词工厂接受两个参数，标题名称和一个 regexp（这是一个 Java 正则表达式）。此谓词与具有给定名称的标头匹配，其值与正则表达式匹配。以下示例配置标头路由谓词：</p>
<p><strong>Example 5. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>

<p>如果请求具有名为 X-Request-Id 的标头，其值与 \d+ 正则表达式匹配（即，它具有一个或多个数字的值），则此路由匹配。</p>
<h3 id="5-6-host路由谓词工厂"><a href="#5-6-host路由谓词工厂" class="headerlink" title="5.6.host路由谓词工厂"></a>5.6.host路由谓词工厂</h3><p>Host路由谓词工厂采用一个参数：host名模式列表。该模式是 Ant 风格的模式，带有 .作为分隔符。此谓词匹配与模式匹配的 Host 标头。以下示例配置host路由谓词：</p>
<p><strong>Example 6. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Host=**.somehost.org,**.anotherhost.org</span></span><br></pre></td></tr></table></figure>

<p>还支持 URI 模板变量（例如 {sub}.myhost.org）。</p>
<p>如果请求具有值为 <a href="http://www.somehost.org/">www.somehost.org</a> 或 beta.somehost.org 或 <a href="http://www.anotherhost.org/">www.anotherhost.org</a> 的 Host 标头，则此路由匹配。</p>
<p>此谓词提取 URI 模板变量（例如，在前面的示例中定义的 sub）作为名称和值的映射，并将其放置在 ServerWebExchange.getAttributes() 中，并使用在 ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE 中定义的键。然后这些值可供 GatewayFilter 工厂使用</p>
<h3 id="5-7-method路由谓词工厂"><a href="#5-7-method路由谓词工厂" class="headerlink" title="5.7.method路由谓词工厂"></a>5.7.method路由谓词工厂</h3><p>方法路由谓词工厂采用一个方法参数，它是一个或多个参数：要匹配的 HTTP 方法。以下示例配置方法路由谓词：</p>
<p><strong>Example 7. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure>

<p>如果请求方法是 GET 或 POST，则此路由匹配。</p>
<h3 id="5-8-path路由谓词工厂"><a href="#5-8-path路由谓词工厂" class="headerlink" title="5.8.path路由谓词工厂"></a>5.8.path路由谓词工厂</h3><p>Path Route Predicate Factory 接受两个参数：一个 Spring PathMatcher 模式列表和一个名为 matchTrailingSlash 的可选标志（默认为 true）。以下示例配置路径路由谓词：</p>
<p><strong>Example 8. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">path_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果请求路径是例如：/red/1 或 /red/1/ 或 /red/blue 或 /blue/green，则此路由匹配。</p>
<p>如果 matchTrailingSlash 设置为 false，则不会匹配请求路径 /red/1/。</p>
<p>此谓词提取 URI 模板变量（例如在前面的示例中定义的段）作为名称和值的映射，并将其放置在 ServerWebExchange.getAttributes() 中，键是在 ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE 中定义的。然后这些值可供 GatewayFilter 工厂使用 可以使用实用方法（称为 get）来更轻松地访问这些变量。以下示例显示了如何使用 get 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; uriVariables = ServerWebExchangeUtils.getPathPredicateVariables(exchange);</span><br><span class="line"></span><br><span class="line">String segment = uriVariables.get(<span class="string">&quot;segment&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-9-query路由谓词工厂"><a href="#5-9-query路由谓词工厂" class="headerlink" title="5.9.query路由谓词工厂"></a>5.9.query路由谓词工厂</h3><p>Query路由谓词工厂有两个参数：一个必需的参数和一个可选的正则表达式（它是一个 Java 正则表达式）。以下示例配置查询路由谓词：</p>
<p><strong>Example 9. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">query_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Query=green</span></span><br></pre></td></tr></table></figure>

<p>如果请求包含绿色查询参数，则前面的路由匹配。</p>
<p><strong>application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">query_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Query=red,</span> <span class="string">gree.</span></span><br></pre></td></tr></table></figure>

<p>如果请求包含值与 gree 匹配的红色查询参数，则前面的路由匹配。 regexp，所以 green 和 greet 会匹配。</p>
<h3 id="5-10-RemoteAddr-路由谓词工厂"><a href="#5-10-RemoteAddr-路由谓词工厂" class="headerlink" title="5.10. RemoteAddr 路由谓词工厂"></a>5.10. RemoteAddr 路由谓词工厂</h3><p>RemoteAddr 路由谓词工厂采用源列表（最小大小 1），这些源是 CIDR 表示法（IPv4 或 IPv6）字符串，例如 192.168.0.1/16（其中 192.168.0.1 是 IP 地址，16 是子网掩码）。以下示例配置 RemoteAddr 路由谓词：</p>
<p><strong>Example 10. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RemoteAddr=192.168.1.1/24</span></span><br></pre></td></tr></table></figure>

<p>如果请求的远程地址是例如 192.168.1.10，则此路由匹配。</p>
<h3 id="5-11-Weight权重路由谓词工厂"><a href="#5-11-Weight权重路由谓词工厂" class="headerlink" title="5.11.Weight权重路由谓词工厂"></a>5.11.Weight权重路由谓词工厂</h3><p>Weight 路由谓词工厂采用两个参数：group 和 weight（一个 int）。权重按组计算。以下示例配置权重路由谓词：</p>
<p><strong>Example 11. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_high</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://weighthigh.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_low</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://weightlow.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>该路由会将约 80% 的流量转发到 weighthigh.org，将约 20% 的流量转发到 weightlow.org</p>
<h4 id="5-11-1-修改远程地址的解析方式"><a href="#5-11-1-修改远程地址的解析方式" class="headerlink" title="5.11.1.修改远程地址的解析方式"></a>5.11.1.修改远程地址的解析方式</h4><p>默认情况下，RemoteAddr 路由谓词工厂使用来自传入请求的远程地址。如果 Spring Cloud Gateway 位于代理层之后，这可能与实际客户端 IP 地址不匹配。</p>
<p>您可以通过设置自定义 RemoteAddressResolver 来自定义解析远程地址的方式。 Spring Cloud Gateway 带有一个基于 X-Forwarded-For 标头 XForwardedRemoteAddressResolver 的非默认远程地址解析器。</p>
<p>XForwardedRemoteAddressResolver 有两个静态构造函数方法，它们采取不同的安全方法：</p>
<ul>
<li>XForwardedRemoteAddressResolver::trustAll 返回一个 RemoteAddressResolver，它总是采用在 X-Forwarded-For 标头中找到的第一个 IP 地址。这种方法容易受到欺骗，因为恶意客户端可以为 X-Forwarded-For 设置一个初始值，该值将被解析器接受。</li>
<li>XForwardedRemoteAddressResolver::maxTrustedIndex 采用一个索引，该索引与运行在 Spring Cloud Gateway 前面的受信任基础设施的数量相关。例如，如果 Spring Cloud Gateway 只能通过 HAProxy 访问，则应使用值 1。如果在访问 Spring Cloud Gateway 之前需要两跳可信基础设施，则应使用值 2。</li>
</ul>
<p>考虑以下标头值：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">X-Forwarded-For:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">,</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.2</span><span class="string">,</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>

<p>以下 maxTrustedIndex 值产生以下远程地址：</p>
<table>
<thead>
<tr>
<th align="left"><code>maxTrustedIndex</code></th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[<code>Integer.MIN_VALUE</code>,0]</td>
<td align="left">（无效，初始化期间 IllegalArgumentException）</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0.0.0.3</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">0.0.0.2</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">0.0.0.1</td>
</tr>
<tr>
<td align="left">[4, <code>Integer.MAX_VALUE</code>]</td>
<td align="left">0.0.0.1</td>
</tr>
</tbody></table>
<p>以下示例显示了如何使用 Java 实现相同的配置：</p>
<p>Example 12. GatewayConfig.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RemoteAddressResolver resolver = XForwardedRemoteAddressResolver</span><br><span class="line">    .maxTrustedIndex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.route(<span class="string">&quot;direct-route&quot;</span>,</span><br><span class="line">    r -&gt; r.remoteAddr(<span class="string">&quot;10.1.1.1&quot;</span>, <span class="string">&quot;10.10.1.1/24&quot;</span>)</span><br><span class="line">        .uri(<span class="string">&quot;https://downstream1&quot;</span>)</span><br><span class="line">.route(<span class="string">&quot;proxied-route&quot;</span>,</span><br><span class="line">    r -&gt; r.remoteAddr(resolver, <span class="string">&quot;10.10.1.1&quot;</span>, <span class="string">&quot;10.10.1.1/24&quot;</span>)</span><br><span class="line">        .uri(<span class="string">&quot;https://downstream2&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="6-GatewayFilter-工厂"><a href="#6-GatewayFilter-工厂" class="headerlink" title="6. GatewayFilter 工厂"></a>6. GatewayFilter 工厂</h2><p>路由过滤器允许以某种方式修改传入的 HTTP 请求或传出的 HTTP 响应。路由过滤器的范围是特定的路由。 Spring Cloud Gateway 包含许多内置的 GatewayFilter 工厂。</p>
<h3 id="6-1-AddRequestHeader-网关过滤器工厂"><a href="#6-1-AddRequestHeader-网关过滤器工厂" class="headerlink" title="6.1. AddRequestHeader 网关过滤器工厂"></a>6.1. AddRequestHeader 网关过滤器工厂</h3><p>AddRequestHeader GatewayFilter 工厂采用名称和值参数。以下示例配置 AddRequestHeader GatewayFilter：</p>
<p><strong>Example 13. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_request_header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-red,</span> <span class="string">blue</span></span><br></pre></td></tr></table></figure>

<p>此清单将 X-Request-red:blue 标头添加到所有匹配请求的下游请求标头中。</p>
<p>AddRequestHeader 知道用于匹配路径或主机的 URI 变量。 URI 变量可以在值中使用并在运行时扩展。以下示例配置使用变量的 AddRequestHeader GatewayFilter：</p>
<p><strong>Example 14. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_request_header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/red/&#123;segment&#125;</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-Red,</span> <span class="string">Blue-&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-AddRequestParameter-网关过滤器工厂"><a href="#6-2-AddRequestParameter-网关过滤器工厂" class="headerlink" title="6.2. AddRequestParameter 网关过滤器工厂"></a>6.2. AddRequestParameter 网关过滤器工厂</h3><p>AddRequestParameter GatewayFilter Factory 采用名称和值参数。以下示例配置 AddRequestParameter GatewayFilter：</p>
<p><strong>Example 15. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_request_parameter_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestParameter=red,</span> <span class="string">blue</span></span><br></pre></td></tr></table></figure>

<p>这会将 red=blue 添加到所有匹配请求的下游请求的查询字符串中。</p>
<p>AddRequestParameter 知道用于匹配路径或主机的 URI 变量。 URI 变量可以在值中使用并在运行时扩展。以下示例配置使用变量的 AddRequestParameter GatewayFilter：</p>
<p><strong>Example 16. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_request_parameter_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Host:</span> &#123;<span class="string">segment</span>&#125;<span class="string">.myhost.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestParameter=foo,</span> <span class="string">bar-&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-AddResponseHeader-网关过滤器工厂"><a href="#6-3-AddResponseHeader-网关过滤器工厂" class="headerlink" title="6.3. AddResponseHeader 网关过滤器工厂"></a>6.3. AddResponseHeader 网关过滤器工厂</h3><p>AddResponseHeader GatewayFilter Factory 采用名称和值参数。以下示例配置 AddResponseHeader GatewayFilter：</p>
<p><strong>Example 17. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_response_header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddResponseHeader=X-Response-Red,</span> <span class="string">Blue</span></span><br></pre></td></tr></table></figure>

<p>这会将 X-Response-Foo:Bar 标头添加到所有匹配请求的下游响应标头中。</p>
<p>AddResponseHeader 知道用于匹配路径或主机的 URI 变量。 URI 变量可以在值中使用并在运行时扩展。以下示例配置使用变量的 AddResponseHeader GatewayFilter：</p>
<p><strong>Example 18. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_response_header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Host:</span> &#123;<span class="string">segment</span>&#125;<span class="string">.myhost.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddResponseHeader=foo,</span> <span class="string">bar-&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-DedupeResponseHeader-网关过滤器工厂"><a href="#6-4-DedupeResponseHeader-网关过滤器工厂" class="headerlink" title="6.4. DedupeResponseHeader 网关过滤器工厂"></a>6.4. DedupeResponseHeader 网关过滤器工厂</h3><p>DedupeResponseHeader GatewayFilter 工厂采用名称参数和可选的策略参数。 name 可以包含以空格分隔的标题名称列表。以下示例配置 DedupeResponseHeader GatewayFilter：</p>
<p><strong>Example 19. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">dedupe_response_header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">DedupeResponseHeader=Access-Control-Allow-Credentials</span> <span class="string">Access-Control-Allow-Origin</span></span><br></pre></td></tr></table></figure>

<p>在网关 CORS 逻辑和下游逻辑都添加它们的情况下，这会删除 Access-Control-Allow-Credentials 和 Access-Control-Allow-Origin 响应标头的重复值。</p>
<p>DedupeResponseHeader 过滤器还接受一个可选的策略参数。接受的值为 RETAIN_FIRST（默认）、RETAIN_LAST 和 RETAIN_UNIQUE。</p>
<h3 id="6-5-Spring-Cloud-断路器网关过滤器工厂"><a href="#6-5-Spring-Cloud-断路器网关过滤器工厂" class="headerlink" title="6.5. Spring Cloud 断路器网关过滤器工厂"></a>6.5. Spring Cloud 断路器网关过滤器工厂</h3><p>Spring Cloud CircuitBreaker GatewayFilter 工厂使用 Spring Cloud CircuitBreaker API 将网关路由包装在断路器中。 Spring Cloud CircuitBreaker 支持多个可与 Spring Cloud Gateway 一起使用的库。 Spring Cloud 支持开箱即用的 Resilience4J。</p>
<p>要启用 Spring Cloud CircuitBreaker 过滤器，您需要将 spring-cloud-starter-circuitbreaker-reactor-resilience4j 放在类路径上。以下示例配置 Spring Cloud CircuitBreaker GatewayFilter：</p>
<p><strong>Example 20. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">circuitbreaker_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CircuitBreaker=myCircuitBreaker</span></span><br></pre></td></tr></table></figure>

<p>要配置断路器，请参阅您正在使用的底层断路器实现的配置。</p>
<ul>
<li><a href="https://cloud.spring.io/spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html">Resilience4J Documentation</a></li>
</ul>
<p>Spring Cloud CircuitBreaker 过滤器还可以接受可选的 fallbackUri 参数。目前，只支持转发：schemed URIs。如果调用回退，则请求将转发到与 URI 匹配的控制器。以下示例配置了这样的回退：</p>
<p><strong>Example 21. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">circuitbreaker_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://backing-service:8088</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/consumingServiceEndpoint</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CircuitBreaker</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">myCircuitBreaker</span></span><br><span class="line">            <span class="attr">fallbackUri:</span> <span class="string">forward:/inCaseOfFailureUseThis</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RewritePath=/consumingServiceEndpoint,</span> <span class="string">/backingServiceEndpoint</span></span><br></pre></td></tr></table></figure>

<p>下面的清单在 Java 中做了同样的事情：</p>
<p><strong>Example 22. Application.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">routes</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.routes()</span><br><span class="line">        .route(<span class="string">&quot;circuitbreaker_route&quot;</span>, r -&gt; r.path(<span class="string">&quot;/consumingServiceEndpoint&quot;</span>)</span><br><span class="line">            .filters(f -&gt; f.circuitBreaker(c -&gt; c.name(<span class="string">&quot;myCircuitBreaker&quot;</span>).fallbackUri(<span class="string">&quot;forward:/inCaseOfFailureUseThis&quot;</span>))</span><br><span class="line">                .rewritePath(<span class="string">&quot;/consumingServiceEndpoint&quot;</span>, <span class="string">&quot;/backingServiceEndpoint&quot;</span>)).uri(<span class="string">&quot;lb://backing-service:8088&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用断路器回退时，此示例转发到 /inCaseofFailureUseThis URI。请注意，此示例还演示了（可选）Spring Cloud LoadBalancer 负载平衡（由目标 URI 上的 lb 前缀定义）。</p>
<p>主要场景是使用 fallbackUri 在网关应用程序中定义内部控制器或处理程序。但是，您也可以将请求重新路由到外部应用程序中的控制器或处理程序，如下所示：</p>
<p><strong>Example 23. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ingredients</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://ingredients</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=//ingredients/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CircuitBreaker</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">fetchIngredients</span></span><br><span class="line">            <span class="attr">fallbackUri:</span> <span class="string">forward:/fallback</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ingredients-fallback</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:9994</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/fallback</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，网关应用程序中没有回退端点或处理程序。但是，在另一个应用程序中有一个，在 localhost:9994 下注册。</p>
<p>如果请求被转发到回退，Spring Cloud CircuitBreaker Gateway 过滤器还提供导致它的 Throwable。它作为 ServerWebExchangeUtils.CIRCUITBREAKER_EXECUTION_EXCEPTION_ATTR 属性添加到 ServerWebExchange 中，可在网关应用程序中处理回退时使用。</p>
<p>对于外部控制器/处理程序场景，可以添加带有异常详细信息的标头。您可以在 FallbackHeaders GatewayFilter Factory 部分找到有关这样做的更多信息。</p>
<h4 id="6-5-1-根据状态代码使断路器脱扣"><a href="#6-5-1-根据状态代码使断路器脱扣" class="headerlink" title="6.5.1.根据状态代码使断路器脱扣"></a>6.5.1.根据状态代码使断路器脱扣</h4><p>在某些情况下，您可能希望根据从其环绕的路由返回的状态代码来触发断路器。断路器配置对象采用状态代码列表，如果返回这些状态代码，将导致断路器跳闸。在设置要使断路器跳闸的状态代码时，您可以使用带有状态代码值的整数或 HttpStatus 枚举的字符串表示形式。</p>
<p><strong>Example 24. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">circuitbreaker_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://backing-service:8088</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/consumingServiceEndpoint</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CircuitBreaker</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">myCircuitBreaker</span></span><br><span class="line">            <span class="attr">fallbackUri:</span> <span class="string">forward:/inCaseOfFailureUseThis</span></span><br><span class="line">            <span class="attr">statusCodes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="number">500</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;NOT_FOUND&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 25. Application.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">routes</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.routes()</span><br><span class="line">        .route(<span class="string">&quot;circuitbreaker_route&quot;</span>, r -&gt; r.path(<span class="string">&quot;/consumingServiceEndpoint&quot;</span>)</span><br><span class="line">            .filters(f -&gt; f.circuitBreaker(c -&gt; c.name(<span class="string">&quot;myCircuitBreaker&quot;</span>).fallbackUri(<span class="string">&quot;forward:/inCaseOfFailureUseThis&quot;</span>).addStatusCode(<span class="string">&quot;INTERNAL_SERVER_ERROR&quot;</span>))</span><br><span class="line">                .rewritePath(<span class="string">&quot;/consumingServiceEndpoint&quot;</span>, <span class="string">&quot;/backingServiceEndpoint&quot;</span>)).uri(<span class="string">&quot;lb://backing-service:8088&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.6. FallbackHeaders 网关过滤器工厂</p>
<p>FallbackHeaders 工厂允许您在转发到外部应用程序中的 fallbackUri 的请求的标头中添加 Spring Cloud CircuitBreaker 执行异常详细信息，如下面的场景：</p>
<p><strong>Example 26. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ingredients</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://ingredients</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=//ingredients/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CircuitBreaker</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">fetchIngredients</span></span><br><span class="line">            <span class="attr">fallbackUri:</span> <span class="string">forward:/fallback</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ingredients-fallback</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:9994</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/fallback</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FallbackHeaders</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">executionExceptionTypeHeaderName:</span> <span class="string">Test-Header</span></span><br></pre></td></tr></table></figure>

<h3 id="6-6-FallbackHeaders-网关过滤器工厂"><a href="#6-6-FallbackHeaders-网关过滤器工厂" class="headerlink" title="6.6. FallbackHeaders 网关过滤器工厂"></a>6.6. FallbackHeaders 网关过滤器工厂</h3><p>FallbackHeaders 工厂允许您在转发到外部应用程序中的 fallbackUri 的请求的标头中添加 Spring Cloud CircuitBreaker 执行异常详细信息，如下面的场景：</p>
<p><strong>Example 26. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ingredients</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://ingredients</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=//ingredients/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CircuitBreaker</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">fetchIngredients</span></span><br><span class="line">            <span class="attr">fallbackUri:</span> <span class="string">forward:/fallback</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ingredients-fallback</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:9994</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/fallback</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FallbackHeaders</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">executionExceptionTypeHeaderName:</span> <span class="string">Test-Header</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，在运行断路器时发生执行异常后，请求将转发到在 localhost:9994 上运行的应用程序中的回退端点或处理程序。 FallbackHeaders 过滤器将带有异常类型、消息和（如果可用）根本原因异常类型和消息的标头添加到该请求中。</p>
<p>您可以通过设置以下参数的值（显示为它们的默认值）来覆盖配置中标头的名称：</p>
<ul>
<li><code>executionExceptionTypeHeaderName</code> (<code>&quot;Execution-Exception-Type&quot;</code>)</li>
<li><code>executionExceptionMessageHeaderName</code> (<code>&quot;Execution-Exception-Message&quot;</code>)</li>
<li><code>rootCauseExceptionTypeHeaderName</code> (<code>&quot;Root-Cause-Exception-Type&quot;</code>)</li>
<li><code>rootCauseExceptionMessageHeaderName</code> (<code>&quot;Root-Cause-Exception-Message&quot;</code>)</li>
</ul>
<p>有关断路器和网关的更多信息，请参阅 Spring Cloud CircuitBreaker Factory 部分。</p>
<h3 id="6-7-MapRequestHeader-网关过滤器工厂"><a href="#6-7-MapRequestHeader-网关过滤器工厂" class="headerlink" title="6.7. MapRequestHeader 网关过滤器工厂"></a>6.7. MapRequestHeader 网关过滤器工厂</h3><p>MapRequestHeader GatewayFilter 工厂采用 fromHeader 和 toHeader 参数。它创建一个新的命名标头 (toHeader)，并从传入的 http 请求中从现有命名标头 (fromHeader) 中提取该值。如果输入标头不存在，则过滤器没有影响。如果新命名的标头已存在，则其值将使用新值进行扩充。以下示例配置 MapRequestHeader：</p>
<p><strong>Example 27. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">map_request_header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">MapRequestHeader=Blue,</span> <span class="string">X-Request-Red</span></span><br></pre></td></tr></table></figure>

<p>这会将 X-Request-Red:<values> 标头添加到下游请求中，并使用来自传入 HTTP 请求的 Blue 标头的更新值。</p>
<h3 id="6-8-PrefixPath-网关过滤器工厂"><a href="#6-8-PrefixPath-网关过滤器工厂" class="headerlink" title="6.8. PrefixPath 网关过滤器工厂"></a>6.8. PrefixPath 网关过滤器工厂</h3><p>PrefixPath GatewayFilter 工厂采用单个前缀参数。以下示例配置 PrefixPath GatewayFilter：</p>
<p><strong>Example 28. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">prefixpath_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">PrefixPath=/mypath</span></span><br></pre></td></tr></table></figure>

<p>这会将 /mypath 前缀为所有匹配请求的路径。因此，对 /hello 的请求将被发送到 /mypath/hello。</p>
<h3 id="6-9-PreserveHostHeader-网关过滤器工厂"><a href="#6-9-PreserveHostHeader-网关过滤器工厂" class="headerlink" title="6.9. PreserveHostHeader 网关过滤器工厂"></a>6.9. PreserveHostHeader 网关过滤器工厂</h3><p>PreserveHostHeader GatewayFilter 工厂没有参数。此过滤器设置路由过滤器检查的请求属性，以确定是否应发送原始主机标头，而不是由 HTTP 客户端确定的主机标头。以下示例配置 PreserveHostHeader GatewayFilter：</p>
<p><strong>Example 29. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">preserve_host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">PreserveHostHeader</span></span><br></pre></td></tr></table></figure>

<h3 id="6-10-RequestRateLimiter-网关过滤器工厂"><a href="#6-10-RequestRateLimiter-网关过滤器工厂" class="headerlink" title="6.10. RequestRateLimiter 网关过滤器工厂"></a>6.10. RequestRateLimiter 网关过滤器工厂</h3><p>RequestRateLimiter GatewayFilter 工厂使用 RateLimiter 实现来确定是否允许继续处理当前请求。如果不是，则返回 HTTP 429 - Too Many Requests（默认情况下）状态。</p>
<p>此过滤器采用可选的 keyResolver 参数和特定于速率限制器的参数（本节稍后介绍）。</p>
<p>keyResolver 是一个实现 KeyResolver 接口的 bean。在配置中，使用 SpEL 按名称引用 bean。 #{@myKeyResolver} 是一个 SpEL 表达式，它引用名为 myKeyResolver 的 bean。以下清单显示了 KeyResolver 接口：</p>
<p><strong>Example 30. KeyResolver.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">Mono&lt;String&gt; <span class="title">resolve</span><span class="params">(ServerWebExchange exchange)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KeyResolver 接口让可插拔策略派生出限制请求的密钥。在未来的里程碑版本中，将有一些 KeyResolver 实现。</p>
<p>KeyResolver 的默认实现是 PrincipalNameKeyResolver，它从 ServerWebExchange 检索 Principal 并调用 Principal.getName()。</p>
<p>默认情况下，如果 KeyResolver 未找到密钥，则拒绝请求。您可以通过设置 spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key（true 或 false）和 spring.cloud.gateway.filter.request-rate-limiter.empty-key 来调整此行为-状态码属性。</p>
<p>RequestRateLimiter 不能使用“快捷方式”表示法进行配置。以下示例无效：</p>
<p><strong>Example 31. application.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># INVALID SHORTCUT CONFIGURATION</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[0].filters[0]</span>=<span class="string">RequestRateLimiter=2, 2, #&#123;@userkeyresolver&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-10-1-The-Redis-RateLimiter"><a href="#6-10-1-The-Redis-RateLimiter" class="headerlink" title="6.10.1. The Redis RateLimiter"></a>6.10.1. The Redis RateLimiter</h4><p>Redis 实现基于在 Stripe 完成的工作。它需要使用 spring-boot-starter-data-redis-reactive Spring Boot starter。</p>
<p>使用的算法是令牌桶算法。</p>
<p>redis-rate-limiter.replenishRate 属性是您希望允许用户每秒执行多少请求，而没有任何丢弃的请求。这是令牌桶填充的速率。</p>
<p>redis-rate-limiter.burstCapacity 属性是允许用户在一秒内执行的最大请求数。这是令牌桶可以容纳的令牌数量。将此值设置为零会阻止所有请求。</p>
<p>redis-rate-limiter.requestedTokens 属性是请求花费多少令牌。这是每个请求从存储桶中获取的令牌数量，默认为 1。</p>
<p>稳定速率是通过在replyRate 和burstCapacity 中设置相同的值来实现的。通过将burstCapacity 设置为高于replyRate，可以允许临时突发。在这种情况下，需要允许速率限制器在突发之间有一段时间（根据replyRate），因为两个连续的突发将导致请求丢失（HTTP 429 - Too Many Requests）。以下清单配置了 redis-rate-limiter：</p>
<p>低于 1 请求/秒的速率限制是通过将replyRate 设置为所需的请求数量、将requestedTokens 设置为以秒为单位的时间跨度以及将burstCapacity 设置为replyRate 和requestedTokens 的乘积来实现的，例如设置replyRate=1、requestedTokens=60 和burstCapacity=60 将导致1 请求/分钟的限制。</p>
<p><strong>Example 32. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">requestratelimiter_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">20</span></span><br><span class="line">            <span class="attr">redis-rate-limiter.requestedTokens:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>以下示例在 Java 中配置 KeyResolver：</p>
<p><strong>Example 33. Config.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">KeyResolver <span class="title">userKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这定义了每个用户 10 的请求速率限制。允许突发 20 个，但在下一秒，只有 10 个请求可用。 KeyResolver 是一个简单的获取用户请求参数的方法（注意，不推荐用于生产）。</p>
<p>您还可以将速率限制器定义为实现 RateLimiter 接口的 bean。在配置中，您可以使用 SpEL 按名称引用 bean。 #{@myRateLimiter} 是一个 SpEL 表达式，它引用名为 myRateLimiter 的 bean。下面的清单定义了一个速率限制器，它使用在前面的清单中定义的 KeyResolver：</p>
<p><strong>Example 34. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">requestratelimiter_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">rate-limiter:</span> <span class="string">&quot;#&#123;@myRateLimiter&#125;&quot;</span></span><br><span class="line">            <span class="attr">key-resolver:</span> <span class="string">&quot;#&#123;@userKeyResolver&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-11-RedirectTo-网关过滤器工厂"><a href="#6-11-RedirectTo-网关过滤器工厂" class="headerlink" title="6.11. RedirectTo 网关过滤器工厂"></a>6.11. RedirectTo 网关过滤器工厂</h3><p>RedirectTo GatewayFilter 工厂接受两个参数，status 和 url。 status 参数应该是一个 300 系列的重定向 HTTP 代码，比如 301。url 参数应该是一个有效的 URL。这是 Location 标头的值。对于相对重定向，您应该使用 uri: no://op 作为路由定义的 uri。以下清单配置了一个 RedirectTo GatewayFilter：</p>
<p><strong>Example 35. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">prefixpath_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RedirectTo=302,</span> <span class="string">https://acme.org</span></span><br></pre></td></tr></table></figure>

<p>这将发送带有 Location:<a href="https://acme.org/">https://acme.org</a> 标头的状态 302 以执行重定向。</p>
<h3 id="6-12-RemoveRequestHeader-网关过滤器工厂"><a href="#6-12-RemoveRequestHeader-网关过滤器工厂" class="headerlink" title="6.12. RemoveRequestHeader 网关过滤器工厂"></a>6.12. RemoveRequestHeader 网关过滤器工厂</h3><p>RemoveRequestHeader GatewayFilter 工厂采用 name 参数。它是要删除的标题的名称。以下清单配置了 RemoveRequestHeader GatewayFilter：</p>
<p><strong>Example 36. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">removerequestheader_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RemoveRequestHeader=X-Request-Foo</span></span><br></pre></td></tr></table></figure>

<p>这会在向下游发送之前删除 X-Request-Foo 标头。</p>
<h3 id="6-13-RemoveResponseHeader-网关过滤器工厂"><a href="#6-13-RemoveResponseHeader-网关过滤器工厂" class="headerlink" title="6.13. RemoveResponseHeader 网关过滤器工厂"></a>6.13. RemoveResponseHeader 网关过滤器工厂</h3><p>RemoveResponseHeader GatewayFilter 工厂采用 name 参数。它是要删除的标题的名称。以下清单配置了 RemoveResponseHeader GatewayFilter：</p>
<p><strong>Example 37. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">removeresponseheader_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RemoveResponseHeader=X-Response-Foo</span></span><br></pre></td></tr></table></figure>

<p>这将在响应返回到网关客户端之前从响应中删除 X-Response-Foo 标头。</p>
<p>要删除任何类型的敏感标头，您应该为您可能想要这样做的任何路由配置此过滤器。此外，您可以使用 spring.cloud.gateway.default-filters 配置一次此过滤器，并将其应用于所有路由。</p>
<h3 id="6-14-RemoveRequestParameter-网关过滤器工厂"><a href="#6-14-RemoveRequestParameter-网关过滤器工厂" class="headerlink" title="6.14. RemoveRequestParameter 网关过滤器工厂"></a>6.14. RemoveRequestParameter 网关过滤器工厂</h3><p>RemoveRequestParameter GatewayFilter 工厂采用名称参数。它是要删除的查询参数的名称。以下示例配置 RemoveRequestParameter GatewayFilter：</p>
<p><strong>Example 38. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">removerequestparameter_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RemoveRequestParameter=red</span></span><br></pre></td></tr></table></figure>

<p>这将在向下游发送之前删除red参数。</p>
<h3 id="6-15-RewritePath-网关过滤器工厂"><a href="#6-15-RewritePath-网关过滤器工厂" class="headerlink" title="6.15. RewritePath 网关过滤器工厂"></a>6.15. RewritePath 网关过滤器工厂</h3><p>RewritePath GatewayFilter 工厂采用路径正则表达式参数和替换参数。这使用 Java 正则表达式来灵活地重写请求路径。以下清单配置了 RewritePath GatewayFilter：</p>
<p><strong>Example 39. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">rewritepath_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/red/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RewritePath=/red/?(?&lt;segment&gt;.*),</span> <span class="string">/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于 /red/blue 的请求路径，这会在发出下游请求之前将路径设置为 /blue。请注意，由于 YAML 规范，$ 应替换为 $\。</p>
<h3 id="6-16-RewriteLocationResponseHeader-网关过滤器工厂"><a href="#6-16-RewriteLocationResponseHeader-网关过滤器工厂" class="headerlink" title="6.16. RewriteLocationResponseHeader 网关过滤器工厂"></a>6.16. RewriteLocationResponseHeader 网关过滤器工厂</h3><p>RewriteLocationResponseHeader GatewayFilter 工厂修改 Location 响应头的值，通常是为了摆脱后端特定的细节。它采用 stripVersionMode、locationHeaderName、hostValue 和 protocolsRegex 参数。以下清单配置了 RewriteLocationResponseHeader GatewayFilter：</p>
<p><strong>Example 40. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">rewritelocationresponseheader_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RewriteLocationResponseHeader=AS_IN_REQUEST,</span> <span class="string">Location,</span> <span class="string">,</span></span><br></pre></td></tr></table></figure>

<p>例如，对于POST api.example.com/some/object/name的请求，object-service.prod.example.net/v2/some/object/id的Location响应头值改写为api.example.com/some/object/id。</p>
<p>stripVersionMode 参数具有以下可能的值：NEVER_STRIP、AS_IN_REQUEST（默认）和 ALWAYS_STRIP。</p>
<ul>
<li><code>NEVER_STRIP</code>: 即使原始请求路径不包含版本，也不会剥离版本。</li>
<li><code>AS_IN_REQUEST</code> 仅当原始请求路径不包含版本时才会剥离版本。</li>
<li><code>ALWAYS_STRIP</code> 版本总是被剥离，即使原始请求路径包含版本。</li>
</ul>
<p>hostValue 参数（如果提供）用于替换响应 Location 标头的 host:port 部分。如果未提供，则使用 Host 请求标头的值。</p>
<p>protocolRegex 参数必须是有效的正则表达式字符串，与协议名称匹配。如果不匹配，则过滤器不执行任何操作。默认为 http|https|ftp|ftps。</p>
<h3 id="6-17-RewriteResponseHeader-网关过滤器工厂"><a href="#6-17-RewriteResponseHeader-网关过滤器工厂" class="headerlink" title="6.17. RewriteResponseHeader 网关过滤器工厂"></a>6.17. RewriteResponseHeader 网关过滤器工厂</h3><p>RewriteResponseHeader GatewayFilter 工厂采用名称、正则表达式和替换参数。它使用 Java 正则表达式来灵活地重写响应头值。以下示例配置 RewriteResponseHeader GatewayFilter：</p>
<p><strong>Example 41. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">rewriteresponseheader_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RewriteResponseHeader=X-Response-Red,</span> <span class="string">,</span> <span class="string">password=[^&amp;]+,</span> <span class="string">password=***</span></span><br></pre></td></tr></table></figure>

<p>对于 /42?user=ford&amp;password=omg!what&amp;flag=true 的 header 值，在发出下游请求后设置为 /42?user=ford&amp;password=***&amp;flag=true。由于 YAML 规范，您必须使用 $\ 来表示 $。</p>
<h3 id="6-18-SaveSession-网关过滤器工厂"><a href="#6-18-SaveSession-网关过滤器工厂" class="headerlink" title="6.18. SaveSession 网关过滤器工厂"></a>6.18. SaveSession 网关过滤器工厂</h3><p>SaveSession GatewayFilter 工厂在向下游转发调用之前强制执行 WebSession::save 操作。这在将 Spring Session 之类的东西与惰性数据存储一起使用时特别有用，并且您需要确保在进行转发调用之前已保存会话状态。以下示例配置 SaveSession GatewayFilter：</p>
<p><strong>Example 42. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">save_session</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/foo/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SaveSession</span></span><br></pre></td></tr></table></figure>

<p>如果您将 Spring Security 与 Spring Session 集成并希望确保安全详细信息已转发到远程进程，那么这很关键。</p>
<h3 id="6-19-SecureHeaders-网关过滤器工厂"><a href="#6-19-SecureHeaders-网关过滤器工厂" class="headerlink" title="6.19. SecureHeaders 网关过滤器工厂"></a>6.19. SecureHeaders 网关过滤器工厂</h3><p>根据本博客文章中提出的建议，SecureHeaders GatewayFilter 工厂向响应添加了许多标头。</p>
<p>添加了以下header（显示为默认值）：</p>
<ul>
<li><code>X-Xss-Protection:1 (mode=block</code>)</li>
<li><code>Strict-Transport-Security (max-age=631138519</code>)</li>
<li><code>X-Frame-Options (DENY)</code></li>
<li><code>X-Content-Type-Options (nosniff)</code></li>
<li><code>Referrer-Policy (no-referrer)</code></li>
<li><code>Content-Security-Policy (default-src &#39;self&#39; https:; font-src &#39;self&#39; https: data:; img-src &#39;self&#39; https: data:; object-src &#39;none&#39;; script-src https:; style-src &#39;self&#39; https: &#39;unsafe-inline)&#39;</code></li>
<li><code>X-Download-Options (noopen)</code></li>
<li><code>X-Permitted-Cross-Domain-Policies (none)</code></li>
</ul>
<p>要更改默认值，请在 spring.cloud.gateway.filter.secure-headers 命名空间中设置适当的属性。以下属性可用：</p>
<ul>
<li><code>xss-protection-header</code></li>
<li><code>strict-transport-security</code></li>
<li><code>x-frame-options</code></li>
<li><code>x-content-type-options</code></li>
<li><code>referrer-policy</code></li>
<li><code>content-security-policy</code></li>
<li><code>x-download-options</code></li>
<li><code>x-permitted-cross-domain-policies</code></li>
</ul>
<p>要禁用默认值，请使用逗号分隔值设置 spring.cloud.gateway.filter.secure-headers.disable 属性。以下示例显示了如何执行此操作：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.gateway.filter.secure-headers.disable</span>=<span class="string">x-frame-options,strict-transport-security</span></span><br></pre></td></tr></table></figure>

<h3 id="6-20-SetPath-网关过滤器工厂"><a href="#6-20-SetPath-网关过滤器工厂" class="headerlink" title="6.20. SetPath 网关过滤器工厂"></a>6.20. SetPath 网关过滤器工厂</h3><p>SetPath GatewayFilter 工厂采用路径模板参数。它提供了一种通过允许路径的模板化段来操作请求路径的简单方法。这使用了 Spring Framework 中的 URI 模板。允许多个匹配段。以下示例配置 SetPath GatewayFilter：</p>
<p><strong>Example 43. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">setpath_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/red/&#123;segment&#125;</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SetPath=/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于 /red/blue 的请求路径，这会在发出下游请求之前将路径设置为 /blue。</p>
<h3 id="6-21-SetRequestHeader-网关过滤器工厂"><a href="#6-21-SetRequestHeader-网关过滤器工厂" class="headerlink" title="6.21. SetRequestHeader 网关过滤器工厂"></a>6.21. SetRequestHeader 网关过滤器工厂</h3><p>SetRequestHeader GatewayFilter 工厂采用名称和值参数。以下清单配置了 SetRequestHeader GatewayFilter：</p>
<p><strong>Example 44. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">setrequestheader_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SetRequestHeader=X-Request-Red,</span> <span class="string">Blue</span></span><br></pre></td></tr></table></figure>

<p>此 GatewayFilter 替换（而不是添加）具有给定名称的所有标头。因此，如果下游服务器以 X-Request-Red:1234 响应，这将替换为 X-Request-Red:Blue，这是下游服务将收到的。</p>
<p>SetRequestHeader 知道用于匹配路径或主机的 URI 变量。 URI 变量可以在值中使用并在运行时扩展。以下示例配置了一个使用变量的 SetRequestHeader GatewayFilter：</p>
<p><strong>Example 45. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">setrequestheader_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Host:</span> &#123;<span class="string">segment</span>&#125;<span class="string">.myhost.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SetRequestHeader=foo,</span> <span class="string">bar-&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-22-SetResponseHeader-网关过滤器工厂"><a href="#6-22-SetResponseHeader-网关过滤器工厂" class="headerlink" title="6.22. SetResponseHeader 网关过滤器工厂"></a>6.22. SetResponseHeader 网关过滤器工厂</h3><p>SetResponseHeader GatewayFilter 工厂采用名称和值参数。以下清单配置了 SetResponseHeader GatewayFilter：</p>
<p><strong>Example 46. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">setresponseheader_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SetResponseHeader=X-Response-Red,</span> <span class="string">Blue</span></span><br></pre></td></tr></table></figure>

<p>此 GatewayFilter 替换（而不是添加）具有给定名称的所有标头。因此，如果下游服务器以 X-Response-Red:1234 响应，这将替换为 X-Response-Red:Blue，这是网关客户端将收到的。</p>
<p>SetResponseHeader 知道用于匹配路径或主机的 URI 变量。 URI 变量可以在值中使用，并将在运行时扩展。以下示例配置使用变量的 SetResponseHeader GatewayFilter：</p>
<p><strong>Example 47. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">setresponseheader_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Host:</span> &#123;<span class="string">segment</span>&#125;<span class="string">.myhost.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SetResponseHeader=foo,</span> <span class="string">bar-&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-23-SetStatus-网关过滤器工厂"><a href="#6-23-SetStatus-网关过滤器工厂" class="headerlink" title="6.23. SetStatus 网关过滤器工厂"></a>6.23. SetStatus 网关过滤器工厂</h3><p>SetStatus GatewayFilter 工厂采用单个参数 status。它必须是有效的 Spring HttpStatus。它可能是整数值 404 或枚举的字符串表示形式：NOT_FOUND。以下清单配置了 SetStatus GatewayFilter：</p>
<p><strong>Example 48. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">setstatusstring_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SetStatus=BAD_REQUEST</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">setstatusint_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SetStatus=401</span></span><br></pre></td></tr></table></figure>

<p>无论哪种情况，响应的 HTTP 状态都设置为 401。</p>
<p>您可以配置 SetStatus GatewayFilter 以在响应的标头中返回来自代理请求的原始 HTTP 状态代码。如果配置了以下属性，则将标头添加到响应中：</p>
<p><strong>Example 49. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">set-status:</span></span><br><span class="line">        <span class="attr">original-status-header-name:</span> <span class="string">original-http-status</span></span><br></pre></td></tr></table></figure>

<h3 id="6-24-StripPrefix-网关过滤器工厂"><a href="#6-24-StripPrefix-网关过滤器工厂" class="headerlink" title="6.24. StripPrefix 网关过滤器工厂"></a>6.24. StripPrefix 网关过滤器工厂</h3><p>StripPrefix GatewayFilter 工厂采用一个参数，parts。部分参数指示在将请求发送到下游之前要从请求中剥离的路径中的部分数。以下清单配置了 StripPrefix GatewayFilter：</p>
<p><strong>Example 50. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">nameRoot</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://nameservice</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/name/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">StripPrefix=2</span></span><br></pre></td></tr></table></figure>

<p>当通过网关向 /name/blue/red 发出请求时，对 nameservice 发出的请求看起来像 nameservice/red。</p>
<h3 id="6-25-Retry网关过滤器工厂"><a href="#6-25-Retry网关过滤器工厂" class="headerlink" title="6.25. Retry网关过滤器工厂"></a>6.25. Retry网关过滤器工厂</h3><p>Retry GatewayFilter 工厂支持以下参数：</p>
<ul>
<li><code>retries</code>: 应该尝试的重试次数。</li>
<li><code>statuses</code>: 应该重试的 HTTP 状态码，用 org.springframework.http.HttpStatus 表示。</li>
<li><code>methods</code>: 应该重试的 HTTP 方法，使用 org.springframework.http.HttpMethod 表示。</li>
<li><code>series</code>: 要重试的一系列状态码，用 org.springframework.http.HttpStatus.Series 表示。</li>
<li><code>exceptions</code>: 应该重试的抛出异常的列表。</li>
<li><code>backoff</code>: 为重试配置的指数backoff。在 firstBackoff * (factor ^ n) 的backoff间隔后执行重试，其中 n 是迭代。如果配置了 maxBackoff，则应用的最大backoff限制为 maxBackoff。如果 basedOnPreviousValue 为真，则使用 prevBackoff * factor计算回退。</li>
</ul>
<p>如果启用，则为重试过滤器配置以下默认值：</p>
<ul>
<li><code>retries</code>: 三次</li>
<li><code>series</code>: 5XX系列</li>
<li><code>methods</code>: GET 方法</li>
<li><code>exceptions</code>: IOException 和 TimeoutException</li>
<li><code>backoff</code>: disabled</li>
</ul>
<p>以下清单配置了重试网关过滤器：</p>
<p><strong>Example 51. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">retry_test</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:8080/flakey</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Host=*.retry.com</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Retry</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">            <span class="attr">statuses:</span> <span class="string">BAD_GATEWAY</span></span><br><span class="line">            <span class="attr">methods:</span> <span class="string">GET,POST</span></span><br><span class="line">            <span class="attr">backoff:</span></span><br><span class="line">              <span class="attr">firstBackoff:</span> <span class="string">10ms</span></span><br><span class="line">              <span class="attr">maxBackoff:</span> <span class="string">50ms</span></span><br><span class="line">              <span class="attr">factor:</span> <span class="number">2</span></span><br><span class="line">              <span class="attr">basedOnPreviousValue:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>使用带有 forward: 前缀的重试过滤器时，应仔细编写目标端点，以便在出现错误时不会执行任何可能导致响应被发送到客户端并提交的操作。例如，如果目标端点是带注释的控制器，则目标控制器方法不应返回带有错误状态代码的 ResponseEntity。相反，它应该抛出异常或发出错误信号（例如，通过 Mono.error(ex) 返回值），重试过滤器可以配置为通过重试来处理。</p>
<p>将重试过滤器与任何带有正文的 HTTP 方法一起使用时，正文将被缓存并且网关将受到内存限制。正文缓存在由 ServerWebExchangeUtils.CACHED_REQUEST_BODY_ATTR 定义的请求属性中。对象的类型是 org.springframework.core.io.buffer.DataBuffer。</p>
<h3 id="6-26-RequestSize-网关过滤器工厂"><a href="#6-26-RequestSize-网关过滤器工厂" class="headerlink" title="6.26. RequestSize 网关过滤器工厂"></a>6.26. RequestSize 网关过滤器工厂</h3><p>当请求大小大于允许的限制时，RequestSize GatewayFilter 工厂可以限制请求到达下游服务。过滤器采用 maxSize 参数。 maxSize 是一个 `DataSize 类型，因此值可以定义为一个数字，后跟一个可选的 DataUnit 后缀，例如 ‘KB’ 或 ‘MB’。字节的默认值为“B”。它是以字节为单位定义的请求的允许大小限制。以下清单配置了 RequestSize GatewayFilter：</p>
<p><strong>Example 52. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">request_size_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:8080/upload</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/upload</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestSize</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">maxSize:</span> <span class="number">5000000</span></span><br></pre></td></tr></table></figure>

<p>当请求因大小而被拒绝时，RequestSize GatewayFilter 工厂将响应状态设置为 413 Payload Too Large 并带有一个额外的标头 errorMessage。以下示例显示了这样的错误消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">errorMessage` : `Request size is larger than permissible limit. Request size is 6.0 MB where permissible limit is 5.0 MB</span><br></pre></td></tr></table></figure>

<p>如果未在路由定义中作为过滤器参数提供，则默认请求大小设置为 5 MB。</p>
<h3 id="6-27-SetRequestHostHeader-网关过滤器工厂"><a href="#6-27-SetRequestHostHeader-网关过滤器工厂" class="headerlink" title="6.27. SetRequestHostHeader 网关过滤器工厂"></a>6.27. SetRequestHostHeader 网关过滤器工厂</h3><p>在某些情况下，可能需要覆盖主机标头。在这种情况下， SetRequestHostHeader GatewayFilter 工厂可以用指定的值替换现有的主机头。过滤器采用主机参数。以下清单配置了 SetRequestHostHeader GatewayFilter：</p>
<p><strong>Example 53. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">set_request_host_header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:8080/headers</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/headers</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SetRequestHostHeader</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">host:</span> <span class="string">example.org</span></span><br></pre></td></tr></table></figure>

<p>SetRequestHostHeader GatewayFilter 工厂用 example.org 替换主机标头的值。</p>
<h3 id="6-28-修改请求正文-GatewayFilter-Factory"><a href="#6-28-修改请求正文-GatewayFilter-Factory" class="headerlink" title="6.28.修改请求正文 GatewayFilter Factory"></a>6.28.修改请求正文 GatewayFilter Factory</h3><p>您可以使用 ModifyRequestBody 过滤器过滤器在请求正文被网关发送到下游之前对其进行修改。</p>
<p>此过滤器只能通过使用 Java DSL 进行配置。</p>
<p>以下清单显示了如何修改请求正文 GatewayFilter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">routes</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.routes()</span><br><span class="line">        .route(<span class="string">&quot;rewrite_request_obj&quot;</span>, r -&gt; r.host(<span class="string">&quot;*.rewriterequestobj.org&quot;</span>)</span><br><span class="line">            .filters(f -&gt; f.prefixPath(<span class="string">&quot;/httpbin&quot;</span>)</span><br><span class="line">                .modifyRequestBody(String.class, Hello.class, MediaType.APPLICATION_JSON_VALUE,</span><br><span class="line">                    (exchange, s) -&gt; <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> Hello(s.toUpperCase())))).uri(uri))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果请求没有正文，则 RewriteFilter 将传递 null。应返回 Mono.empty() 以在请求中分配缺失的主体。</p>
<h3 id="6-29-修改响应体-GatewayFilter-工厂"><a href="#6-29-修改响应体-GatewayFilter-工厂" class="headerlink" title="6.29.修改响应体 GatewayFilter 工厂"></a>6.29.修改响应体 GatewayFilter 工厂</h3><p>您可以使用 ModifyResponseBody 过滤器在响应正文发送回客户端之前对其进行修改。</p>
<p>此过滤器只能通过使用 Java DSL 进行配置。</p>
<p>以下清单显示了如何修改响应正文 GatewayFilter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">routes</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.routes()</span><br><span class="line">        .route(<span class="string">&quot;rewrite_response_upper&quot;</span>, r -&gt; r.host(<span class="string">&quot;*.rewriteresponseupper.org&quot;</span>)</span><br><span class="line">            .filters(f -&gt; f.prefixPath(<span class="string">&quot;/httpbin&quot;</span>)</span><br><span class="line">                .modifyResponseBody(String.class, String.class,</span><br><span class="line">                    (exchange, s) -&gt; Mono.just(s.toUpperCase()))).uri(uri))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果响应没有正文，则 RewriteFilter 将传递 null。应返回 Mono.empty() 以在响应中分配缺失的主体。</p>
<h3 id="6-30-令牌Relay网关过滤器工厂"><a href="#6-30-令牌Relay网关过滤器工厂" class="headerlink" title="6.30.令牌Relay网关过滤器工厂"></a>6.30.令牌Relay网关过滤器工厂</h3><p>令牌中继是 OAuth2 消费者充当客户端并将传入令牌转发到传出资源请求的地方。消费者可以是纯客户端（如 SSO 应用程序）或资源服务器。</p>
<p>Spring Cloud Gateway 可以将 OAuth2 访问令牌下游转发到它正在代理的服务。要将此功能添加到网关，您需要像这样添加 TokenRelayGatewayFilterFactory：</p>
<p><strong>App.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.routes()</span><br><span class="line">            .route(<span class="string">&quot;resource&quot;</span>, r -&gt; r.path(<span class="string">&quot;/resource&quot;</span>)</span><br><span class="line">                    .filters(f -&gt; f.tokenRelay())</span><br><span class="line">                    .uri(<span class="string">&quot;http://localhost:9000&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或这个</p>
<p><strong>application.yaml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">resource</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:9000</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/resource</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">TokenRelay=</span></span><br></pre></td></tr></table></figure>

<p>并且它将（除了登录用户并获取令牌之外）将身份验证令牌下游传递给服务（在本例中为 /resource）。</p>
<p>要为 Spring Cloud Gateway 启用此功能，请添加以下依赖项</p>
<ul>
<li><code>org.springframework.boot:spring-boot-starter-oauth2-client</code></li>
</ul>
<p>它是如何工作的？ {githubmaster}/src/main/java/org/springframework/cloud/gateway/security/TokenRelayGatewayFilterFactory.java[filter] 从当前已验证的用户中提取访问令牌，并将其放入下游请求的请求头中。</p>
<p>只有在设置了正确的 spring.security.oauth2.client.* 属性时才会创建 TokenRelayGatewayFilterFactory bean，这将触发 ReactiveClientRegistrationRepository bean 的创建。</p>
<p>TokenRelayGatewayFilterFactory 使用的 ReactiveOAuth2AuthorizedClientService 的默认实现使用内存数据存储。如果您需要更强大的解决方案，您将需要提供自己的实现 ReactiveOAuth2AuthorizedClientService。</p>
<h3 id="6-31-默认过滤器"><a href="#6-31-默认过滤器" class="headerlink" title="6.31.默认过滤器"></a>6.31.默认过滤器</h3><p>要添加过滤器并将其应用于所有路由，您可以使用 spring.cloud.gateway.default-filters。此属性采用过滤器列表。以下清单定义了一组默认过滤器：</p>
<p><strong>Example 54. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddResponseHeader=X-Response-Default-Red,</span> <span class="string">Default-Blue</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PrefixPath=/httpbin</span></span><br></pre></td></tr></table></figure>

<h2 id="7-全局过滤器"><a href="#7-全局过滤器" class="headerlink" title="7. 全局过滤器"></a>7. 全局过滤器</h2><p>GlobalFilter 接口与 GatewayFilter 具有相同的签名。这些是有条件地应用于所有路由的特殊过滤器。</p>
<p>在未来的里程碑版本中，此界面及其用法可能会发生变化。</p>
<h3 id="7-1-组合全局过滤器和网关过滤器排序"><a href="#7-1-组合全局过滤器和网关过滤器排序" class="headerlink" title="7.1.组合全局过滤器和网关过滤器排序"></a>7.1.组合全局过滤器和网关过滤器排序</h3><p>当请求与路由匹配时，过滤 Web 处理程序会将 GlobalFilter 的所有实例和 GatewayFilter 的所有特定于路由的实例添加到过滤器链中。这个组合过滤器链由 org.springframework.core.Ordered 接口排序，您可以通过实现 getOrder() 方法设置该接口。</p>
<p>由于 Spring Cloud Gateway 区分过滤器逻辑执行的“pre”和“post”阶段，具有最高优先级的过滤器是“pre”阶段的第一个，“post”阶段的最后一个——阶段。</p>
<p>以下清单配置了过滤器链：</p>
<p><strong>Example 55. ExampleConfiguration.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GlobalFilter <span class="title">customFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomGlobalFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;custom global filter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-Forward路由过滤器"><a href="#7-2-Forward路由过滤器" class="headerlink" title="7.2.Forward路由过滤器"></a>7.2.Forward路由过滤器</h3><p>ForwardRoutingFilter 在交换属性 ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR 中查找 URI。如果 URL 有转发方案（例如 forward:///localendpoint），它会使用 Spring DispatcherHandler 来处理请求。请求 URL 的路径部分被转发 URL 中的路径覆盖。未修改的原始 URL 将附加到 ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR 属性中的列表中。</p>
<h3 id="7-3-ReactiveLoadBalancerClientFilter"><a href="#7-3-ReactiveLoadBalancerClientFilter" class="headerlink" title="7.3. ReactiveLoadBalancerClientFilter"></a>7.3. ReactiveLoadBalancerClientFilter</h3><p>ReactiveLoadBalancerClientFilter 在名为 ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR 的交换属性中查找 URI。如果 URL 具有 lb 方案（例如 lb://myservice），则它使用 Spring Cloud ReactorLoadBalancer 将名称（在此示例中为 myservice）解析为实际主机和端口，并替换同一属性中的 URI。未修改的原始 URL 将附加到 ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR 属性中的列表中。过滤器还会查看 ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR 属性以查看它是否等于 lb。如果是，则应用相同的规则。以下清单配置了一个 ReactiveLoadBalancerClientFilter：</p>
<p><strong>Example 56. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">myRoute</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/service/**</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，当 ReactorLoadBalancer 找不到服务实例时，会返回 503。您可以通过设置 spring.cloud.gateway.loadbalancer.use404=true 将网关配置为返回 404。</p>
<p>从 ReactiveLoadBalancerClientFilter 返回的 ServiceInstance 的 isSecure 值会覆盖向网关发出的请求中指定的方案。例如，如果请求通过 HTTPS 进入网关，但 ServiceInstance 指示它不安全，则通过 HTTP 发出下游请求。相反的情况也可以适用。但是，如果在网关配置中为路由指定了 GATEWAY_SCHEME_PREFIX_ATTR，则前缀将被剥离，并且来自路由 URL 的结果方案将覆盖 ServiceInstance 配置。</p>
<h3 id="7-4-Netty-路由过滤器"><a href="#7-4-Netty-路由过滤器" class="headerlink" title="7.4. Netty 路由过滤器"></a>7.4. Netty 路由过滤器</h3><p>如果位于 ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR 交换属性中的 URL 具有 http 或 https 方案，则 Netty 路由过滤器运行。它使用 Netty HttpClient 发出下游代理请求。响应放在 ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR 交换属性中，以供稍后过滤器使用。 （还有一个实验性的 WebClientHttpRoutingFilter 执行相同的功能但不需要 Netty。）</p>
<h3 id="7-5-Netty-写响应过滤器"><a href="#7-5-Netty-写响应过滤器" class="headerlink" title="7.5. Netty 写响应过滤器"></a>7.5. Netty 写响应过滤器</h3><p>如果 ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR 交换属性中存在 Netty HttpClientResponse，则 NettyWriteResponseFilter 运行。它在所有其他过滤器完成后运行，并将代理响应写回网关客户端响应。 （还有一个实验性的 WebClientWriteResponseFilter 可以执行相同的功能，但不需要 Netty。）</p>
<h3 id="7-6-RouteToRequestUrl-过滤器"><a href="#7-6-RouteToRequestUrl-过滤器" class="headerlink" title="7.6. RouteToRequestUrl 过滤器"></a>7.6. RouteToRequestUrl 过滤器</h3><p>如果 ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR 交换属性中存在 Route 对象，则 RouteToRequestUrlFilter 运行。它基于请求 URI 创建一个新的 URI，但使用 Route 对象的 URI 属性进行更新。新 URI 放置在 ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR 交换属性中。</p>
<p>如果 URI 具有方案前缀，例如 lb:ws://serviceid，则 lb 方案将从 URI 中剥离并放置在 ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR 中，以便稍后在过滤器链中使用。</p>
<h3 id="7-7-Websocket-路由过滤器"><a href="#7-7-Websocket-路由过滤器" class="headerlink" title="7.7. Websocket 路由过滤器"></a>7.7. Websocket 路由过滤器</h3><p>如果位于 ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR 交换属性中的 URL 具有 ws 或 wss 方案，则 websocket 路由过滤器运行。它使用 Spring WebSocket 基础结构向下游转发 websocket 请求。</p>
<p>您可以通过在 URI 前加上 lb 来对 websockets 进行负载平衡，例如 lb:ws://serviceid。</p>
<p>如果你使用 SockJS 作为普通 HTTP 的后备，你应该配置一个普通的 HTTP 路由以及 websocket 路由。</p>
<p>以下清单配置了一个 websocket 路由过滤器：</p>
<p><strong>Example 57. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="comment"># SockJS route</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">websocket_sockjs_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:3001</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/websocket/info/**</span></span><br><span class="line">      <span class="comment"># Normal Websocket route</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">websocket_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">ws://localhost:3001</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/websocket/**</span></span><br></pre></td></tr></table></figure>

<h3 id="7-8-网关指标过滤器"><a href="#7-8-网关指标过滤器" class="headerlink" title="7.8.网关指标过滤器"></a>7.8.网关指标过滤器</h3><p>要启用网关指标，请将 spring-boot-starter-actuator 添加为项目依赖项。然后，默认情况下，只要属性 spring.cloud.gateway.metrics.enabled 未设置为 false，网关指标过滤器就会运行。此过滤器添加了一个名为 gateway.requests 的计时器指标，并带有以下标签：</p>
<ul>
<li><code>routeId</code>: 路由标识。</li>
<li><code>routeUri</code>: API 路由到的 URI。</li>
<li><code>outcome</code>: 结果，由 HttpStatus.Series 分类。</li>
<li><code>status</code>: 返回给客户端的请求的 HTTP 状态。</li>
<li><code>httpStatusCode</code>: 返回给客户端的请求的 HTTP 状态。</li>
<li><code>httpMethod</code>: 用于请求的 HTTP 方法。</li>
</ul>
<p>然后可以从 /actuator/metrics/gateway.requests 抓取这些指标，并且可以轻松地与 Prometheus 集成以创建 Grafana 仪表板。</p>
<p>要启用 prometheus 端点，请将 micrometer-registry-prometheus 添加为项目依赖项。</p>
<h3 id="7-9-将交换标记为已路由"><a href="#7-9-将交换标记为已路由" class="headerlink" title="7.9.将交换标记为已路由"></a>7.9.将交换标记为已路由</h3><p>网关路由 ServerWebExchange 后，它通过将 gatewayAlreadyRouted 添加到交换属性来将该交换标记为“已路由”。一旦请求被标记为路由，其他路由过滤器将不会再次路由该请求，实质上是跳过过滤器。有一些方便的方法可用于将交换标记为已路由或检查交换是否已被路由。</p>
<ul>
<li>ServerWebExchangeUtils.isAlreadyRouted 接受一个 ServerWebExchange 对象并检查它是否已被“路由”。</li>
<li>ServerWebExchangeUtils.setAlreadyRouted 接受一个 ServerWebExchange 对象并将其标记为“已路由”。</li>
</ul>
<h2 id="8-HttpHeadersFilters"><a href="#8-HttpHeadersFilters" class="headerlink" title="8. HttpHeadersFilters"></a>8. HttpHeadersFilters</h2><p>HttpHeadersFilters 在向下游发送请求之前应用于请求，例如在 NettyRoutingFilter 中。</p>
<h3 id="8-1-Forwarded-Headers过滤器"><a href="#8-1-Forwarded-Headers过滤器" class="headerlink" title="8.1.Forwarded Headers过滤器"></a>8.1.Forwarded Headers过滤器</h3><p>Forwarded Headers过滤器创建转发头以发送到下游服务。它将当前请求的 Host 标头、方案和端口添加到任何现有的 Forwarded 标头中。</p>
<h3 id="8-2-RemoveHopByHop-header过滤器"><a href="#8-2-RemoveHopByHop-header过滤器" class="headerlink" title="8.2. RemoveHopByHop header过滤器"></a>8.2. RemoveHopByHop header过滤器</h3><p>RemoveHopByHop 标头过滤器从转发的请求中删除标头。删除的默认标头列表来自 IETF。</p>
<p>默认删除的headers是：</p>
<ul>
<li>Connection</li>
<li>Keep-Alive</li>
<li>Proxy-Authenticate</li>
<li>Proxy-Authorization</li>
<li>TE</li>
<li>Trailer</li>
<li>Transfer-Encoding</li>
<li>Upgrade</li>
</ul>
<p>要更改此设置，请将 spring.cloud.gateway.filter.remove-hop-by-hop.headers 属性设置为要删除的标头名称列表。</p>
<h3 id="8-3-XForwarded-header过滤器"><a href="#8-3-XForwarded-header过滤器" class="headerlink" title="8.3. XForwarded header过滤器"></a>8.3. XForwarded header过滤器</h3><p>XForwarded 标头过滤器创建各种 X-Forwarded-* 标头以发送到下游服务。它使用当前请求的主机头、方案、端口和路径来创建各种头。</p>
<p>可以通过以下布尔属性（默认为 true）控制单个header的创建：</p>
<ul>
<li><code>spring.cloud.gateway.x-forwarded.for-enabled</code></li>
<li><code>spring.cloud.gateway.x-forwarded.host-enabled</code></li>
<li><code>spring.cloud.gateway.x-forwarded.port-enabled</code></li>
<li><code>spring.cloud.gateway.x-forwarded.proto-enabled</code></li>
<li><code>spring.cloud.gateway.x-forwarded.prefix-enabled</code></li>
</ul>
<p>附加多个header可以由以下布尔属性控制（默认为 true）：</p>
<ul>
<li><code>spring.cloud.gateway.x-forwarded.for-append</code></li>
<li><code>spring.cloud.gateway.x-forwarded.host-append</code></li>
<li><code>spring.cloud.gateway.x-forwarded.port-append</code></li>
<li><code>spring.cloud.gateway.x-forwarded.proto-append</code></li>
<li><code>spring.cloud.gateway.x-forwarded.prefix-append</code></li>
</ul>
<h2 id="9-TLS-和-SSL"><a href="#9-TLS-和-SSL" class="headerlink" title="9. TLS 和 SSL"></a>9. TLS 和 SSL</h2><p>网关可以通过遵循通常的 Spring 服务器配置来侦听 HTTPS 上的请求。以下示例显示了如何执行此操作：</p>
<p><strong>Example 58. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">key-alias:</span> <span class="string">scg</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="string">scg1234</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:scg-keystore.p12</span></span><br><span class="line">    <span class="attr">key-store-type:</span> <span class="string">PKCS12</span></span><br></pre></td></tr></table></figure>

<p>您可以将网关路由路由到 HTTP 和 HTTPS 后端。如果要路由到 HTTPS 后端，则可以使用以下配置将网关配置为信任所有下游证书：</p>
<p><strong>Example 59. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">httpclient:</span></span><br><span class="line">        <span class="attr">ssl:</span></span><br><span class="line">          <span class="attr">useInsecureTrustManager:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>使用不安全的信任管理器不适合生产。对于生产部署，您可以使用一组可以信任的已知证书配置网关，并使用以下配置：</p>
<p><strong>Example 60. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">httpclient:</span></span><br><span class="line">        <span class="attr">ssl:</span></span><br><span class="line">          <span class="attr">trustedX509Certificates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cert1.pem</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">cert2.pem</span></span><br></pre></td></tr></table></figure>

<p>如果 Spring Cloud Gateway 未提供受信任的证书，则使用默认信任存储（您可以通过设置 javax.net.ssl.trustStore 系统属性来覆盖）。</p>
<h3 id="9-1-TLS-握手"><a href="#9-1-TLS-握手" class="headerlink" title="9.1. TLS 握手"></a>9.1. TLS 握手</h3><p>网关维护一个客户端池，用于路由到后端。通过 HTTPS 通信时，客户端会发起 TLS 握手。许多超时与此握手相关联。您可以配置这些超时可以配置（默认显示）如下：</p>
<p><strong>Example 61. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">httpclient:</span></span><br><span class="line">        <span class="attr">ssl:</span></span><br><span class="line">          <span class="attr">handshake-timeout-millis:</span> <span class="number">10000</span></span><br><span class="line">          <span class="attr">close-notify-flush-timeout-millis:</span> <span class="number">3000</span></span><br><span class="line">          <span class="attr">close-notify-read-timeout-millis:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="10-配置"><a href="#10-配置" class="headerlink" title="10. 配置"></a>10. 配置</h2><p>Spring Cloud Gateway 的配置由一组 RouteDefinitionLocator 实例驱动。以下清单显示了 RouteDefinitionLocator 接口的定义：</p>
<p><strong>Example 62. RouteDefinitionLocator.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RouteDefinitionLocator</span> </span>&#123;</span><br><span class="line">    <span class="function">Flux&lt;RouteDefinition&gt; <span class="title">getRouteDefinitions</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，PropertiesRouteDefinitionLocator 使用 Spring Boot 的 @ConfigurationProperties 机制加载属性。</p>
<p>较早的配置示例都使用使用位置参数而不是命名参数的快捷表示法。下面两个例子是等价的：</p>
<p><strong>Example 63. application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">setstatus_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SetStatus</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">status:</span> <span class="number">401</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">setstatusshortcut_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SetStatus=401</span></span><br></pre></td></tr></table></figure>

<p>对于网关的某些用途，属性就足够了，但某些生产用例受益于从外部源（例如数据库）加载配置。未来的里程碑版本将具有基于 Spring Data Repositories 的 RouteDefinitionLocator 实现，例如 Redis、MongoDB 和 Cassandra。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Gateway</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Gateway</tag>
      </tags>
  </entry>
</search>
